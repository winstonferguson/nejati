"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.listDeletedFiles = exports.bulkRestoreFilesFromTrashBin = exports.bulkDeleteFiles = exports.generateVideoStreamingUrl = exports.searchFiles = exports.listFiles = exports.bulkImportFiles = exports.importFile = exports.generateFileResumableUploadUrl = exports.generateFileUploadUrl = exports.updateFileDescriptor = exports.getFileDescriptors = exports.getFileDescriptor = exports.generateFileDownloadUrl = exports.generateFilesDownloadUrl = exports.StreamFormat = exports.RootFolder = exports.SortOrder = exports.UploadProtocol = exports.State = exports.OperationStatus = exports.MediaType = exports.__debug = void 0;
const velo_1 = require("@wix/metro-runtime/velo");
const ambassadorWixMediaSiteMediaV1FileDescriptor = __importStar(require("./media-site-media-v1-file-descriptor.http"));
let __verbose = false;
function __log(...args) {
    __verbose && console.log(...args);
}
function __inspect(obj) {
    return obj;
}
exports.__debug = {
    verboseLogging: {
        on: () => (__verbose = true),
        off: () => (__verbose = false),
    },
};
const _toVeloEntity = '$';
const _fromVeloEntity = '$';
var MediaType;
(function (MediaType) {
    MediaType["UNKNOWN"] = "UNKNOWN";
    MediaType["IMAGE"] = "IMAGE";
    MediaType["VIDEO"] = "VIDEO";
    MediaType["AUDIO"] = "AUDIO";
    MediaType["DOCUMENT"] = "DOCUMENT";
    MediaType["VECTOR"] = "VECTOR";
    MediaType["ARCHIVE"] = "ARCHIVE";
    MediaType["MODEL3D"] = "MODEL3D";
    MediaType["OTHER"] = "OTHER";
})(MediaType = exports.MediaType || (exports.MediaType = {}));
var OperationStatus;
(function (OperationStatus) {
    /** File upload or processing failed */
    OperationStatus["FAILED"] = "FAILED";
    /** File is ready for consumption */
    OperationStatus["READY"] = "READY";
    /** File is waiting for processing or currently being processed */
    OperationStatus["PENDING"] = "PENDING";
})(OperationStatus = exports.OperationStatus || (exports.OperationStatus = {}));
var State;
(function (State) {
    State["OK"] = "OK";
    State["DELETED"] = "DELETED";
})(State = exports.State || (exports.State = {}));
var UploadProtocol;
(function (UploadProtocol) {
    /** The upload protocol to use for implementing the resumable upload. */
    UploadProtocol["TUS"] = "TUS";
})(UploadProtocol = exports.UploadProtocol || (exports.UploadProtocol = {}));
var SortOrder;
(function (SortOrder) {
    SortOrder["ASC"] = "ASC";
    SortOrder["DESC"] = "DESC";
})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));
var RootFolder;
(function (RootFolder) {
    /** Root of all site media */
    RootFolder["MEDIA_ROOT"] = "MEDIA_ROOT";
    /** Root of the trash system folder */
    RootFolder["TRASH_ROOT"] = "TRASH_ROOT";
    /** Root of all visitor uploads */
    RootFolder["VISITOR_UPLOADS_ROOT"] = "VISITOR_UPLOADS_ROOT";
})(RootFolder = exports.RootFolder || (exports.RootFolder = {}));
var StreamFormat;
(function (StreamFormat) {
    StreamFormat["UNKNOWN"] = "UNKNOWN";
    StreamFormat["HLS"] = "HLS";
    StreamFormat["DASH"] = "DASH";
})(StreamFormat = exports.StreamFormat || (exports.StreamFormat = {}));
const _audioV2 = { assets: 'wix.common.Audio' };
const _bulkDeleteFilesRequest = {};
const _bulkDeleteFilesResponse = {};
const _bulkImportFilesRequest = { importFileRequests: '_importFileRequest' };
const _bulkImportFilesResponse = { files: '_fileDescriptor' };
const _bulkRestoreFilesFromTrashBinRequest = {};
const _bulkRestoreFilesFromTrashBinResponse = {};
const _fileDescriptor = { media: '_fileMedia' };
const _fileMedia = {
    video: 'wix.common.VideoV2',
    document: 'wix.common.Document',
    image: '_imageMedia',
    audio: '_audioV2',
    vector: '_imageMedia',
    model3d: '_model3D',
};
const _generateFileDownloadUrlRequest = {};
const _generateFileDownloadUrlResponse = {};
const _generateFileResumableUploadUrlRequest = {};
const _generateFileResumableUploadUrlResponse = {};
const _generateFilesDownloadUrlRequest = {};
const _generateFilesDownloadUrlResponse = {};
const _generateFileUploadUrlRequest = {};
const _generateFileUploadUrlResponse = {};
const _generateVideoStreamingUrlRequest = {};
const _generateVideoStreamingUrlResponse = {};
const _getFileDescriptorRequest = {};
const _getFileDescriptorResponse = { file: '_fileDescriptor' };
const _getFileDescriptorsRequest = {};
const _getFileDescriptorsResponse = { files: '_fileDescriptor' };
const _imageMedia = {
    image: 'wix.common.Image',
    previewImage: 'wix.common.Image',
};
const _importFileRequest = {};
const _importFileResponse = { file: '_fileDescriptor' };
const _listDeletedFilesRequest = {};
const _listDeletedFilesResponse = { files: '_fileDescriptor' };
const _listFilesRequest = {};
const _listFilesResponse = { files: '_fileDescriptor' };
const _model3D = { thumbnail: 'wix.common.Image' };
const _searchFilesRequest = {};
const _searchFilesResponse = { files: '_fileDescriptor' };
const _updateFileDescriptorRequest = { file: '_fileDescriptor' };
const _updateFileDescriptorResponse = { file: '_fileDescriptor' };
/**
 * Generates a URL for downloading a compressed file containing specific files in the Media Manager.
 *
 * The compressed file can contain up to 1000 files.
 * @param fileIds - IDs of the files to download.
 * @public
 * @requiredField fileIds
 * @permissionScope Manage Media Manager
 * @applicableIdentity APP
 */
function generateFilesDownloadUrl(fileIds) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = { fileIds: '$[0]' };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[1];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _generateFilesDownloadUrlRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _generateFilesDownloadUrlResponse,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([fileIds]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.generateFilesDownloadUrl(payload);
        __log(`"GenerateFilesDownloadUrl" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'fileIds',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.generateFilesDownloadUrl = generateFilesDownloadUrl;
/**
 * Generates one or more temporary URLs for downloading a specific file in the Media Manager.
 *
 * To download different assets of the file, use the `assetKeys` parameter which generates a download URL for each asset.
 * If no `assetKey` is specified, it defaults to `src`, which generates one download URL in the original file's format and quality.
 *
 * Use this endpoint to grant external clients access to a private media file. Use the `expirationInMinutes` parameter to set the URL expiration time, and the `expirationRedirectUrl` parameter to add a redirect url when the URL expires.
 * @param fileId - File ID.
 * @public
 * @requiredField fileId
 * @param options - Options to use when generating a file's download URL.
 * @permissionScope Manage Media Manager
 * @applicableIdentity APP
 */
function generateFileDownloadUrl(fileId, options) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = {
            fileId: '$[0]',
            downloadFileName: '$[1].downloadFileName',
            expirationInMinutes: '$[1].expirationInMinutes',
            expirationRedirectUrl: '$[1].expirationRedirectUrl',
            assetKeys: '$[1].assetKeys',
        };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[2];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _generateFileDownloadUrlRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _generateFileDownloadUrlResponse,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([fileId, options]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.generateFileDownloadUrl(payload);
        __log(`"GenerateFileDownloadUrl" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'fileId',
                'options',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.generateFileDownloadUrl = generateFileDownloadUrl;
/**
 * Gets information about a specific file in the Media Manager.
 * @param fileId - File ID.
 * @public
 * @requiredField fileId
 * @permissionScope Read Media Manager
 * @applicableIdentity APP
 * @returns Information about the file.
 */
function getFileDescriptor(fileId) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = { fileId: '$[0]' };
        const responseTransformation = '$.file';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[1];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _getFileDescriptorRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _getFileDescriptorResponse,
            depSchemas: {
                _audioV2,
                _fileDescriptor,
                _fileMedia,
                _imageMedia,
                _model3D,
            },
            fqdnTransformation: {
                paths: [...['file']],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([fileId]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.getFileDescriptor(payload);
        __log(`"GetFileDescriptor" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'fileId',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.getFileDescriptor = getFileDescriptor;
/**
 * Gets information about the specified files in the Media Manager.
 * @param fileIds - File IDs.
 * @public
 * @requiredField fileIds
 * @permissionScope Read Media Manager
 * @applicableIdentity APP
 */
function getFileDescriptors(fileIds) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = { fileIds: '$[0]' };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[1];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _getFileDescriptorsRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _getFileDescriptorsResponse,
            depSchemas: {
                _audioV2,
                _fileDescriptor,
                _fileMedia,
                _imageMedia,
                _model3D,
            },
            fqdnTransformation: {
                paths: [...['Array#files']],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([fileIds]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.getFileDescriptors(payload);
        __log(`"GetFileDescriptors" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'fileIds',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.getFileDescriptors = getFileDescriptors;
/**
 * Updates a file. <br />
 *
 * You can use the `parentFolderId` parameter to move a file from its current folder to a different folder.
 * @param _id - File ID. Generated when a file is uploaded to the Media Manager.
 * @public
 * @requiredField _id
 * @requiredField file
 * @permissionScope Manage Media Manager
 * @applicableIdentity APP
 * @returns Information about the updated file.
 */
function updateFileDescriptor(_id, file) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = { file: { '*': '$[1]', id: '$[0]' } };
        const responseTransformation = '$.file';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[2];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _updateFileDescriptorRequest,
            depSchemas: {
                _audioV2,
                _fileDescriptor,
                _fileMedia,
                _imageMedia,
                _model3D,
            },
            fqdnTransformation: {
                paths: [...['file']],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _updateFileDescriptorResponse,
            depSchemas: {
                _audioV2,
                _fileDescriptor,
                _fileMedia,
                _imageMedia,
                _model3D,
            },
            fqdnTransformation: {
                paths: [...['file']],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([_id, file]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.updateFileDescriptor(payload);
        __log(`"UpdateFileDescriptor" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                '_id',
                'file',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.updateFileDescriptor = updateFileDescriptor;
/**
 * Generates an upload URL to allow external clients to upload a file to the Media Manager.
 *
 * To learn how external clients can use the generated upload URL in the response to upload a file to the Media Manager, see the [Upload API](#upload-api).
 *
 * > **Note:** Any interruption in the upload process stops the file upload. For files larger than 10MB, or when network connection is poor, use the [Generate File Resumable Upload Url](#generatefileresumableuploadurl) instead. With the resumable upload URL, any interruption in the upload process pauses the file upload, and resumes the file upload process after the interruption.
 * @param mimeType - File mime type.
 * @public
 * @requiredField mimeType
 * @param options - Options to use when generating a file's upload URL.
 * @permissionScope Manage Media Manager
 * @applicableIdentity APP
 */
function generateFileUploadUrl(mimeType, options) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = {
            mimeType: '$[0]',
            fileName: '$[1].fileName',
            sizeInBytes: '$[1].sizeInBytes',
            parentFolderId: '$[1].parentFolderId',
            private: '$[1].private',
            labels: '$[1].labels',
            externalInfo: '$[1].externalInfo',
        };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[2];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _generateFileUploadUrlRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _generateFileUploadUrlResponse,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([mimeType, options]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.generateFileUploadUrl(payload);
        __log(`"GenerateFileUploadUrl" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'mimeType',
                'options',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.generateFileUploadUrl = generateFileUploadUrl;
/**
 * Generates a resumable upload URL to allow external clients to easily upload large files over 10MB to the Media Manager.
 *
 * With the resumable upload URL, any interruptions in the upload process pauses the file upload, and resumes the file upload process after the interruption. The resumable upload URL is also helpful when network connection is poor.
 *
 * To learn how external clients can use the generated upload URL in the response to upload large files to the Media Manager, see the [Resumable Upload API](#resumable-upload-api) article.
 * @param mimeType - File mime type.
 * @public
 * @requiredField mimeType
 * @param options - Options to use when generating a resumable upload URL.
 * @permissionScope Manage Media Manager
 * @applicableIdentity APP
 */
function generateFileResumableUploadUrl(mimeType, options) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = {
            mimeType: '$[0]',
            fileName: '$[1].fileName',
            sizeInBytes: '$[1].sizeInBytes',
            parentFolderId: '$[1].parentFolderId',
            private: '$[1].private',
            labels: '$[1].labels',
            uploadProtocol: '$[1].uploadProtocol',
        };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[2];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _generateFileResumableUploadUrlRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _generateFileResumableUploadUrlResponse,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([mimeType, options]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.generateFileResumableUploadUrl(payload);
        __log(`"GenerateFileResumableUploadUrl" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'mimeType',
                'options',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.generateFileResumableUploadUrl = generateFileResumableUploadUrl;
/**
 * Imports a file to the Media Manager using an external url.
 *
 * This function returns information about the imported file.
 * Use the `parentFolderId` parameter to specify which folder you want the file to be imported to.
 * If no folder is specified, the file is imported to the `media-root` folder.
 *
 * To import a file, you need to provide one of the following:
 * 1. Pass the file's [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) in the `mimeType` parameter of the request. For example, `'image/png'`.
 * 2. Pass the file's name and extension. For example, `'my-image.png'`.
 * 3. If you don't know the file's extension or MIME type, pass its [media type](https://support.wix.com/en/article/wix-media-supported-media-file-types-and-file-sizes) in the `mediaType` parameter of the request. For example, `'IMAGE'`. Note that this option only works if the server hosting the media allows a 'HEAD' request.
 *
 * >**Note:** The `media` property isn't returned in the `files` response object.
 *
 * @param url - Publicly accessible external file URL.
 * @public
 * @requiredField url
 * @param options - Options to use when importing a single file.
 * @permissionScope Manage Media Manager
 * @applicableIdentity APP
 */
function importFile(url, options) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = {
            url: '$[0]',
            mediaType: '$[1].mediaType',
            displayName: '$[1].displayName',
            parentFolderId: '$[1].parentFolderId',
            private: '$[1].private',
            labels: '$[1].labels',
            mimeType: '$[1].mimeType',
            externalInfo: '$[1].externalInfo',
            urlParams: '$[1].urlParams',
            urlHeaders: '$[1].urlHeaders',
        };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[2];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _importFileRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _importFileResponse,
            depSchemas: {
                _audioV2,
                _fileDescriptor,
                _fileMedia,
                _imageMedia,
                _model3D,
            },
            fqdnTransformation: {
                paths: [...['file']],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([url, options]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.importFile(payload);
        __log(`"ImportFile" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'url',
                'options',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.importFile = importFile;
/**
 * Imports a bulk of files to the Media Manager using external urls.
 *
 * Returns information about the imported files. Use the `parentFolderId` parameter to specify in which folder you want each file to be imported to.
 * If no folder is specified, the file is imported to the `media-root` folder.
 *
 * To import files, you need to provide one of the following:
 * 1. Pass each file's [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) in the `mimeType` parameter of the request. For example, `'image/png'`.
 * 2. Pass each file's name and extension. For example, `'my-image.png'`.
 * 3. If you don't know a file's extension or MIME type, pass its [media type](https://support.wix.com/en/article/wix-media-supported-media-file-types-and-file-sizes) in the `mediaType` parameter of the request. For example, `'IMAGE'`. Note that this option only works if the server hosting the media allows a 'HEAD' request.
 *
 * >**Note:** The `media` property isn't returned in the `files` response object.
 * @param importFileRequests - Information about the files to import.
 * @public
 * @requiredField importFileRequests
 * @requiredField importFileRequests.url
 * @param options - Options to use when uploading multiple files.
 * @permissionScope Manage Media Manager
 * @applicableIdentity APP
 */
function bulkImportFiles(importFileRequests) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = { importFileRequests: '$[0]' };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[1];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _bulkImportFilesRequest,
            depSchemas: { _importFileRequest },
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _bulkImportFilesResponse,
            depSchemas: {
                _audioV2,
                _fileDescriptor,
                _fileMedia,
                _imageMedia,
                _model3D,
            },
            fqdnTransformation: {
                paths: [...['Array#files']],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([importFileRequests]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.bulkImportFiles(payload);
        __log(`"BulkImportFiles" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'importFileRequests',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.bulkImportFiles = bulkImportFiles;
/**
 * Retrieves a list of files in the Media Manager.
 *
 * To retrieve a list of files within a specific folder in the Media Manager, pass the folder's ID in the `parentFolderId` parameter. If no folder is specified, the endpoint retrieves the list of files in the root folder of the Media Manager.
 * @public
 * @param options - Options to use when listing media files.
 * @permissionScope Read Media Manager
 * @applicableIdentity APP
 */
function listFiles(options) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = {
            parentFolderId: '$[0].parentFolderId',
            mediaTypes: '$[0].mediaTypes',
            private: '$[0].private',
            sort: '$[0].sort',
            paging: '$[0].paging',
        };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[1];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _listFilesRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _listFilesResponse,
            depSchemas: {
                _audioV2,
                _fileDescriptor,
                _fileMedia,
                _imageMedia,
                _model3D,
            },
            fqdnTransformation: {
                paths: [...['Array#files']],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([options]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.listFiles(payload);
        __log(`"ListFiles" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'options',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.listFiles = listFiles;
/**
 * Searches all folders in the Media Manager and returns a list of files that match the terms specified in the optional parameters.
 *
 * If no parameters are specified, the endpoint returns all files in the `MEDIA_ROOT` folder.
 * @public
 * @param options - Options to specify which folders to search.
 * @permissionScope Read Media Manager
 * @applicableIdentity APP
 */
function searchFiles(options) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = {
            search: '$[0].search',
            rootFolder: '$[0].rootFolder',
            mediaTypes: '$[0].mediaTypes',
            private: '$[0].private',
            sort: '$[0].sort',
            paging: '$[0].paging',
        };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[1];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _searchFilesRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _searchFilesResponse,
            depSchemas: {
                _audioV2,
                _fileDescriptor,
                _fileMedia,
                _imageMedia,
                _model3D,
            },
            fqdnTransformation: {
                paths: [...['Array#files']],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([options]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.searchFiles(payload);
        __log(`"SearchFiles" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'options',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.searchFiles = searchFiles;
/**
 * Generates a URL for streaming a specific video file in the Media Manager.
 * @param fileId - File ID.
 * @public
 * @requiredField fileId
 * @param options - Options to use when generating a video file's streaming URL.
 * @permissionScope Read Media Manager
 * @applicableIdentity APP
 */
function generateVideoStreamingUrl(fileId, options) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = { fileId: '$[0]', format: '$[1].format' };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[2];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _generateVideoStreamingUrlRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _generateVideoStreamingUrlResponse,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([fileId, options]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.generateVideoStreamingUrl(payload);
        __log(`"GenerateVideoStreamingUrl" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'fileId',
                'options',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.generateVideoStreamingUrl = generateVideoStreamingUrl;
/**
 * Deletes the specified files from the Media Manager.
 *
 *
 * The deleted files are moved to the Media Manager's trash bin (`TRASH-ROOT` folder) unless permanently deleted. To permanently delete files, pass the `permanent` parameter with the value `true`. Permanently deleting files isn't reversible, so make sure that these files aren't being used in a site or in any other way as the files will no longer be accessible.
 *
 * >**Notes:**
 * > - The specified files can be from different folders.
 * > - Moving multiple files at once is an asynchronous action, and may take time for the changes to appear in the Media Manager.
 * > - Attempting to delete files that are already in the trash bin doesn't result in an error.
 * > - If your site contains deleted media files, the deleted media files still appear on your site as the files are still in the Media Manager (in the trash bin).
 * > - You can use the [Bulk Restore Files From Trash Bin](#bulkrestorefilesfromtrashbin) endpoint to restore files from the Media Manager's trash bin.
 * @param fileIds - IDs of the files to move to the Media Manager's trash bin.
 * @public
 * @requiredField fileIds
 * @param options - Options to use when deleting files.
 * @permissionScope Manage Media Manager
 * @applicableIdentity APP
 */
function bulkDeleteFiles(fileIds, options) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = {
            fileIds: '$[0]',
            permanent: '$[1].permanent',
        };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[2];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _bulkDeleteFilesRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _bulkDeleteFilesResponse,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([fileIds, options]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.bulkDeleteFiles(payload);
        __log(`"BulkDeleteFiles" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'fileIds',
                'options',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.bulkDeleteFiles = bulkDeleteFiles;
/**
 * Restores the specified files from the Media Manager's trash bin, and moves them to their original locations in the Media Manager.
 * @param fileIds - IDs of the files to restore from the Media Manager's trash bin.
 * @public
 * @requiredField fileIds
 * @permissionScope Manage Media Manager
 * @applicableIdentity APP
 */
function bulkRestoreFilesFromTrashBin(fileIds) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = { fileIds: '$[0]' };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[1];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _bulkRestoreFilesFromTrashBinRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _bulkRestoreFilesFromTrashBinResponse,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([fileIds]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.bulkRestoreFilesFromTrashBin(payload);
        __log(`"BulkRestoreFilesFromTrashBin" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'fileIds',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.bulkRestoreFilesFromTrashBin = bulkRestoreFilesFromTrashBin;
/**
 * Retrieves a list of files in the Media Manager's trash bin.
 *
 * >**Note:** The Media Manager's trash bin (`TRASH-ROOT` folder) only contains temporarily deleted files, not permanently deleted files.
 * @public
 * @param options - Options to use when listing deleted files from the trash bin.
 * @permissionScope Read Media Manager
 * @applicableIdentity APP
 */
function listDeletedFiles(options) {
    var _a, _b, _c;
    return __awaiter(this, arguments, void 0, function* () {
        const requestTransformation = {
            parentFolderId: '$[0].parentFolderId',
            mediaTypes: '$[0].mediaTypes',
            private: '$[0].private',
            sort: '$[0].sort',
            paging: '$[0].paging',
        };
        const responseTransformation = '$';
        // @ts-ignore
        const { httpClient, sideEffects } = arguments[1];
        const { toAmbassadorRequest } = (0, velo_1.serializer)({
            rootSchema: _listDeletedFilesRequest,
            depSchemas: {},
            fqdnTransformation: {
                paths: [],
                transformation: _fromVeloEntity,
            },
            customTransformation: requestTransformation,
        });
        const { fromJSON } = (0, velo_1.serializer)({
            rootSchema: _listDeletedFilesResponse,
            depSchemas: {
                _audioV2,
                _fileDescriptor,
                _fileMedia,
                _imageMedia,
                _model3D,
            },
            fqdnTransformation: {
                paths: [...['Array#files']],
                transformation: _toVeloEntity,
            },
            customTransformation: responseTransformation,
        });
        const payload = toAmbassadorRequest([options]);
        const reqOpts = ambassadorWixMediaSiteMediaV1FileDescriptor.listDeletedFiles(payload);
        __log(`"ListDeletedFiles" sending request with: ${__inspect(reqOpts)}`);
        (_a = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSiteCall) === null || _a === void 0 ? void 0 : _a.call(sideEffects);
        try {
            const result = yield httpClient.request(reqOpts);
            (_b = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onSuccess) === null || _b === void 0 ? void 0 : _b.call(sideEffects, result);
            return fromJSON(result.data);
        }
        catch (err) {
            const transformedError = (0, velo_1.transformError)(err, requestTransformation, [
                'options',
            ]);
            (_c = sideEffects === null || sideEffects === void 0 ? void 0 : sideEffects.onError) === null || _c === void 0 ? void 0 : _c.call(sideEffects, err);
            throw transformedError;
        }
    });
}
exports.listDeletedFiles = listDeletedFiles;
//# sourceMappingURL=media-site-media-v1-file-descriptor.universal.js.map