{"version":3,"names":["_imageServiceConstants","require","_utils","SUPPORTED_IMAGE_EXTENSIONS","fileType","PNG","JPEG","JPG","JPE","WIX_ICO_MP","WIX_MP","WEBP","JPG_EXTENSIONS","isImageTypeSupported","uri","includes","getFileExtension","isValidRequest","fittingType","src","target","isUrlEmptyOrNone","id","Object","values","fittingTypes","isImageTransformApplicable","hasAnimation","isNotTransformableWEBP","isExternalUrl","isWEBP","isJPG","isPNG","url","test","trim","toLowerCase","isSEOBot","options","ILLEGAL_CHARS","map","encodeURIComponent","URL_SAFE_ILLEGAL_CHARS","ILLEGAL_CHARS_REPLACEMENT","getFileName","name","beforeLeadingSlashRegexp","fileExtensionRegexp","illegalCharsRegex","RegExp","concat","join","length","fileName","extension","match","replace","trimmed","getFileType","UNRECOGNIZED","splitURI","exec","getFitScaleFactor","sWidth","sHeight","dWidth","dHeight","Math","min","getFillScaleFactor","max","getScaleFactor","transformType","scaleFactor","transformTypes","FILL","FIT","getSafeTransformData","width","height","SAFE_TRANSFORMED_AREA","dimensionScaleFactor","sqrt","getTransformData","dpr","upscaleMethod","getOptimizedTransformData","getFocalPointFrom9GridAlignment","alignment","alignTypes","CENTER","ALIGN_TYPE_TO_FOCAL_POINT","getAlignedRect","sRect","dRect","sFP","fp","getFocalPoint","x","y","getOverlappingRect","isValidRect","getDevicePixelRatio","pixelAspectRatio","MAX_DEVICE_PIXEL_RATIO","getAlignment","alignTypesMap","focalPoint","isNaN","roundToFixed","getPreferredImageQuality","imageWidth","imageHeight","imageScaleDefaults","getImageQualityKey","quality","getClassicScaleData","imageKey","optimizedScaleFactor","maxUpscale","upscaleMethodValue","upscaleMethodsValues","classic","forceUSM","getAutoScaleData","getSuperScaleData","last","SUPER_UPSCALE_MODELS","super","getOptimizedScaleData","tWidth","tHeight","cssUpscaleNeeded","size","imageQuality","HIGH","MEDIUM","LOW","TINY","getDimension","round","value","precision","truncatePrecision","pow","toFixed","getUpscaleString","upscaleMethods","AUTO","toUpperCase"],"sources":["../../../src/helpers/imageServiceUtils.ts"],"sourcesContent":["import {\n  alignTypes,\n  alignTypesMap,\n  fileType,\n  fittingTypes,\n  imageQuality,\n  imageScaleDefaults,\n  transformTypes,\n  upscaleMethods,\n  upscaleMethodsValues,\n  ALIGN_TYPE_TO_FOCAL_POINT,\n  MAX_DEVICE_PIXEL_RATIO,\n  SUPER_UPSCALE_MODELS,\n  SAFE_TRANSFORMED_AREA,\n} from './imageServiceConstants';\nimport { last } from './utils';\nimport type {\n  FileType,\n  AlignType,\n  FittingType,\n  TransformType,\n  UpscaleMethod,\n  ImageQuality,\n  ImageTransformData,\n  ImageTransformOptions,\n  ImageTransformSource,\n  ImageTransformTarget,\n} from '../types';\n\nconst SUPPORTED_IMAGE_EXTENSIONS: Partial<FileType>[] = [\n  fileType.PNG,\n  fileType.JPEG,\n  fileType.JPG,\n  fileType.JPE,\n  fileType.WIX_ICO_MP,\n  fileType.WIX_MP,\n  fileType.WEBP,\n];\n\nconst JPG_EXTENSIONS: Partial<FileType>[] = [\n  fileType.JPEG,\n  fileType.JPG,\n  fileType.JPE,\n];\n\n/**\n * checks if image type is supported\n * @param {string}     uri      image source uri\n *\n * @returns {boolean}\n */\nfunction isImageTypeSupported(uri: string) {\n  return SUPPORTED_IMAGE_EXTENSIONS.includes(\n    getFileExtension(uri) as Partial<FileType>,\n  );\n}\n\n/**\n * check request integrity\n * @param {FittingType}             fittingType         imageService.fittingTypes\n * @param {ImageTransformSource}    src\n * @param {ImageTransformTarget}    target\n *\n * @returns {boolean}\n */\nfunction isValidRequest(\n  fittingType: FittingType,\n  src: ImageTransformSource,\n  target: ImageTransformTarget,\n) {\n  return (\n    target &&\n    src &&\n    !isUrlEmptyOrNone(src.id) &&\n    Object.values(fittingTypes).includes(fittingType)\n  );\n}\n\n/**\n * check if image transform is supported for source image\n * @param {string}     uri\n *\n * @returns {boolean}\n */\nfunction isImageTransformApplicable(uri: string, hasAnimation?: boolean) {\n  return (\n    !isNotTransformableWEBP(uri, hasAnimation) &&\n    isImageTypeSupported(uri) &&\n    !isExternalUrl(uri)\n  );\n}\n\n/**\n * returns true if image is of WEBP type and could be animated\n * (ie. image has hasAnimation true or was added before hasAnimation flag was created)\n *\n * @param {string} uri\n * @param {boolean} hasAnimation\n * @returns {boolean}\n */\nfunction isNotTransformableWEBP(uri: string, hasAnimation: boolean = true) {\n  return isWEBP(uri) && hasAnimation;\n}\n\n/**\n * returns true if image is of JPG type\n * @param {string}  uri\n *\n * @returns {boolean}\n */\nfunction isJPG(uri: string) {\n  return JPG_EXTENSIONS.includes(getFileExtension(uri) as Partial<FileType>);\n}\n\n/**\n * returns true if image is of PNG type\n * @param {string}  uri\n *\n * @returns {boolean}\n */\nfunction isPNG(uri: string) {\n  return getFileExtension(uri) === fileType.PNG;\n}\n\n/**\n * returns true if image is of webP type\n * @param {string}  uri\n *\n * @returns {boolean}\n */\nfunction isWEBP(uri: string) {\n  return getFileExtension(uri) === fileType.WEBP;\n}\n\n/**\n * returns true if the url starts with http, https, // or data\n * @param {string}  url\n *\n * @returns {boolean}\n */\nfunction isExternalUrl(url: string) {\n  return /(^https?)|(^data)|(^\\/\\/)/.test(url);\n}\n\n/**\n * returns true if the url empty or none string\n * @param {string}  url\n *\n * @returns {boolean}\n */\nfunction isUrlEmptyOrNone(url: string) {\n  return !url || !url.trim() || url.toLowerCase() === 'none';\n}\n\n/**\n * returns search bot true or false as indicated in options\n * @param {ImageTransformOptions}   options\n *\n * @returns {boolean}\n */\nfunction isSEOBot(options?: ImageTransformOptions) {\n  return options?.isSEOBot ?? false;\n}\n\n// https://jira.wixpress.com/browse/WEED-12667\n// const illegalChars = ['/', '\\\\', '#', '^', '?', '{', '}', '<', '>', '|', '`', '“', ':', '\"'].map(encodeURIComponent)\nconst ILLEGAL_CHARS = ['/', '\\\\', '?', '<', '>', '|', '“', ':', '\"'].map(\n  encodeURIComponent,\n);\nconst URL_SAFE_ILLEGAL_CHARS = ['\\\\.', '\\\\*'];\nconst ILLEGAL_CHARS_REPLACEMENT = '_';\n\n/**\n * returns source image file name (no extension)\n * @param {string}     uri      image source uri\n * @param {string}     [name]   optional image source name\n *\n * @returns {string}\n */\nfunction getFileName(uri: string, name?: string) {\n  const beforeLeadingSlashRegexp = /\\/(.*?)$/;\n  const fileExtensionRegexp = /\\.([^.]*)$/;\n  const illegalCharsRegex = new RegExp(\n    `(${ILLEGAL_CHARS.concat(URL_SAFE_ILLEGAL_CHARS).join('|')})`,\n    'g',\n  );\n\n  // if name is a non empty string, remove only supported extension if exists and url encode the string\n  if (name && name.length) {\n    let fileName = name;\n\n    const extension = name.match(fileExtensionRegexp);\n\n    if (\n      extension &&\n      SUPPORTED_IMAGE_EXTENSIONS.includes(extension[1] as Partial<FileType>)\n    ) {\n      fileName = name.replace(fileExtensionRegexp, '');\n    }\n\n    return encodeURIComponent(fileName).replace(\n      illegalCharsRegex,\n      ILLEGAL_CHARS_REPLACEMENT,\n    );\n  }\n\n  // else, trim any preceding media structure from the uri string (like \"media/\" etc.) and remove extension\n  const trimmed = uri.match(beforeLeadingSlashRegexp);\n  const fileName = trimmed ? trimmed[1] : uri;\n  return fileName.replace(fileExtensionRegexp, '');\n}\n\n/**\n * returns source image file name (no extension)\n * @param {string}     uri      image source uri\n *\n * @returns {FileType}\n */\nfunction getFileType(uri: string) {\n  if (isJPG(uri)) {\n    return fileType.JPG;\n  } else if (isPNG(uri)) {\n    return fileType.PNG;\n  } else if (isWEBP(uri)) {\n    return fileType.WEBP;\n  }\n  return fileType.UNRECOGNIZED;\n}\n\n/**\n * returns source image file extension\n * @param {string}     uri      image source uri\n *\n * @returns {string}\n */\nfunction getFileExtension(uri: string) {\n  const splitURI = /[.]([^.]+)$/.exec(uri);\n  return ((splitURI && /[.]([^.]+)$/.exec(uri)![1]) || '').toLowerCase();\n}\n\n/**\n * returns scale factor needed if FIT fitting\n * @param {number}  sWidth\n * @param {number}  sHeight\n * @param {number}  dWidth\n * @param {number}  dHeight\n *\n * @returns {number}\n */\nfunction getFitScaleFactor(\n  sWidth: number,\n  sHeight: number,\n  dWidth: number,\n  dHeight: number,\n) {\n  return Math.min(dWidth / sWidth, dHeight / sHeight);\n}\n\n/**\n * returns scale factor needed if FILL fitting\n * @param {number}  sWidth\n * @param {number}  sHeight\n * @param {number}  dWidth\n * @param {number}  dHeight\n *\n * @returns {number}\n */\nfunction getFillScaleFactor(\n  sWidth: number,\n  sHeight: number,\n  dWidth: number,\n  dHeight: number,\n) {\n  return Math.max(dWidth / sWidth, dHeight / sHeight);\n}\n\n/**\n * returns scale factor source target\n * @param {number}  sWidth\n * @param {number}  sHeight\n * @param {number}  dWidth\n * @param {number}  dHeight\n * @param {string}  transformType\n *\n * @returns {number}\n */\nfunction getScaleFactor(\n  sWidth: number,\n  sHeight: number,\n  dWidth: number,\n  dHeight: number,\n  transformType: TransformType,\n) {\n  let scaleFactor;\n\n  if (transformType === transformTypes.FILL) {\n    scaleFactor = getFillScaleFactor(sWidth, sHeight, dWidth, dHeight);\n  } else if (transformType === transformTypes.FIT) {\n    scaleFactor = getFitScaleFactor(sWidth, sHeight, dWidth, dHeight);\n  } else {\n    scaleFactor = 1;\n  }\n\n  return scaleFactor;\n}\n\n/**\n * get calculated scale factor , width and height while considering wixmp image transform dimension limits\n * @param sWidth\n * @param sHeight\n * @param dWidth\n * @param dHeight\n * @param transformType\n * @returns {{scaleFactor: *, width: *, height: *}}\n */\nfunction getSafeTransformData(\n  sWidth: number,\n  sHeight: number,\n  dWidth: number,\n  dHeight: number,\n  transformType: TransformType,\n) {\n  let scaleFactor;\n  // defaults for FILL transform type\n  let width = dWidth;\n  let height = dHeight;\n\n  // calculate safe image transformed area\n  scaleFactor = getScaleFactor(sWidth, sHeight, dWidth, dHeight, transformType);\n\n  if (transformType === transformTypes.FIT) {\n    width = sWidth * scaleFactor;\n    height = sHeight * scaleFactor;\n  }\n\n  // adjust target width & height & scaleFactor\n  if (width && height && width * height > SAFE_TRANSFORMED_AREA) {\n    const dimensionScaleFactor = Math.sqrt(\n      SAFE_TRANSFORMED_AREA / (width * height),\n    );\n    width *= dimensionScaleFactor;\n    height *= dimensionScaleFactor;\n    // get the new scale factor\n    scaleFactor = getScaleFactor(sWidth, sHeight, width, height, transformType);\n  }\n\n  return {\n    scaleFactor,\n    width,\n    height,\n  };\n}\n\n/**\n * returns the destination rectangle\n * @param {number}                  sWidth\n * @param {number}                  sHeight\n * @param {TransformType}           transformType\n * @param {ImageTransformTarget}    target\n * @param {number}                  dpr - device pixel ratio\n * @param {UpscaleMethod}           upscaleMethod\n *\n * @returns {ImageTransformData & {upscaleMethodValue: number}}\n */\nfunction getTransformData(\n  sWidth: number,\n  sHeight: number,\n  transformType: TransformType,\n  target: ImageTransformTarget,\n  dpr: number,\n  upscaleMethod: UpscaleMethod,\n): ImageTransformData & { upscaleMethodValue: number } {\n  // use target dimension is src not provided\n  sWidth = sWidth || target.width;\n  sHeight = sHeight || target.height;\n\n  // adjust image transform values considering server side transform limitations and performance\n  const { scaleFactor, width, height } = getSafeTransformData(\n    sWidth,\n    sHeight,\n    target.width * dpr,\n    target.height * dpr,\n    transformType,\n  );\n\n  // adjust image transform values to optimizing upsacle quality and payload\n  return getOptimizedTransformData(\n    sWidth,\n    sHeight,\n    width,\n    height,\n    upscaleMethod,\n    scaleFactor,\n    transformType,\n  );\n}\n\n/**\n * converts 9 grid alignment to Focal point position\n * @param {string}  [alignment]\n *\n * @returns {x:number,y:number}\n */\n\nfunction getFocalPointFrom9GridAlignment(alignment = alignTypes.CENTER) {\n  return ALIGN_TYPE_TO_FOCAL_POINT[alignment];\n}\n\n/**\n * returns overlapping rectangle where sRect\n * id aligned (according to alignment) within dRect\n * @param {{ width: number; height: number }} sRect rect 1\n * @param {{ width: number, height: number }} dRect rect 2\n * @param {{x: number, y: number}|undefined}  sFP   source image focal point\n * @param {string}                            alignment\n *\n * @returns {{x: number, y: number, width: number, height: number}}\n */\nfunction getAlignedRect(\n  sRect: { width: number; height: number },\n  dRect: { width: number; height: number },\n  sFP: { x?: number; y?: number } | undefined,\n  alignment?: string,\n) {\n  const fp =\n    getFocalPoint(sFP) ||\n    getFocalPointFrom9GridAlignment(alignment as AlignType);\n  const x = Math.max(\n    0,\n    Math.min(\n      sRect.width - dRect.width,\n      (fp.x as number) * sRect.width - dRect.width / 2,\n    ),\n  );\n  const y = Math.max(\n    0,\n    Math.min(\n      sRect.height - dRect.height,\n      (fp.y as number) * sRect.height - dRect.height / 2,\n    ),\n  );\n\n  // rect\n  return {\n    x,\n    y,\n    width: Math.min(sRect.width, dRect.width),\n    height: Math.min(sRect.height, dRect.height),\n  };\n}\n\n/**\n * returns overlapping rectangle between sRect and dRect\n * @param {object}      sRect         rect 1\n * @param {object}      dRect         rect 2\n *\n * @returns {{x:number,y:number,width:number, height:number} || null}\n */\nfunction getOverlappingRect(\n  sRect: { width: number; height: number },\n  dRect: { width: number; height: number; x: number; y: number },\n) {\n  const width = Math.max(\n    0,\n    Math.min(sRect.width, dRect.x + dRect.width) - Math.max(0, dRect.x),\n  );\n  const height = Math.max(\n    0,\n    Math.min(sRect.height, dRect.y + dRect.height) - Math.max(0, dRect.y),\n  );\n\n  const isValidRect =\n    width && height && (sRect.width !== width || sRect.height !== height);\n\n  // return overlapping sRect/dRect rectangle(x, y, width, height)\n  return isValidRect\n    ? {\n        x: Math.max(0, dRect.x),\n        y: Math.max(0, dRect.y),\n        width,\n        height,\n      }\n    : null;\n}\n\n/**\n * returns pixel aspect ratio value\n * @param {ImageTransformTarget}    target\n *\n * @returns {number}\n */\nfunction getDevicePixelRatio(target: ImageTransformTarget) {\n  return Math.min(target.pixelAspectRatio || 1, MAX_DEVICE_PIXEL_RATIO);\n}\n\n/**\n * returns target alignment value\n * @param {ImageTransformTarget}    target\n *\n * @returns {string}\n */\nfunction getAlignment(target: ImageTransformTarget) {\n  return (\n    (target.alignment && alignTypesMap[target.alignment]) ||\n    alignTypesMap[alignTypes.CENTER as AlignType]\n  );\n}\n\n/**\n * returns the focal point value, if no focal point passed use alignment\n * @param {{x: number, y: number}|undefined} focalPoint\n */\nfunction getFocalPoint(focalPoint: { x?: number; y?: number } | undefined) {\n  let fp;\n\n  if (\n    focalPoint &&\n    typeof focalPoint.x === 'number' &&\n    !isNaN(focalPoint.x) &&\n    typeof focalPoint.y === 'number' &&\n    !isNaN(focalPoint.y)\n  ) {\n    fp = {\n      x: roundToFixed(Math.max(0, Math.min(100, focalPoint.x)) / 100, 2),\n      y: roundToFixed(Math.max(0, Math.min(100, focalPoint.y)) / 100, 2),\n    };\n  }\n\n  return fp;\n}\n\n/**\n * returns preferred image quality value\n * @param {number}    imageWidth\n * @param {number}    imageHeight\n *\n * @returns {number}\n */\nfunction getPreferredImageQuality(imageWidth: number, imageHeight: number) {\n  return imageScaleDefaults[getImageQualityKey(imageWidth, imageHeight)]\n    .quality;\n}\n\n/**\n * returns the scale descriptor of CLASSIC upscale method\n * @param sWidth\n * @param sHeight\n * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getClassicScaleData(sWidth: number, sHeight: number) {\n  const imageKey = getImageQualityKey(sWidth, sHeight);\n\n  return {\n    optimizedScaleFactor: imageScaleDefaults[imageKey].maxUpscale,\n    upscaleMethodValue: upscaleMethodsValues.classic,\n    forceUSM: false,\n  };\n}\n\n/**\n * returns the scale descriptor of AUTO upscale method\n * @param sWidth\n * @param sHeight\n * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getAutoScaleData(sWidth: number, sHeight: number) {\n  const imageKey = getImageQualityKey(sWidth, sHeight);\n\n  return {\n    optimizedScaleFactor: imageScaleDefaults[imageKey].maxUpscale,\n    upscaleMethodValue: upscaleMethodsValues.classic,\n    forceUSM: false,\n  };\n}\n\n/**\n * returns the scale descriptor of SUPER upscale method\n * @param scaleFactor\n * @returns {{optimizedScaleFactor: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getSuperScaleData(scaleFactor: number) {\n  return {\n    optimizedScaleFactor: last(SUPER_UPSCALE_MODELS),\n    upscaleMethodValue: upscaleMethodsValues.super,\n    forceUSM: !(\n      SUPER_UPSCALE_MODELS.includes(scaleFactor) ||\n      scaleFactor > last(SUPER_UPSCALE_MODELS)\n    ),\n  };\n}\n\n/**\n * returns upscale descriptor object\n * @param {number}    sWidth\n * @param {number}    sHeight\n * @param {string}    upscaleMethod\n * @param {number}    scaleFactor\n *\n * @returns  {{maxScale: number, upscaleMethodValue: number, forceUSM: boolean}}\n */\nfunction getOptimizedScaleData(\n  sWidth: number,\n  sHeight: number,\n  scaleFactor: number,\n  upscaleMethod: UpscaleMethod,\n) {\n  if (upscaleMethod === 'auto') {\n    return getAutoScaleData(sWidth, sHeight);\n  } else if (upscaleMethod === 'super') {\n    return getSuperScaleData(scaleFactor);\n  }\n\n  // assuming 'classic' method\n  return getClassicScaleData(sWidth, sHeight);\n}\n\n/**\n * returns optimized upscale data, considering requested upscale method , optimize upscale for best quality and bandwidth\n * @param {number}    sWidth\n * @param {number}    sHeight\n * @param {number}    tWidth\n * @param {number}    tHeight\n * @param {UpscaleMethod}    upscaleMethod\n * @param {number}    scaleFactor\n * @param {TransformType}    transformType\n *\n * @returns  {ImageTransformData}\n */\nfunction getOptimizedTransformData(\n  sWidth: number,\n  sHeight: number,\n  tWidth: number,\n  tHeight: number,\n  upscaleMethod: UpscaleMethod,\n  scaleFactor: number,\n  transformType: TransformType,\n): ImageTransformData & { upscaleMethodValue: number } {\n  const {\n    optimizedScaleFactor,\n    upscaleMethodValue,\n    forceUSM,\n  } = getOptimizedScaleData(sWidth, sHeight, scaleFactor, upscaleMethod);\n\n  let width = tWidth;\n  let height = tHeight;\n\n  if (scaleFactor <= optimizedScaleFactor) {\n    // target upscale within limits or downscale\n    return {\n      width,\n      height,\n      scaleFactor,\n      upscaleMethodValue,\n      forceUSM,\n      cssUpscaleNeeded: false,\n    };\n  }\n  // limited upscale\n  switch (transformType) {\n    case transformTypes.FILL:\n      width = tWidth! * (optimizedScaleFactor / scaleFactor);\n      height = tHeight! * (optimizedScaleFactor / scaleFactor);\n      break;\n    case transformTypes.FIT:\n      width = sWidth * optimizedScaleFactor;\n      height = sHeight * optimizedScaleFactor;\n      break;\n    default:\n      break;\n  }\n  // adjust transform values\n  return {\n    width,\n    height,\n    scaleFactor: optimizedScaleFactor,\n    upscaleMethodValue,\n    forceUSM,\n    cssUpscaleNeeded: true,\n  };\n}\n\n/**\n * returns image quality key\n * @param {number}    imageWidth\n * @param {number}    imageHeight\n *\n * @returns {ImageQuality}\n */\nfunction getImageQualityKey(\n  imageWidth: number,\n  imageHeight: number,\n): ImageQuality {\n  const size = imageWidth * imageHeight;\n\n  if (size > imageScaleDefaults[imageQuality.HIGH].size) {\n    return imageQuality.HIGH;\n  } else if (size > imageScaleDefaults[imageQuality.MEDIUM].size) {\n    return imageQuality.MEDIUM;\n  } else if (size > imageScaleDefaults[imageQuality.LOW].size) {\n    return imageQuality.LOW;\n  }\n  return imageQuality.TINY;\n}\n\n/**\n * return the actual rounded dimension of a scaled rectangle\n * @param sWidth\n * @param sHeight\n * @param tWidth\n * @param tHeight\n * @param transformType\n * @returns {{width: number, height: number}}\n */\nfunction getDimension(\n  sWidth: number,\n  sHeight: number,\n  tWidth: number,\n  tHeight: number,\n  transformType: TransformType,\n) {\n  const scaleFactor = getScaleFactor(\n    sWidth,\n    sHeight,\n    tWidth,\n    tHeight,\n    transformType,\n  );\n  return {\n    width: Math.round(sWidth * scaleFactor),\n    height: Math.round(sHeight * scaleFactor),\n  };\n}\n\n/**\n * rounds number n digit precision and converts to string\n * @param {number}      value\n * @param {number}      precision\n *\n * @returns {string}\n */\nfunction roundToFixed(value: number, precision: number) {\n  const truncatePrecision = Math.pow(10, precision || 0);\n\n  return ((value * truncatePrecision) / truncatePrecision).toFixed(precision);\n}\n\n/**\n * get normalize scale method\n * @param {ImageTransformOptions} [options]\n * @returns {UpscaleMethod}\n */\nfunction getUpscaleString(options?: ImageTransformOptions) {\n  if (!options || !options.upscaleMethod) {\n    return upscaleMethods.AUTO;\n  }\n  return (\n    upscaleMethods[options.upscaleMethod.toUpperCase()] || upscaleMethods.AUTO\n  );\n}\n\nexport {\n  getAlignedRect,\n  getAlignment,\n  getDevicePixelRatio,\n  getDimension,\n  getFileExtension,\n  getFileName,\n  getFileType,\n  getFocalPoint,\n  getOverlappingRect,\n  getPreferredImageQuality,\n  getScaleFactor,\n  getTransformData,\n  getUpscaleString,\n  isExternalUrl,\n  isImageTransformApplicable,\n  isImageTypeSupported,\n  isSEOBot,\n  isValidRequest,\n  isPNG,\n  isWEBP,\n  roundToFixed,\n};\n"],"mappings":"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"}