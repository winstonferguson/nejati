"use strict";

exports.__esModule = true;
exports.setTransformParts = setTransformParts;
var _imageServiceConstants = require("./imageServiceConstants");
var _imageServiceUtils = require("./imageServiceUtils");
/**
 * request analysis, returns parsed transforms object
 * @param {object}                  transformsObj
 * @param {ImageTransformSource}    src
 * @param {ImageTransformTarget}    target
 */
function setTransformParts(transformsObj, src, target) {
  let rect;

  // crop source image if needed
  // set crop part and adjust source dimensions
  if (src.crop) {
    rect = (0, _imageServiceUtils.getOverlappingRect)(src, src.crop);
    if (rect) {
      transformsObj.src.width = rect.width;
      transformsObj.src.height = rect.height;
      transformsObj.src.isCropped = true;
      transformsObj.parts.push(getCropPart(rect));
    }
  }

  // set additional transform part
  switch (transformsObj.fittingType) {
    case _imageServiceConstants.fittingTypes.SCALE_TO_FIT:
    case _imageServiceConstants.fittingTypes.LEGACY_FIT_WIDTH:
    case _imageServiceConstants.fittingTypes.LEGACY_FIT_HEIGHT:
    case _imageServiceConstants.fittingTypes.LEGACY_FULL:
    case _imageServiceConstants.fittingTypes.FIT_AND_TILE:
    case _imageServiceConstants.fittingTypes.LEGACY_BG_FIT_AND_TILE:
    case _imageServiceConstants.fittingTypes.LEGACY_BG_FIT_AND_TILE_HORIZONTAL:
    case _imageServiceConstants.fittingTypes.LEGACY_BG_FIT_AND_TILE_VERTICAL:
    case _imageServiceConstants.fittingTypes.LEGACY_BG_NORMAL:
      // fit
      transformsObj.parts.push(getFitPart(transformsObj, target));
      break;
    case _imageServiceConstants.fittingTypes.SCALE_TO_FILL:
      // fill
      transformsObj.parts.push(getFillPart(transformsObj, target));
      break;
    case _imageServiceConstants.fittingTypes.STRETCH:
      // stretch
      transformsObj.parts.push(getStretchPart(transformsObj, target));
      break;
    case _imageServiceConstants.fittingTypes.TILE_HORIZONTAL:
    case _imageServiceConstants.fittingTypes.TILE_VERTICAL:
    case _imageServiceConstants.fittingTypes.TILE:
    case _imageServiceConstants.fittingTypes.LEGACY_ORIGINAL_SIZE:
    case _imageServiceConstants.fittingTypes.ORIGINAL_SIZE:
      // use crop transform
      // if crop of source image was requested adjust cropping rectangle
      rect = (0, _imageServiceUtils.getAlignedRect)(transformsObj.src, target, transformsObj.focalPoint, target.alignment);
      if (transformsObj.src.isCropped) {
        Object.assign(transformsObj.parts[0], rect);

        // update source width & height accordingly
        transformsObj.src.width = rect.width;
        transformsObj.src.height = rect.height;
      } else {
        transformsObj.parts.push(getCropPart(rect));
      }
      break;

    // ---------------------------------------------------------------------------------------
    // handles a legacy bug on bgImageStrip, background html tag
    // component Full Width Strip stored incorrect image source width and height
    // ---------------------------------------------------------------------------------------
    case _imageServiceConstants.fittingTypes.LEGACY_STRIP_TILE_HORIZONTAL:
    case _imageServiceConstants.fittingTypes.LEGACY_STRIP_TILE_VERTICAL:
    case _imageServiceConstants.fittingTypes.LEGACY_STRIP_TILE:
    case _imageServiceConstants.fittingTypes.LEGACY_STRIP_ORIGINAL_SIZE:
      // crop request of source image is not supported
      // use legacy crop
      transformsObj.parts.push(getLegacyCropPart(target));
      break;
    case _imageServiceConstants.fittingTypes.LEGACY_STRIP_SCALE_TO_FIT:
    case _imageServiceConstants.fittingTypes.LEGACY_STRIP_FIT_AND_TILE:
      // legacy fit
      transformsObj.parts.push(getLegacyFitPart(target));
      break;
    case _imageServiceConstants.fittingTypes.LEGACY_STRIP_SCALE_TO_FILL:
      // legacy fill
      transformsObj.parts.push(getLegacyFillPart(target));
      break;
  }
}

/**
 * returns fit part of the image transform uri
 * @param {object}                  transformsObj
 * @param {ImageTransformTarget}    target
 *
 * @returns {TransformFitPart}
 */
function getFitPart(transformsObj, target) {
  // calculate the transformed image size needed
  const transformedData = (0, _imageServiceUtils.getTransformData)(transformsObj.src.width, transformsObj.src.height, _imageServiceConstants.transformTypes.FIT, target, transformsObj.devicePixelRatio, transformsObj.upscaleMethod);
  const transformType = _imageServiceConstants.transformTypes.FILL;

  // return fit transform data
  return {
    transformType,
    width: Math.round(transformedData.width),
    height: Math.round(transformedData.height),
    alignment: _imageServiceConstants.alignTypesMap.center,
    upscale: transformedData.scaleFactor > 1,
    forceUSM: transformedData.forceUSM,
    scaleFactor: transformedData.scaleFactor,
    cssUpscaleNeeded: transformedData.cssUpscaleNeeded,
    upscaleMethodValue: transformedData.upscaleMethodValue
  };
}

/**
 * returns fill part of the image transform uri
 * @param {ImageTransformObject} transformsObj
 * @param {ImageTransformTarget} target
 *
 * @returns {TransformFillPart}
 */
function getFillPart(transformsObj, target) {
  // calculate the transformed image size needed
  const transformedData = (0, _imageServiceUtils.getTransformData)(transformsObj.src.width, transformsObj.src.height, _imageServiceConstants.transformTypes.FILL, target, transformsObj.devicePixelRatio, transformsObj.upscaleMethod);
  const focalPoint = (0, _imageServiceUtils.getFocalPoint)(transformsObj.focalPoint);
  const transformType = focalPoint ? _imageServiceConstants.transformTypes.FILL_FOCAL : _imageServiceConstants.transformTypes.FILL;
  return {
    transformType,
    width: Math.round(transformedData.width),
    height: Math.round(transformedData.height),
    alignment: (0, _imageServiceUtils.getAlignment)(target),
    focalPointX: focalPoint && focalPoint.x,
    focalPointY: focalPoint && focalPoint.y,
    upscale: transformedData.scaleFactor > 1,
    forceUSM: transformedData.forceUSM,
    scaleFactor: transformedData.scaleFactor,
    cssUpscaleNeeded: transformedData.cssUpscaleNeeded,
    upscaleMethodValue: transformedData.upscaleMethodValue
  };
}

/**
 * returns fill part of the image transform uri
 * @param {ImageTransformObject} transformsObj
 * @param {ImageTransformTarget} target
 *
 * @returns {TransformFitPart}
 */
function getStretchPart(transformsObj, target) {
  // stretch data
  const scaleFactor = (0, _imageServiceUtils.getScaleFactor)(transformsObj.src.width, transformsObj.src.height, target.width, target.height, _imageServiceConstants.transformTypes.FILL);
  const clonedTarget = {
    ...target
  };
  clonedTarget.width = transformsObj.src.width * scaleFactor;
  clonedTarget.height = transformsObj.src.height * scaleFactor;

  // return stretch part
  return getFitPart(transformsObj, clonedTarget);
}

/**
 * returns crop part of the image transform uri
 * @param {{x: number, y: number, width: number, height: number}}  rect     x, y, width, height
 *
 * @returns {TransformCropPart}
 */
function getCropPart(rect) {
  return {
    transformType: _imageServiceConstants.transformTypes.CROP,
    x: Math.round(rect.x),
    y: Math.round(rect.y),
    width: Math.round(rect.width),
    height: Math.round(rect.height),
    upscale: false,
    forceUSM: false,
    scaleFactor: 1,
    cssUpscaleNeeded: false
  };
}

// ---------------------------------------------------------------------------------------
// handles a legacy bug on bgImageStrip, background html tag
// component Full Width Strip stored incorrect image source width and height
// ---------------------------------------------------------------------------------------

/**
 * returns fit part of the image transform uri
 * @param {ImageTransformTarget}    target
 *
 * @returns {TransformLegacyFitPart}
 */
function getLegacyFitPart(target) {
  return {
    transformType: _imageServiceConstants.transformTypes.FIT,
    width: Math.round(target.width),
    height: Math.round(target.height),
    upscale: false,
    forceUSM: true,
    scaleFactor: 1,
    cssUpscaleNeeded: false
  };
}

/**
 * returns fill part of the image transform uri
 * @param {ImageTransformTarget}    target
 *
 * @returns {TransformLegacyFillPart}
 */
function getLegacyFillPart(target) {
  return {
    transformType: _imageServiceConstants.transformTypes.LEGACY_FILL,
    width: Math.round(target.width),
    height: Math.round(target.height),
    alignment: (0, _imageServiceUtils.getAlignment)(target),
    upscale: false,
    forceUSM: true,
    scaleFactor: 1,
    cssUpscaleNeeded: false
  };
}

/**
 * returns legacy crop part of the image transform uri
 * @param {ImageTransformTarget}     target
 *
 * @returns {TransformLegacyCropPart}
 */
function getLegacyCropPart(target) {
  return {
    transformType: _imageServiceConstants.transformTypes.LEGACY_CROP,
    width: Math.round(target.width),
    height: Math.round(target.height),
    alignment: (0, _imageServiceUtils.getAlignment)(target),
    upscale: false,
    forceUSM: false,
    scaleFactor: 1,
    cssUpscaleNeeded: false
  };
}
//# sourceMappingURL=imageTransformParts.js.map