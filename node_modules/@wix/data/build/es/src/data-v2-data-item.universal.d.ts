export declare const __debug: {
    verboseLogging: {
        on: () => boolean;
        off: () => boolean;
    };
};
export interface DataItem {
    /** Data item ID. */
    _id?: string;
    /**
     * Data item contents.
     *
     * Property-value pairs representing the data item's payload. When retrieving a data item, it also includes the following read-only fields:
     *
     * + `_id`: Item ID.
     * + `_createdDate`: Date and time the item was added to the collection.
     * + `_updatedDate`: Date and time the item was last modified. When the item is first inserted, `_createdDate` and `_updatedDate` have the same value.
     * + `_ownerId`: ID of the user who created the item. Can be modified with site owner permissions.
     */
    data?: Record<string, any> | null;
}
export interface InsertDataItemRequest {
    /** ID of the collection in which to insert the item. */
    dataCollectionId: string;
    /** Item to insert. */
    dataItem: DataItem;
}
export declare enum Environment {
    LIVE = "LIVE",
    SANDBOX = "SANDBOX"
}
export interface Options {
}
export interface PublishPluginOptions {
    showDraftItems?: boolean;
}
export interface InsertDataItemResponse {
    /** Inserted data item. */
    dataItem?: DataItem;
}
export interface UpdateDataItemRequest {
    /** ID of the collection containing the existing item. */
    dataCollectionId: string;
    /** Updated data item content. The existing data item's content is replaced entirely. */
    dataItem: DataItem;
}
export interface UpdateDataItemResponse {
    /** Updated data item. */
    dataItem?: DataItem;
}
export interface SaveDataItemRequest {
    /** ID of the collection in which to insert or update the item. */
    dataCollectionId: string;
    /** Data item to insert or update. */
    dataItem: DataItem;
}
export interface SaveDataItemResponse {
    /**
     * The action carried out for the item.
     *
     * + `INSERTED`: A new item was added to the collection.
     * + `UPDATED`: An existing item in the collection was updated.
     */
    action?: Action;
    /** Inserted or updated data item. */
    dataItem?: DataItem;
}
export declare enum Action {
    UNKNOWN_ACTION = "UNKNOWN_ACTION",
    INSERTED = "INSERTED",
    UPDATED = "UPDATED"
}
export interface GetDataItemRequest {
    /** ID of the collection from which to retrieve the data item. */
    dataCollectionId: string;
    /** ID of the data item to retrieve. */
    dataItemId: string;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
export interface GetDataItemResponse {
    /** Retrieved item. */
    dataItem?: DataItem;
}
export interface RemoveDataItemRequest {
    /** ID of the collection from which to remove the item. */
    dataCollectionId: string;
    /** ID of the item to remove. */
    dataItemId: string;
}
export interface RemoveDataItemResponse {
    /** Removed item. */
    dataItem?: DataItem;
}
export interface TruncateDataItemsRequest {
    /** ID of the collection to truncate. */
    dataCollectionId: string;
}
export interface TruncateDataItemsResponse {
}
export interface QueryDataItemsRequest {
    /** ID of the collection in which to insert the item. */
    dataCollectionId: string;
    /** Query preferences. For more details on using queries, see [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language). */
    query?: QueryV2;
    /**
     * Whether to return the total count in the response for a query with offset paging.
     * When `true`, the `pagingMetadata` object in the response contains a `total` field.
     *
     * Default: `false`
     */
    returnTotalCount?: boolean;
    /**
     * Properties for which to include referenced items in the query's results.
     * Up to 50 referenced items can be included for each item that matches the query.
     */
    includeReferencedItems?: string[];
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
export interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     *
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     *
     * Examples of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
    /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
    fields?: string[];
}
/** @oneof */
export interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /**
     * Sort order.
     *
     * Supported values: `ASC`, `DESC`.
     */
    order?: SortOrder;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
export interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /** Number of items to load. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
export interface QueryDataItemsResponse {
    /** Retrieved items. */
    dataItems?: DataItem[];
    /** Paging information. */
    pagingMetadata?: PagingMetadataV2;
}
export interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used, `returnTotalCount` is `true` in the request, and `tooManyToCount` is false. */
    total?: number | null;
    /** Whether the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
export interface Cursors {
    /** Cursor pointing to next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to previous page in the list of results. */
    prev?: string | null;
}
export interface AggregateDataItemsRequest extends AggregateDataItemsRequestPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** ID of the collection on which to run the aggregation. */
    dataCollectionId: string;
    /** Filter applied to the collection's data prior to running the aggregation. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language#getting-started_api-query-language_the-filter-section) for information on how to structure a filter object. */
    initialFilter?: Record<string, any> | null;
    /** Aggregation applied to the data. */
    aggregation?: Aggregation;
    /** Filter applied to the processed data following the aggregation. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language#getting-started_api-query-language_the-filter-section) for information on how to structure a filter object. */
    finalFilter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
    /**
     * Whether to return the total count in the response for a query with offset paging.
     * When `true`, the `pagingMetadata` object in the response contains a `total` field.
     *
     * Default: `false`
     */
    returnTotalCount?: boolean;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
/** @oneof */
export interface AggregateDataItemsRequestPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Average {
    /** Name of the field for which to calculate the average value. */
    itemFieldName?: string;
}
export interface Min {
    /** Name of the field for which to calculate the minimum value. */
    itemFieldName?: string;
}
export interface Max {
    /** Name of the field for which to calculate the maximum value. */
    itemFieldName?: string;
}
export interface Sum {
    /** Name of the field for which to calculate the sum. */
    itemFieldName?: string;
}
export interface Count {
}
export interface Operation extends OperationCalculateOneOf {
    /** Calculate the average value of a specified field for all items in the grouping. */
    average?: Average;
    /** Calculate the minimum value of a specified field for all items in the grouping. */
    min?: Min;
    /** Calculate the maximum value of a specified field for all items in the grouping. */
    max?: Max;
    /** Calculate the sum of values of a specified field for all items in the grouping. */
    sum?: Sum;
    /** Calculate the number of items in the grouping. */
    itemCount?: Count;
    /** Name of the field containing results of the operation. */
    resultFieldName?: string;
}
/** @oneof */
export interface OperationCalculateOneOf {
    /** Calculate the average value of a specified field for all items in the grouping. */
    average?: Average;
    /** Calculate the minimum value of a specified field for all items in the grouping. */
    min?: Min;
    /** Calculate the maximum value of a specified field for all items in the grouping. */
    max?: Max;
    /** Calculate the sum of values of a specified field for all items in the grouping. */
    sum?: Sum;
    /** Calculate the number of items in the grouping. */
    itemCount?: Count;
}
export interface Aggregation {
    /** Fields by which to group items for the aggregation. If empty, the aggregation is carried out on all items in the collection. */
    groupingFields?: string[];
    /** Operations to carry out on the data in each grouping. */
    operations?: Operation[];
}
export interface AggregateDataItemsResponse {
    /** Aggregation results. */
    results?: Record<string, any>[] | null;
    /** Paging information. */
    pagingMetadata?: PagingMetadataV2;
}
export interface CountDataItemsRequest {
    /** ID of the collection for which to count query results. */
    dataCollectionId: string;
    /**
     * Filter object in the following format:
     *
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`.
     *
     * Examples of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`.
     */
    filter?: Record<string, any> | null;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
export interface CountDataItemsResponse {
    /** Number of items matching the query. */
    totalCount?: number;
}
export interface QueryDistinctValuesRequest extends QueryDistinctValuesRequestPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** ID of the collection to query. */
    dataCollectionId: string;
    /** Item field name for which to return all distinct values. */
    fieldName?: string;
    /**
     * Filter object in the following format:
     *
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`.
     *
     * Examples of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`.
     */
    filter?: Record<string, any> | null;
    /**
     * Sort order.
     *
     * Supported values: `ASC`, `DESC`.
     */
    order?: SortOrder;
    /**
     * Whether to return the total count in the response for a query with offset paging.
     * When `true`, the `pagingMetadata` object in the response contains a `total` field.
     *
     * Default: `false`
     */
    returnTotalCount?: boolean;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
/** @oneof */
export interface QueryDistinctValuesRequestPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface QueryDistinctValuesResponse {
    /** List of distinct values contained in the field specified in `fieldName`. */
    distinctValues?: any[];
    /** Paging information. */
    pagingMetadata?: PagingMetadataV2;
}
export interface BulkInsertDataItemsRequest {
    /** ID of the collection in which to insert the items. */
    dataCollectionId: string;
    /** Data items to insert. */
    dataItems: DataItem[];
    /**
     * Whether to return the inserted data items.
     * When `true`, the `results` objects contain a `dataItem` field.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
export interface BulkInsertDataItemsResponse {
    /** Information about the inserted items. */
    results?: BulkDataItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkDataItemResult {
    /**
     * The action attempted for the data item.
     *
     * Supported values: `UNKNOWN_ACTION_TYPE`, `INSERT`, `UPDATE`, `DELETE`.
     */
    action?: BulkActionType;
    /** Metadata related to the data item for which the action was attempted. */
    itemMetadata?: ItemMetadata;
    /** The data item for which the action was attempted. Only returned if `returnEntity` is `true` in the request and the action is successful. */
    dataItem?: DataItem;
}
export declare enum BulkActionType {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    INSERT = "INSERT",
    UPDATE = "UPDATE",
    DELETE = "DELETE"
}
export interface ItemMetadata {
    /** Item ID. This field doesn't appear if there is no item ID, for example, when item creation fails. */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
export interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
export interface BulkActionMetadata {
    /** Number of items successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
}
export interface BulkUpdateDataItemsRequest {
    /** ID of the collection in which to update items. */
    dataCollectionId: string;
    /** Data items to update. */
    dataItems: DataItem[];
    /**
     * Whether to return the updated data items.
     * When `true`, the `results` objects contain a `dataItem` field.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
export interface BulkUpdateDataItemsResponse {
    /** Information about the updated items. */
    results?: BulkDataItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkSaveDataItemsRequest {
    /** ID of the collection in which to insert or update the items. */
    dataCollectionId: string;
    /** Data items to insert or update. */
    dataItems: DataItem[];
    /**
     * Whether to return the saved data item.
     * When `true`, the `results` objects contain a `dataItem` field.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
export interface BulkSaveDataItemsResponse {
    /** Information about the saved items. */
    results?: BulkDataItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkRemoveDataItemsRequest {
    /** ID of the collection from which to remove the item. */
    dataCollectionId: string;
    /** IDs of data items to remove. */
    dataItemIds: string[];
}
export interface BulkRemoveDataItemsResponse {
    /** Information about the removed data items. */
    results?: BulkDataItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface QueryReferencedDataItemsRequest extends QueryReferencedDataItemsRequestPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** ID of the collection containing the referring item. */
    dataCollectionId: string;
    /** ID of the referring item. */
    referringItemId?: string;
    /** Field containing references in the referring item. */
    referringItemFieldName?: string;
    /** Order of the returned referenced items. Sorted by the date each item was referenced. */
    order?: SortOrder;
    /**
     * Whether to return the total count in the response.
     * When `true`, the `pagingMetadata` object in the response contains a `total` field.
     *
     * Default: `false`
     */
    returnTotalCount?: boolean;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
/** @oneof */
export interface QueryReferencedDataItemsRequestPagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface QueryReferencedDataItemsResponse {
    /** Referenced items and/or IDs. For successfully resolved references, the referenced data item is returned. For references that can't be resolved, the ID is returned. */
    results?: ReferencedResult[];
    /** Paging information. */
    pagingMetadata?: PagingMetadataV2;
}
export interface UnresolvedReference {
    /** ID of the referring item. */
    referringItemId?: string;
    /** Field specified to query for references. */
    referringItemFieldName?: string;
}
export interface ReferencedResult extends ReferencedResultEntityOneOf {
    /** Data item referenced. */
    dataItem?: DataItem;
    /** Unresolved reference. Appears instead of the data item when the reference doesn't resolve, for example, when an ID isn't found or if an item is in draft state. */
    unresolvedReference?: UnresolvedReference;
}
/** @oneof */
export interface ReferencedResultEntityOneOf {
    /** Data item referenced. */
    dataItem?: DataItem;
    /** Unresolved reference. Appears instead of the data item when the reference doesn't resolve, for example, when an ID isn't found or if an item is in draft state. */
    unresolvedReference?: UnresolvedReference;
}
export interface IsReferencedDataItemRequest {
    /** ID of the collection containing the referring data item. */
    dataCollectionId: string;
    /** Field to check for a reference to the item that may be referenced. */
    referringItemFieldName: string;
    /** ID of the referring item. */
    referringItemId: string;
    /** ID of the item that may be referenced. */
    referencedItemId: string;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
export interface IsReferencedDataItemResponse {
    /** Whether the specified reference exists. */
    isReferenced?: boolean;
}
export interface InsertDataItemReferenceRequest {
    /** ID of the collection in which to insert the reference. */
    dataCollectionId: string;
    /** Reference to insert */
    dataItemReference?: DataItemReference;
}
export interface DataItemReference {
    /** Referring item field containing the references to the referenced items. */
    referringItemFieldName?: string;
    /** ID of the referring item. */
    referringItemId?: string;
    /** ID of the referenced item. */
    referencedItemId?: string;
}
export interface InsertDataItemReferenceResponse {
    /** Inserted reference. */
    dataItemReference?: DataItemReference;
}
export interface RemoveDataItemReferenceRequest {
    /** ID of the collection containing the referring item. */
    dataCollectionId: string;
    /** Reference to remove. */
    dataItemReference: DataItemReference;
}
export interface RemoveDataItemReferenceResponse {
    /** Removed reference. */
    dataItemReference?: DataItemReference;
}
export interface BulkInsertDataItemReferencesRequest {
    /** ID of the collection containing the referring items. */
    dataCollectionId: string;
    /** References to insert. */
    dataItemReferences: DataItemReference[];
    /**
     * Whether to return the inserted data item references.
     * When `true`, the `results` objects contain a `dataItemReference` field.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
export interface BulkInsertDataItemReferencesResponse {
    /** Information about the inserted references. */
    results?: BulkDataItemReferenceResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkDataItemReferenceResult {
    /**
     * The action attempted for the reference.
     *
     * Supported values: `UNKNOWN_ACTION_TYPE`, `INSERT`, `UPDATE`, `DELETE`.
     */
    action?: BulkActionType;
    /** Metadata related to the reference for which the action was attempted. */
    referenceMetadata?: ItemMetadata;
    /** The reference for which the action was attempted. Only returned if `returnEntity` is `true` in the request and the action is successful. */
    dataItemReference?: DataItemReference;
}
export interface BulkRemoveDataItemReferencesRequest {
    /** ID of the collection containing the referring items. */
    dataCollectionId: string;
    /** References to remove. */
    dataItemReferences: DataItemReference[];
}
export interface BulkRemoveDataItemReferencesResponse {
    /** Information about the removed references. */
    results?: BulkDataItemReferenceResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface ReplaceDataItemReferencesRequest {
    /** ID of the collection containing the referring item. */
    dataCollectionId: string;
    /** Field containing references in the referring item. */
    referringItemFieldName: string;
    /** ID of the referring item. */
    referringItemId: string;
    /** List of new referenced item IDs to replace the existing ones. */
    newReferencedItemIds?: string[];
}
export interface ReplaceDataItemReferencesResponse {
    /** Updated references. */
    dataItemReferences?: DataItemReference[];
}
export interface InsertDataItemResponseNonNullableFields {
    dataItem?: {
        _id: string;
    };
}
export interface UpdateDataItemResponseNonNullableFields {
    dataItem?: {
        _id: string;
    };
}
export interface SaveDataItemResponseNonNullableFields {
    action: Action;
    dataItem?: {
        _id: string;
    };
}
export interface GetDataItemResponseNonNullableFields {
    dataItem?: {
        _id: string;
    };
}
export interface RemoveDataItemResponseNonNullableFields {
    dataItem?: {
        _id: string;
    };
}
export interface QueryDataItemsResponseNonNullableFields {
    dataItems: {
        _id: string;
    }[];
}
export interface CountDataItemsResponseNonNullableFields {
    totalCount: number;
}
export interface BulkInsertDataItemsResponseNonNullableFields {
    results: {
        action: BulkActionType;
        itemMetadata?: {
            originalIndex: number;
            success: boolean;
            error?: {
                code: string;
                description: string;
            };
        };
        dataItem?: {
            _id: string;
        };
    }[];
    bulkActionMetadata?: {
        totalSuccesses: number;
        totalFailures: number;
    };
}
export interface BulkUpdateDataItemsResponseNonNullableFields {
    results: {
        action: BulkActionType;
        itemMetadata?: {
            originalIndex: number;
            success: boolean;
            error?: {
                code: string;
                description: string;
            };
        };
        dataItem?: {
            _id: string;
        };
    }[];
    bulkActionMetadata?: {
        totalSuccesses: number;
        totalFailures: number;
    };
}
export interface BulkSaveDataItemsResponseNonNullableFields {
    results: {
        action: BulkActionType;
        itemMetadata?: {
            originalIndex: number;
            success: boolean;
            error?: {
                code: string;
                description: string;
            };
        };
        dataItem?: {
            _id: string;
        };
    }[];
    bulkActionMetadata?: {
        totalSuccesses: number;
        totalFailures: number;
    };
}
export interface BulkRemoveDataItemsResponseNonNullableFields {
    results: {
        action: BulkActionType;
        itemMetadata?: {
            originalIndex: number;
            success: boolean;
            error?: {
                code: string;
                description: string;
            };
        };
        dataItem?: {
            _id: string;
        };
    }[];
    bulkActionMetadata?: {
        totalSuccesses: number;
        totalFailures: number;
    };
}
export interface QueryReferencedDataItemsResponseNonNullableFields {
    results: {
        dataItem?: {
            _id: string;
        };
        unresolvedReference?: {
            referringItemId: string;
            referringItemFieldName: string;
        };
    }[];
}
export interface IsReferencedDataItemResponseNonNullableFields {
    isReferenced: boolean;
}
export interface InsertDataItemReferenceResponseNonNullableFields {
    dataItemReference?: {
        referringItemFieldName: string;
        referringItemId: string;
        referencedItemId: string;
    };
}
export interface RemoveDataItemReferenceResponseNonNullableFields {
    dataItemReference?: {
        referringItemFieldName: string;
        referringItemId: string;
        referencedItemId: string;
    };
}
export interface BulkInsertDataItemReferencesResponseNonNullableFields {
    results: {
        action: BulkActionType;
        referenceMetadata?: {
            originalIndex: number;
            success: boolean;
            error?: {
                code: string;
                description: string;
            };
        };
        dataItemReference?: {
            referringItemFieldName: string;
            referringItemId: string;
            referencedItemId: string;
        };
    }[];
    bulkActionMetadata?: {
        totalSuccesses: number;
        totalFailures: number;
    };
}
export interface BulkRemoveDataItemReferencesResponseNonNullableFields {
    results: {
        action: BulkActionType;
        referenceMetadata?: {
            originalIndex: number;
            success: boolean;
            error?: {
                code: string;
                description: string;
            };
        };
        dataItemReference?: {
            referringItemFieldName: string;
            referringItemId: string;
            referencedItemId: string;
        };
    }[];
    bulkActionMetadata?: {
        totalSuccesses: number;
        totalFailures: number;
    };
}
export interface ReplaceDataItemReferencesResponseNonNullableFields {
    dataItemReferences: {
        referringItemFieldName: string;
        referringItemId: string;
        referencedItemId: string;
    }[];
}
/**
 * Adds an item to a collection.
 *
 *
 * An item can only be inserted into an existing connection.
 * You can create a new collection using the Data Collections API.
 *
 * When an item is inserted into a collection, the item's ID is automatically assigned a random value.
 * You can optionally provide a custom ID in `dataItem.id` when inserting the item.
 * If you specify an ID that already exists in the collection, the insertion will fail.
 *
 * If `options.dataItem.data` is empty, a new item is created with no data fields.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.dataCollectionId
 * @requiredField options.dataItem
 * @param options - Options for adding an item to a collection.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function insertDataItem(options: InsertDataItemOptions): Promise<InsertDataItemResponse & InsertDataItemResponseNonNullableFields>;
export interface InsertDataItemOptions {
    /** ID of the collection in which to insert the item. */
    dataCollectionId: string;
    /** Item to insert. */
    dataItem: DataItem;
}
/**
 * Updates an item in a collection.
 *
 *
 * This function replaces the data item's existing data with the payload provided in `options.dataItem.data` in the request.
 *
 * To update an item, you need to specify an item ID and a collection ID.
 * If an item is found in the specified collection with the specified ID, that item is updated.
 * If the collection doesn't contain an item with that ID, the request fails.
 *
 * When an item is updated, its `data._updatedDate` field is changed to the current date and time.
 *
 * > **Note:**
 * > After an item is updated, it only contains the fields included in the `options.dataItem.data` payload in the `updateDataItem()` call.
 * > If the existing item has fields with values and those fields aren't included in the updated item, their values are lost.
 * @param _id - Data item ID.
 * @public
 * @documentationMaturity preview
 * @requiredField _id
 * @requiredField options
 * @requiredField options.dataCollectionId
 * @requiredField options.dataItem
 * @param options - Options for updating an item in a collection.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function updateDataItem(_id: string, options: UpdateDataItemOptions): Promise<UpdateDataItemResponse & UpdateDataItemResponseNonNullableFields>;
export interface UpdateDataItemOptions {
    /** Updated data item content. The existing data item's content is replaced entirely. */
    dataItem: {
        /** Data item ID. */
        _id?: string;
        /**
         * Data item contents.
         *
         * Property-value pairs representing the data item's payload. When retrieving a data item, it also includes the following read-only fields:
         *
         * + `_id`: Item ID.
         * + `_createdDate`: Date and time the item was added to the collection.
         * + `_updatedDate`: Date and time the item was last modified. When the item is first inserted, `_createdDate` and `_updatedDate` have the same value.
         * + `_ownerId`: ID of the user who created the item. Can be modified with site owner permissions.
         */
        data?: Record<string, any> | null;
    };
    /** ID of the collection containing the existing item. */
    dataCollectionId: string;
}
/**
 * Inserts or updates an item in a collection.
 *
 *
 * The `saveDataItem()` function inserts or updates the specified item, depending on whether it already exists in the collection.
 *
 * + If you don't provide an ID, a new item is created.
 *
 * + If you provide an ID that does not exist in the collection, a new item is created with that ID.
 *
 * + If an item with the ID you provide already exists in the collection, that item is updated. When an item is updated, its `data._updatedDate` field is changed to the current date and time.
 *
 * > **Note:** When you provide an item with an ID that already exists in the collection, the payload you provide in `options.dataItem.data` replaces the existing item with that ID.
 * > This means that the item's previous fields and values are lost.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.dataCollectionId
 * @requiredField options.dataItem
 * @param options - Options for saving an item in a collection.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function saveDataItem(options: SaveDataItemOptions): Promise<SaveDataItemResponse & SaveDataItemResponseNonNullableFields>;
export interface SaveDataItemOptions {
    /** ID of the collection in which to insert or update the item. */
    dataCollectionId: string;
    /** Data item to insert or update. */
    dataItem: DataItem;
}
/**
 * Retrieves an item from a collection.
 *
 *
 * > **Note**: When calling `getDataItem()` following an update to your collection, the data retrieved may not contain the most recent changes. If you need the most up-to-date data, set `options.consistentRead` to `true`.
 * @param dataItemId - ID of the data item to retrieve.
 * @public
 * @documentationMaturity preview
 * @requiredField dataItemId
 * @requiredField options.dataCollectionId
 * @param options - Options for retrieving an item from a collection.
 * @permissionScope Read Data Items
 * @applicableIdentity APP
 * @returns Retrieved item.
 */
export declare function getDataItem(dataItemId: string, options?: GetDataItemOptions): Promise<DataItem & NonNullable<GetDataItemResponseNonNullableFields>['dataItem']>;
export interface GetDataItemOptions {
    /** ID of the collection from which to retrieve the data item. */
    dataCollectionId: string;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
/**
 * Removes an item from a collection.
 *
 *
 * If any items in other collections reference the removed item in reference or multi-reference fields, those fields are cleared.
 *
 * > **Note:**
 * > Once an item has been removed from a collection, it can't be restored.
 * @param dataItemId - ID of the item to remove.
 * @public
 * @documentationMaturity preview
 * @requiredField dataItemId
 * @requiredField options
 * @requiredField options.dataCollectionId
 * @param options - Options for removing an item from a collection.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function removeDataItem(dataItemId: string, options: RemoveDataItemOptions): Promise<RemoveDataItemResponse & RemoveDataItemResponseNonNullableFields>;
export interface RemoveDataItemOptions {
    /** ID of the collection from which to remove the item. */
    dataCollectionId: string;
}
/**
 * Removes all items from a collection.
 *
 *
 * If any items in other collections reference the removed items in reference or multi-reference fields, those fields are cleared.
 *
 * > **Note:**
 * > Once items have been removed from a collection, they can't be restored.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.dataCollectionId
 * @param options - Options for truncating data items from a collection.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function truncateDataItems(options: TruncateDataItemsOptions): Promise<void>;
export interface TruncateDataItemsOptions {
    /** ID of the collection to truncate. */
    dataCollectionId: string;
}
/**
 * Creates a query to retrieve items from a database collection.
 *
 * The `queryDataItems()` function builds a query to retrieve data items from a collection and returns a `DataItemsQueryBuilder` object.
 *
 * The returned object contains the query definition which is typically used to run the query using the `find()` function.
 *
 * You can refine the query by chaining `DataItemsQueryBuilder` functions onto the query. `DataItemsQueryBuilder` functions enable you to sort, filter, and control the results that `queryDataItems()` returns.
 *
 * The `queryDataItems()` function runs with the following `DataItemsQueryBuilder` defaults that you can override:
 *
 * + `skip`: 0
 * + `limit`: 50
 * + `descending`: by `_createdDate`
 *
 * The functions that are chained to `queryDataItems()` are applied in the order they are called. For example, if you sort on an `age` field in ascending order and then on a `name` field in descending order, the results are sorted first by the age of the items and then, if there are multiple results with the same age, the items are sorted by name in descending order, per age value.
 *
 * If the collection that you are querying has references to other collections, by default the data from referenced collections is not retrieved. To get the data from referenced items, specify them in the `options.includeReferencedItems` parameter.
 *
 * > **Note**: When calling `queryDataItems()` following an update to your collection, the data retrieved may not contain the most recent changes. If you need the most up-to-date data, set `options.consistentRead` to `true`.
 *
 *
 * @public
 * @documentationMaturity preview
 * @requiredField options.options.dataCollectionId
 * @param options - Options for querying data items.
 * @permissionScope Read Data Items
 * @applicableIdentity APP
 */
export declare function queryDataItems(options: QueryDataItemsOptions): DataItemsQueryBuilder;
export interface QueryDataItemsOptions {
    /** ID of the collection in which to insert the item. */
    dataCollectionId: string;
    /**
     * Whether to return the total count in the response for a query with offset paging.
     * When `true`, the `pagingMetadata` object in the response contains a `total` field.
     *
     * Default: `false`
     */
    returnTotalCount?: boolean | undefined;
    /**
     * Properties for which to include referenced items in the query's results.
     * Up to 50 referenced items can be included for each item that matches the query.
     */
    includeReferencedItems?: string[] | undefined;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean | undefined;
}
interface QueryOffsetResult {
    currentPage: number;
    totalPages: number;
    totalCount: number;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
export interface DataItemsQueryResult extends QueryOffsetResult {
    items: DataItem[];
    query: DataItemsQueryBuilder;
    next: () => Promise<DataItemsQueryResult>;
    prev: () => Promise<DataItemsQueryResult>;
}
export interface DataItemsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    eq: (propertyName: '_id' | 'data' | string, value: any) => DataItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ne: (propertyName: '_id' | 'data' | string, value: any) => DataItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     * @documentationMaturity preview
     */
    startsWith: (propertyName: '_id' | string, value: string) => DataItemsQueryBuilder;
    /** @documentationMaturity preview */
    in: (propertyName: '_id' | 'data' | string, value: any) => DataItemsQueryBuilder;
    /** @documentationMaturity preview */
    exists: (propertyName: '_id' | 'data' | string, value: boolean) => DataItemsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    ascending: (...propertyNames: Array<'_id' | 'data' | string>) => DataItemsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    descending: (...propertyNames: Array<'_id' | 'data' | string>) => DataItemsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
     * @documentationMaturity preview
     */
    limit: (limit: number) => DataItemsQueryBuilder;
    /** @param skip - Number of items to skip in the query results before returning the results.
     * @documentationMaturity preview
     */
    skip: (skip: number) => DataItemsQueryBuilder;
    /** @documentationMaturity preview */
    find: () => Promise<DataItemsQueryResult>;
}
/**
 * Runs an aggregation on a data collection and returns the resulting list of items.
 *
 *
 * An aggregation enables you to perform certain calculations on your collection data, or on groups of items that you define, to retrieve meaningful summaries.
 * You can also add paging, filtering, and sorting preferences to your aggregation to retrieve exactly what you need.
 * @public
 * @documentationMaturity preview
 * @requiredField options.dataCollectionId
 * @param options - Options for running an aggregation.
 * @permissionScope Read Data Items
 * @applicableIdentity APP
 */
export declare function aggregateDataItems(options?: AggregateDataItemsOptions): Promise<AggregateDataItemsResponse>;
export interface AggregateDataItemsOptions extends AggregateDataItemsRequestPagingMethodOneOf {
    /** ID of the collection on which to run the aggregation. */
    dataCollectionId: string;
    /** Filter applied to the collection's data prior to running the aggregation. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language#getting-started_api-query-language_the-filter-section) for information on how to structure a filter object. */
    initialFilter?: Record<string, any> | null;
    /** Aggregation applied to the data. */
    aggregation?: Aggregation;
    /** Filter applied to the processed data following the aggregation. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language#getting-started_api-query-language_the-filter-section) for information on how to structure a filter object. */
    finalFilter?: Record<string, any> | null;
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
    /**
     * Whether to return the total count in the response for a query with offset paging.
     * When `true`, the `pagingMetadata` object in the response contains a `total` field.
     *
     * Default: `false`
     */
    returnTotalCount?: boolean;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
/**
 * Counts the number of items in a data collection that match the provided filtering preferences.
 *
 * > **Note**: When calling `countDataItems()` following an update to your collection, the result returned may not reflect the most recent changes. If you need the most up-to-date data, set `options.consistentRead` to `true`.
 * @public
 * @documentationMaturity preview
 * @requiredField options.dataCollectionId
 * @param options - Options for counting the number of items in a data collection.
 * @permissionScope Read Data Items
 * @applicableIdentity APP
 */
export declare function countDataItems(options?: CountDataItemsOptions): Promise<CountDataItemsResponse & CountDataItemsResponseNonNullableFields>;
export interface CountDataItemsOptions {
    /** ID of the collection for which to count query results. */
    dataCollectionId: string;
    /**
     * Filter object in the following format:
     *
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`.
     *
     * Examples of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`.
     */
    filter?: Record<string, any> | null;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
/**
 * Retrieves a list of distinct values for a given field in all items that match a query, without duplicates.
 *
 *
 * As with `queryDataItems()`, this endpoint retrieves items based on the filtering, sorting, and paging preferences you provide.
 * However, `queryDistinctValues()` doesn't return all of the full items that match the query.
 * Rather, it returns all unique values of the field you specify in `options.fieldName` for items that match the query.
 * If more than one item has the same value for that field, that value appears only once.
 *
 * For more details on using queries, see [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language).
 *
 * > **Note**: When calling `queryDistinctValues()` following an update to your collection, the data retrieved may not reflect the most recent changes. If you need the most up-to-date data, set `options.consistentRead` to `true`.
 * @public
 * @documentationMaturity preview
 * @requiredField options.dataCollectionId
 * @param options - Options for querying distinct values.
 * @permissionScope Read Data Items
 * @applicableIdentity APP
 */
export declare function queryDistinctValues(options?: QueryDistinctValuesOptions): Promise<QueryDistinctValuesResponse>;
export interface QueryDistinctValuesOptions extends QueryDistinctValuesRequestPagingMethodOneOf {
    /** ID of the collection to query. */
    dataCollectionId: string;
    /** Item field name for which to return all distinct values. */
    fieldName?: string;
    /**
     * Filter object in the following format:
     *
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`.
     *
     * Examples of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`.
     */
    filter?: Record<string, any> | null;
    /**
     * Sort order.
     *
     * Supported values: `ASC`, `DESC`.
     */
    order?: SortOrder;
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Whether to return the total count in the response for a query with offset paging.
     * When `true`, the `pagingMetadata` object in the response contains a `total` field.
     *
     * Default: `false`
     */
    returnTotalCount?: boolean;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
/**
 * Adds multiple items to a collection.
 *
 *
 * When each item is inserted into a collection, its ID is automatically assigned a random value.
 * You can optionally provide your own ID when inserting the item. If you specify an ID that already exists in the collection, the insertion will fail.
 * @public
 * @documentationMaturity preview
 * @requiredField options.dataCollectionId
 * @requiredField options.dataItems
 * @param options - Options for adding multiple items to a collection.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function bulkInsertDataItems(options?: BulkInsertDataItemsOptions): Promise<BulkInsertDataItemsResponse & BulkInsertDataItemsResponseNonNullableFields>;
export interface BulkInsertDataItemsOptions {
    /** ID of the collection in which to insert the items. */
    dataCollectionId: string;
    /** Data items to insert. */
    dataItems: DataItem[];
    /**
     * Whether to return the inserted data items.
     * When `true`, the `results` objects contain a `dataItem` field.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
/**
 * Updates multiple items in a collection.
 *
 *
 * This function replaces each specified data item's existing data with the payload provided in the request.
 *
 * Each item in the request must include an ID. If an item is found in the specified collection with
 * the same ID, that item is updated. If the collection doesn't contain an item with that ID, the update fails.
 *
 * When an item is updated, its `data._updatedDate` field is changed to the current date and time.
 *
 * > **Note:**
 * > After each item is updated, it only contains the fields included in the request. If the existing item has fields with values and those fields
 * > aren't included in the updated item, their values are lost.
 * @public
 * @documentationMaturity preview
 * @requiredField options.dataCollectionId
 * @requiredField options.dataItems
 * @param options - Options for updating multiple items in a collection.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function bulkUpdateDataItems(options?: BulkUpdateDataItemsOptions): Promise<BulkUpdateDataItemsResponse & BulkUpdateDataItemsResponseNonNullableFields>;
export interface BulkUpdateDataItemsOptions {
    /** ID of the collection in which to update items. */
    dataCollectionId: string;
    /** Data items to update. */
    dataItems: DataItem[];
    /**
     * Whether to return the updated data items.
     * When `true`, the `results` objects contain a `dataItem` field.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
/**
 * Inserts or updates multiple items in a collection.
 *
 *
 * This function inserts or updates each item provided, depending on whether it already exists in the collection. For each item:
 *
 * + If you don't provide an ID, a new item is created.
 *
 * + If you provide an ID that doesn't exist in the collection, a new item is created with that ID.
 *
 * + If an item with the ID you provide already exists in the collection, that item is updated. When an item is updated, its `data._updatedDate` field is changed to the current date and time.
 *
 * > **Note:** When you provide an item with an ID that already exists in the collection, the item you provide completely replaces the existing item with that ID.
 * > This means that all of the item's previous fields and values are lost.
 * @public
 * @documentationMaturity preview
 * @requiredField options.dataCollectionId
 * @requiredField options.dataItems
 * @param options - Options for saving multiple items in a collection.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function bulkSaveDataItems(options?: BulkSaveDataItemsOptions): Promise<BulkSaveDataItemsResponse & BulkSaveDataItemsResponseNonNullableFields>;
export interface BulkSaveDataItemsOptions {
    /** ID of the collection in which to insert or update the items. */
    dataCollectionId: string;
    /** Data items to insert or update. */
    dataItems: DataItem[];
    /**
     * Whether to return the saved data item.
     * When `true`, the `results` objects contain a `dataItem` field.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
/**
 * Removes multiple items from a collection.
 *
 *
 * If any items in other collections reference the removed items in reference or multi-reference fields, those fields are cleared.
 *
 * > **Note:** Once an item has been removed from a collection, it can't be restored.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.dataCollectionId
 * @requiredField options.dataItemIds
 * @param options - Options for removing multiple items from a collection.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function bulkRemoveDataItems(options: BulkRemoveDataItemsOptions): Promise<BulkRemoveDataItemsResponse & BulkRemoveDataItemsResponseNonNullableFields>;
export interface BulkRemoveDataItemsOptions {
    /** ID of the collection from which to remove the item. */
    dataCollectionId: string;
    /** IDs of data items to remove. */
    dataItemIds: string[];
}
/**
 * Retrieves the full items referenced in the specified field of an item.
 *
 *
 * Reference and multi-reference fields refer to items in different collections.
 * Use this function to retrieve the full details of the referenced items themselves.
 *
 * For example, suppose you have a **Movies** collection with an **Actors** field that contains references to items in a **People** collection.
 * Querying the **Movies** collection using `queryReferencedDataItems()` returns the relevant **People** items referenced in the **Actors** field of the specified **Movie** item.
 * This gives you information from the **People** collection about each of the actors in the specified movie.
 *
 * > **Note**: When calling `queryReferencedDataItems()` following an update to your collection, the data retrieved may not contain the most recent changes. If you need the most up-to-date data, set `options.consistentRead` to `true`.
 * @public
 * @documentationMaturity preview
 * @requiredField options.dataCollectionId
 * @param options - Options for querying referenced data items.
 * @permissionScope Read Data Items
 * @applicableIdentity APP
 */
export declare function queryReferencedDataItems(options?: QueryReferencedDataItemsOptions): Promise<QueryReferencedDataItemsResponse & QueryReferencedDataItemsResponseNonNullableFields>;
export interface QueryReferencedDataItemsOptions extends QueryReferencedDataItemsRequestPagingMethodOneOf {
    /** ID of the collection containing the referring item. */
    dataCollectionId: string;
    /** ID of the referring item. */
    referringItemId?: string;
    /** Field containing references in the referring item. */
    referringItemFieldName?: string;
    /** Order of the returned referenced items. Sorted by the date each item was referenced. */
    order?: SortOrder;
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Whether to return the total count in the response.
     * When `true`, the `pagingMetadata` object in the response contains a `total` field.
     *
     * Default: `false`
     */
    returnTotalCount?: boolean;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
/**
 * Checks whether a field in a referring item contains a reference to a specified item.
 *
 * > **Note**: When calling `isReferencedDataItem()` following an update to your collection, the result returned may not reflect the most recent changes. If you need the most up-to-date data, set `options.consistentRead` to `true`.
 * @public
 * @documentationMaturity preview
 * @requiredField options.dataCollectionId
 * @requiredField options.referencedItemId
 * @requiredField options.referringItemFieldName
 * @requiredField options.referringItemId
 * @param options - Options for checking whether a field contains a reference to an item.
 * @permissionScope Read Data Items
 * @applicableIdentity APP
 */
export declare function isReferencedDataItem(options?: IsReferencedDataItemOptions): Promise<IsReferencedDataItemResponse & IsReferencedDataItemResponseNonNullableFields>;
export interface IsReferencedDataItemOptions {
    /** ID of the collection containing the referring data item. */
    dataCollectionId: string;
    /** Field to check for a reference to the item that may be referenced. */
    referringItemFieldName: string;
    /** ID of the referring item. */
    referringItemId: string;
    /** ID of the item that may be referenced. */
    referencedItemId: string;
    /**
     * Whether to retrieve data from the primary database instance.
     * This decreases performance but ensures data retrieved is up to date even immediately after an update.
     *
     * Default: `false`
     */
    consistentRead?: boolean;
}
/**
 * Inserts a reference in the specified field in an item in a collection.
 *
 *
 * A reference in `options.dataItemReference` specifies a referring item's ID, the field in which to insert the reference, and the ID of the referenced item.
 * @public
 * @documentationMaturity preview
 * @requiredField options.dataCollectionId
 * @requiredField options.dataItemReference.referencedItemId
 * @requiredField options.dataItemReference.referringItemFieldName
 * @requiredField options.dataItemReference.referringItemId
 * @param options - Options for inserting a reference.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function insertDataItemReference(options?: InsertDataItemReferenceOptions): Promise<InsertDataItemReferenceResponse & InsertDataItemReferenceResponseNonNullableFields>;
export interface InsertDataItemReferenceOptions {
    /** ID of the collection in which to insert the reference. */
    dataCollectionId: string;
    /** Reference to insert */
    dataItemReference?: DataItemReference;
}
/**
 * Removes the specified reference from the specified field.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.dataCollectionId
 * @requiredField options.dataItemReference
 * @requiredField options.dataItemReference.referencedItemId
 * @requiredField options.dataItemReference.referringItemFieldName
 * @requiredField options.dataItemReference.referringItemId
 * @param options - Options for removing a reference.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function removeDataItemReference(options: RemoveDataItemReferenceOptions): Promise<RemoveDataItemReferenceResponse & RemoveDataItemReferenceResponseNonNullableFields>;
export interface RemoveDataItemReferenceOptions {
    /** ID of the collection containing the referring item. */
    dataCollectionId: string;
    /** Reference to remove. */
    dataItemReference: DataItemReference;
}
/**
 * Inserts one or more references in the specified fields of items in a collection.
 *
 *
 * This endpoint adds one or more references to a collection.
 * Each new reference in `options.dataItemReferences` specifies a referring item's ID, the field in which to insert the reference, and the ID of the referenced item.
 * @public
 * @documentationMaturity preview
 * @requiredField options.dataCollectionId
 * @requiredField options.dataItemReferences
 * @requiredField options.dataItemReferences.referencedItemId
 * @requiredField options.dataItemReferences.referringItemFieldName
 * @requiredField options.dataItemReferences.referringItemId
 * @param options - Options for inserting one or more references.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function bulkInsertDataItemReferences(options?: BulkInsertDataItemReferencesOptions): Promise<BulkInsertDataItemReferencesResponse & BulkInsertDataItemReferencesResponseNonNullableFields>;
export interface BulkInsertDataItemReferencesOptions {
    /** ID of the collection containing the referring items. */
    dataCollectionId: string;
    /** References to insert. */
    dataItemReferences: DataItemReference[];
    /**
     * Whether to return the inserted data item references.
     * When `true`, the `results` objects contain a `dataItemReference` field.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
/**
 * Removes one or more references.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.dataCollectionId
 * @requiredField options.dataItemReferences
 * @requiredField options.dataItemReferences.referencedItemId
 * @requiredField options.dataItemReferences.referringItemFieldName
 * @requiredField options.dataItemReferences.referringItemId
 * @param options - Options for removing one or more references.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function bulkRemoveDataItemReferences(options: BulkRemoveDataItemReferencesOptions): Promise<BulkRemoveDataItemReferencesResponse & BulkRemoveDataItemReferencesResponseNonNullableFields>;
export interface BulkRemoveDataItemReferencesOptions {
    /** ID of the collection containing the referring items. */
    dataCollectionId: string;
    /** References to remove. */
    dataItemReferences: DataItemReference[];
}
/**
 * Replaces references in a specified field of a specified data item.
 *
 *
 * This function replaces the existing reference or references contained in the field specified in `options.referringItemFieldName` within the data item specified in `options.referringItemId`.
 * The function removes existing references and in their place it adds references to the items specified in `options.newReferencedItemIds`.
 *
 * > **Note:** If you pass an empty array in `options.newReferencedItemIds`, all existing references are removed.
 * @public
 * @documentationMaturity preview
 * @requiredField options.dataCollectionId
 * @requiredField options.referringItemFieldName
 * @requiredField options.referringItemId
 * @param options - Options for replacing references.
 * @permissionScope Write Data Items
 * @applicableIdentity APP
 */
export declare function replaceDataItemReferences(options?: ReplaceDataItemReferencesOptions): Promise<ReplaceDataItemReferencesResponse & ReplaceDataItemReferencesResponseNonNullableFields>;
export interface ReplaceDataItemReferencesOptions {
    /** ID of the collection containing the referring item. */
    dataCollectionId: string;
    /** Field containing references in the referring item. */
    referringItemFieldName: string;
    /** ID of the referring item. */
    referringItemId: string;
    /** List of new referenced item IDs to replace the existing ones. */
    newReferencedItemIds?: string[];
}
export {};
