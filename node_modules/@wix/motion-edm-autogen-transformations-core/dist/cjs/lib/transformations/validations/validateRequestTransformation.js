"use strict";

exports.__esModule = true;
exports.validateRequestTransformation = validateRequestTransformation;
var _motionEdmAutogenCommon = require("@wix/motion-edm-autogen-common");
var _lodash = require("lodash");
var _corvidEntity = require("../../corvid-entity");
var _helpers = require("../../helpers");
var _customFunctions = require("../custom-functions");
var _reduceTransformation = require("../reduceTransformation");
var _common = require("./common");
const validateSimpleTransformation = (simpleTransformation, path = null) => {
  const validationErrors = [];
  const transformationSegments = simpleTransformation.split('.');
  const firstSegment = transformationSegments[0];
  transformationSegments.filter(_corvidEntity.isReservedCommonFieldName).forEach(invalidName => validationErrors.push((0, _common.validationError)(`cannot refer to ${invalidName} field, consider using ${(0, _corvidEntity.toCorvidName)(invalidName)} instead`, simpleTransformation, path)));
  if ((0, _lodash.some)(transformationSegments, _helpers.isSpreadOperator)) {
    validationErrors.push((0, _common.validationError)('cannot refer to the * operator', simpleTransformation, path));
  }
  if (!(0, _helpers.hasValidArgumentIndex)(firstSegment)) {
    validationErrors.push((0, _common.validationError)('must start with $[N] where N is an index', simpleTransformation, path));
  }
  if ((0, _lodash.filter)(transformationSegments, _helpers.hasValidArgumentIndex).length > 1) {
    validationErrors.push((0, _common.validationError)('must have a single argument-index as the first path segment', simpleTransformation, path));
  }
  return validationErrors;
};
function validateRequestTransformation(transformation) {
  const errors = (0, _reduceTransformation.reduceTransformation)(transformation, {
    visitors: {
      TopLevelSimpleTransformationExpression: simpleTransformation => validateSimpleTransformation(simpleTransformation),
      CustomFunctionExpression: (acc, path, functionName, argumentExpressions, rawExpression) => {
        if (functionName === null || argumentExpressions === null) {
          acc.push((0, _common.validationError)('contains an invalid custom function expression', rawExpression, path));
        } else {
          const argumentExpression = argumentExpressions[0];
          if (functionName === 'constant') {
            if ((0, _helpers.isInvalidJsonValue)(argumentExpression)) {
              acc.push((0, _common.validationError)('must be a valid json value', argumentExpression, path));
            }
          } else {
            // TODO: validate all arguments
            const _argumentExpression$s = argumentExpression.split('.'),
              firstSegment = _argumentExpression$s[0],
              nestedPathSegments = _argumentExpression$s.slice(1);
            if ((0, _helpers.isInvalidJsonPath)(argumentExpression)) {
              acc.push((0, _common.validationError)('must be a valid json-path', argumentExpression, path));
            }
            if (!(0, _helpers.hasValidArgumentIndex)(firstSegment)) {
              acc.push((0, _common.validationError)('must start with $[N] where N is an index', argumentExpression, path));
            }
            nestedPathSegments.forEach(nestedPathSegment => {
              if ((0, _helpers.hasValidArgumentIndex)(nestedPathSegment)) {
                acc.push((0, _common.validationError)('must have a single argument-index as the first path segment', argumentExpression, path));
              }
            });
          }
        }
      },
      NestedSimpleTransformationExpression: (acc, path, simpleTransformationExpression) => {
        const lastPathSegment = (0, _motionEdmAutogenCommon.lastPathSegmentOf)(path);
        const parentPath = (0, _motionEdmAutogenCommon.parentPathOf)(path);
        if ((0, _customFunctions.isFunctionCallExpression)(lastPathSegment)) {
          acc.push((0, _common.validationError)('cannot be a custom function call', lastPathSegment, parentPath));
        }
        if ((0, _helpers.hasValidArgumentIndex)(lastPathSegment)) {
          acc.push((0, _common.validationError)("must start with '$.'", lastPathSegment, parentPath));
        }
        if ((0, _helpers.isSpreadOperator)(lastPathSegment)) {
          acc.push((0, _common.validationError)('cannot refer to the * operator', lastPathSegment, parentPath));
        }
        acc.push(...validateSimpleTransformation(simpleTransformationExpression, path));
      },
      NestedUnsupportedTransformationExpression: (acc, path, value) => {
        acc.push((0, _common.validationError)('must start with $[N] where N is an index', value, path));
      },
      TopLevelUnsupportedTransformationExpression: unsupportedTransformation => [(0, _common.validationError)('must start with $[N] where N is an index', unsupportedTransformation)],
      TopLevelOmit: (source, fieldsToOmit) => (0, _common.validateOmitTransformation)({
        source,
        fieldsToOmit,
        validateSource: validateRequestTransformation
      }),
      NestedOmit: (acc, path, source, fieldsToOmit) => acc.push(...(0, _common.validateOmitTransformation)({
        source,
        fieldsToOmit,
        parentPath: path,
        validateSource: validateRequestTransformation
      }))
    },
    accumulator: []
  });
  return {
    isValid: errors.length === 0,
    validationErrors: errors
  };
}
//# sourceMappingURL=validateRequestTransformation.js.map