"use strict";

exports.__esModule = true;
exports.validateResponseTransformation = validateResponseTransformation;
var _motionEdmAutogenCommon = require("@wix/motion-edm-autogen-common");
var _lodash = require("lodash");
var _corvidEntity = require("../../corvid-entity");
var _helpers = require("../../helpers");
var _common = require("../common");
var _customFunctions = require("../custom-functions");
var _reduceTransformation = require("../reduceTransformation");
var _common2 = require("./common");
const ARRAY_ITEMS_PATH_PROPERTY_NAME = _common.transformations.ARRAY_ITEMS_PATH_PROPERTY_NAME,
  ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME = _common.transformations.ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME;
const INVALID_PATH_STRING_MESSAGE = "must be a string starting with '$.'";
const validateArrayItemTransformation = (sourceArrayExpression, itemTransformation, parentPath = null) => {
  const withOptionalParentPath = path => err => ({
    ...err,
    // @ts-expect-error
    parentPath: [parentPath, path, _common2.validationError.parentPath].filter(s => s).join('.')
  });
  const validationErrors = [];
  if ((0, _helpers.isInvalidJsonPath)(sourceArrayExpression)) {
    const fullPath = parentPath ? [parentPath, ARRAY_ITEMS_PATH_PROPERTY_NAME] : [ARRAY_ITEMS_PATH_PROPERTY_NAME];
    validationErrors.push((0, _common2.validationError)(INVALID_PATH_STRING_MESSAGE, sourceArrayExpression, fullPath.join('.')));
  }
  validationErrors.push(
  // eslint-disable-next-line no-use-before-define
  ...validateResponseTransformation(sourceArrayExpression).validationErrors.map(withOptionalParentPath(ARRAY_ITEMS_PATH_PROPERTY_NAME)),
  // eslint-disable-next-line no-use-before-define
  ...validateResponseTransformation(itemTransformation).validationErrors.map(withOptionalParentPath(ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME)));
  return validationErrors;
};
const validateSimpleTransformationExpression = (simpleTransformationExpression, path = null) => {
  const transformationSegments = simpleTransformationExpression.split('.');
  const firstExpressionSegment = transformationSegments[0];
  const validationErrors = [];
  if (!(0, _helpers.isRootObjectIdentifier)(firstExpressionSegment)) {
    validationErrors.push((0, _common2.validationError)(INVALID_PATH_STRING_MESSAGE, simpleTransformationExpression, path));
  }
  if ((0, _lodash.some)(transformationSegments, _helpers.isSpreadOperator)) {
    validationErrors.push((0, _common2.validationError)('cannot refer to the * operator', simpleTransformationExpression, path));
  }
  if ((0, _helpers.isInvalidJsonPath)(simpleTransformationExpression)) {
    validationErrors.push((0, _common2.validationError)('must be a valid json-path', simpleTransformationExpression, path));
  }
  transformationSegments.filter(_corvidEntity.isReservedCorvidFieldName).forEach(invalidName => validationErrors.push((0, _common2.validationError)(`cannot refer to the ${invalidName} field`, simpleTransformationExpression, path)));
  return validationErrors;
};
const validateCustomFunctionExpression = ({
  functionName,
  argumentExpressions,
  rawExpression,
  path = null
}) => {
  const validationErrors = [];
  if (functionName === null || argumentExpressions === null) {
    validationErrors.push((0, _common2.validationError)('contains an invalid custom function expression', rawExpression, path));
    return validationErrors;
  }

  // TODO: validate all arguments
  const argumentExpression = argumentExpressions[0];
  const _argumentExpression$s = argumentExpression.split('.'),
    firstSegment = _argumentExpression$s[0];
  if ((0, _helpers.isInvalidJsonPath)(argumentExpression)) {
    validationErrors.push((0, _common2.validationError)('must be a valid json-path', argumentExpression, path));
  }
  if (!(0, _helpers.isRootObjectIdentifier)(firstSegment)) {
    validationErrors.push((0, _common2.validationError)(INVALID_PATH_STRING_MESSAGE, argumentExpression, path));
  }
  return validationErrors;
};
function validateResponseTransformation(transformation) {
  const errors = (0, _reduceTransformation.reduceTransformation)(transformation, {
    visitors: {
      TopLevelSimpleTransformationExpression: simpleTransformation => validateSimpleTransformationExpression(simpleTransformation),
      TopLevelCustomFunctionExpression: (functionName, argumentExpressions, rawExpression) => validateCustomFunctionExpression({
        functionName,
        argumentExpressions,
        rawExpression
      }),
      CustomFunctionExpression: (acc, path, functionName, argumentExpressions, rawExpression) => {
        acc.push(...validateCustomFunctionExpression({
          functionName,
          argumentExpressions,
          rawExpression,
          path
        }));
      },
      NestedSimpleTransformationExpression: (acc, path, simpleTransformationExpression) => {
        const lastPathSegment = (0, _motionEdmAutogenCommon.lastPathSegmentOf)(path);
        const parentPath = (0, _motionEdmAutogenCommon.parentPathOf)(path);
        acc.push(...validateSimpleTransformationExpression(simpleTransformationExpression, path));
        if ((0, _customFunctions.isFunctionCallExpression)(lastPathSegment)) {
          acc.push((0, _common2.validationError)('cannot be a custom function call', lastPathSegment, parentPath));
        }
        if ((0, _corvidEntity.isReservedCorvidFieldName)(lastPathSegment)) {
          acc.push((0, _common2.validationError)(`cannot refer to the ${lastPathSegment} field`, lastPathSegment, parentPath));
        }
        if ((0, _helpers.hasValidArgumentIndex)(lastPathSegment)) {
          acc.push((0, _common2.validationError)(INVALID_PATH_STRING_MESSAGE, lastPathSegment, parentPath));
        }
        if ((0, _helpers.isRootObjectIdentifier)(lastPathSegment)) {
          acc.push((0, _common2.validationError)('cannot refer to $ in a transformation key', lastPathSegment, parentPath));
        }
      },
      NestedUnsupportedTransformationExpression: (acc, path, value) => {
        acc.push((0, _common2.validationError)(INVALID_PATH_STRING_MESSAGE, value, path));
      },
      TopLevelUnsupportedTransformationExpression: unsupportedTransformation => [(0, _common2.validationError)(INVALID_PATH_STRING_MESSAGE, unsupportedTransformation)],
      TopLevelOmit: (source, fieldsToOmit) => (0, _common2.validateOmitTransformation)({
        source,
        fieldsToOmit,
        validateSource: validateResponseTransformation
      }),
      NestedOmit: (acc, path, source, fieldsToOmit) => acc.push(...(0, _common2.validateOmitTransformation)({
        source,
        fieldsToOmit,
        parentPath: path,
        validateSource: validateResponseTransformation
      })),
      MapArrayItems: (acc, path, sourceArrayExpression, itemTransformation) => {
        acc.push(...validateArrayItemTransformation(sourceArrayExpression, itemTransformation, path));
      },
      TopLevelMapArrayItems: (sourceArrayExpression, itemTransformation) => validateArrayItemTransformation(sourceArrayExpression, itemTransformation)
    },
    accumulator: []
  });
  return {
    isValid: errors.length === 0,
    validationErrors: errors
  };
}
//# sourceMappingURL=validateResponseTransformation.js.map