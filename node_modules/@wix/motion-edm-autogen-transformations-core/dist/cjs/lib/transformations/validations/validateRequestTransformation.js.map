{"version":3,"names":["_motionEdmAutogenCommon","require","_lodash","_corvidEntity","_helpers","_customFunctions","_reduceTransformation","_common","validateSimpleTransformation","simpleTransformation","path","validationErrors","transformationSegments","split","firstSegment","filter","isReservedCommonFieldName","forEach","invalidName","push","validationError","toCorvidName","some","isSpreadOperator","hasValidArgumentIndex","length","validateRequestTransformation","transformation","errors","reduceTransformation","visitors","TopLevelSimpleTransformationExpression","CustomFunctionExpression","acc","functionName","argumentExpressions","rawExpression","argumentExpression","isInvalidJsonValue","_argumentExpression$s","nestedPathSegments","slice","isInvalidJsonPath","nestedPathSegment","NestedSimpleTransformationExpression","simpleTransformationExpression","lastPathSegment","lastPathSegmentOf","parentPath","parentPathOf","isFunctionCallExpression","NestedUnsupportedTransformationExpression","value","TopLevelUnsupportedTransformationExpression","unsupportedTransformation","TopLevelOmit","source","fieldsToOmit","validateOmitTransformation","validateSource","NestedOmit","accumulator","isValid"],"sources":["../../../../../src/lib/transformations/validations/validateRequestTransformation.ts"],"sourcesContent":["import {\n  lastPathSegmentOf,\n  parentPathOf,\n} from '@wix/motion-edm-autogen-common';\nimport { filter, some } from 'lodash';\n\nimport { isReservedCommonFieldName, toCorvidName } from '../../corvid-entity';\nimport {\n  hasValidArgumentIndex,\n  isInvalidJsonPath,\n  isInvalidJsonValue,\n  isSpreadOperator,\n} from '../../helpers';\nimport { isFunctionCallExpression } from '../custom-functions';\nimport { reduceTransformation } from '../reduceTransformation';\nimport { validateOmitTransformation, validationError } from './common';\n\nconst validateSimpleTransformation = (simpleTransformation, path = null) => {\n  const validationErrors: any[] = [];\n  const transformationSegments = simpleTransformation.split('.');\n  const [firstSegment] = transformationSegments;\n\n  transformationSegments\n    .filter(isReservedCommonFieldName)\n    .forEach((invalidName) =>\n      validationErrors.push(\n        validationError(\n          `cannot refer to ${invalidName} field, consider using ${toCorvidName(\n            invalidName,\n          )} instead`,\n          simpleTransformation,\n          path,\n        ),\n      ),\n    );\n\n  if (some(transformationSegments, isSpreadOperator)) {\n    validationErrors.push(\n      validationError(\n        'cannot refer to the * operator',\n        simpleTransformation,\n        path,\n      ),\n    );\n  }\n\n  if (!hasValidArgumentIndex(firstSegment)) {\n    validationErrors.push(\n      validationError(\n        'must start with $[N] where N is an index',\n        simpleTransformation,\n        path,\n      ),\n    );\n  }\n\n  if (filter(transformationSegments, hasValidArgumentIndex).length > 1) {\n    validationErrors.push(\n      validationError(\n        'must have a single argument-index as the first path segment',\n        simpleTransformation,\n        path,\n      ),\n    );\n  }\n\n  return validationErrors;\n};\n\nfunction validateRequestTransformation(transformation) {\n  const errors = reduceTransformation(transformation, {\n    visitors: {\n      TopLevelSimpleTransformationExpression: (simpleTransformation) =>\n        validateSimpleTransformation(simpleTransformation),\n      CustomFunctionExpression: (\n        acc,\n        path,\n        functionName,\n        argumentExpressions,\n        rawExpression,\n      ) => {\n        if (functionName === null || argumentExpressions === null) {\n          acc.push(\n            validationError(\n              'contains an invalid custom function expression',\n              rawExpression,\n              path,\n            ),\n          );\n        } else {\n          const [argumentExpression] = argumentExpressions;\n\n          if (functionName === 'constant') {\n            if (isInvalidJsonValue(argumentExpression)) {\n              acc.push(\n                validationError(\n                  'must be a valid json value',\n                  argumentExpression,\n                  path,\n                ),\n              );\n            }\n          } else {\n            // TODO: validate all arguments\n            const [firstSegment, ...nestedPathSegments] =\n              argumentExpression.split('.');\n\n            if (isInvalidJsonPath(argumentExpression)) {\n              acc.push(\n                validationError(\n                  'must be a valid json-path',\n                  argumentExpression,\n                  path,\n                ),\n              );\n            }\n\n            if (!hasValidArgumentIndex(firstSegment)) {\n              acc.push(\n                validationError(\n                  'must start with $[N] where N is an index',\n                  argumentExpression,\n                  path,\n                ),\n              );\n            }\n\n            nestedPathSegments.forEach((nestedPathSegment) => {\n              if (hasValidArgumentIndex(nestedPathSegment)) {\n                acc.push(\n                  validationError(\n                    'must have a single argument-index as the first path segment',\n                    argumentExpression,\n                    path,\n                  ),\n                );\n              }\n            });\n          }\n        }\n      },\n      NestedSimpleTransformationExpression: (\n        acc,\n        path,\n        simpleTransformationExpression,\n      ) => {\n        const lastPathSegment = lastPathSegmentOf(path);\n        const parentPath = parentPathOf(path);\n\n        if (isFunctionCallExpression(lastPathSegment)) {\n          acc.push(\n            validationError(\n              'cannot be a custom function call',\n              lastPathSegment,\n              parentPath,\n            ),\n          );\n        }\n\n        if (hasValidArgumentIndex(lastPathSegment)) {\n          acc.push(\n            validationError(\n              \"must start with '$.'\",\n              lastPathSegment,\n              parentPath,\n            ),\n          );\n        }\n\n        if (isSpreadOperator(lastPathSegment)) {\n          acc.push(\n            validationError(\n              'cannot refer to the * operator',\n              lastPathSegment,\n              parentPath,\n            ),\n          );\n        }\n\n        acc.push(\n          ...validateSimpleTransformation(simpleTransformationExpression, path),\n        );\n      },\n      NestedUnsupportedTransformationExpression: (acc, path, value) => {\n        acc.push(\n          validationError(\n            'must start with $[N] where N is an index',\n            value,\n            path,\n          ),\n        );\n      },\n      TopLevelUnsupportedTransformationExpression: (\n        unsupportedTransformation,\n      ) => [\n        validationError(\n          'must start with $[N] where N is an index',\n          unsupportedTransformation,\n        ),\n      ],\n      TopLevelOmit: (source, fieldsToOmit) =>\n        validateOmitTransformation({\n          source,\n          fieldsToOmit,\n          validateSource: validateRequestTransformation,\n        }),\n      NestedOmit: (acc, path, source, fieldsToOmit) =>\n        acc.push(\n          ...validateOmitTransformation({\n            source,\n            fieldsToOmit,\n            parentPath: path,\n            validateSource: validateRequestTransformation,\n          }),\n        ),\n    },\n    accumulator: [],\n  });\n\n  return {\n    isValid: errors.length === 0,\n    validationErrors: errors,\n  };\n}\n\nexport { validateRequestTransformation };\n"],"mappings":"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"}