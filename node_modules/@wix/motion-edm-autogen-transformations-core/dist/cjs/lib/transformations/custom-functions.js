"use strict";

exports.__esModule = true;
exports.runCustomFunctionCallExpression = exports.parseCustomFunctionCall = exports.isFunctionCallExpression = void 0;
var _lodash = require("lodash");
// eslint-disable-next-line max-len
const FUNCTION_CALL_EXPRESSION_REGEX = /^#(?<functionName>[a-zA-Z0-9]+(\.[a-zA-Z0-9]+)*)\((?<argumentExpressions>[\S ]*)\)$/;
const parseCustomFunctionCall = functionCallExpression => {
  const match = functionCallExpression.match(FUNCTION_CALL_EXPRESSION_REGEX);
  const argumentExpressions = (0, _lodash.get)(match, 'groups.argumentExpressions', null);
  return {
    functionName: (0, _lodash.get)(match, 'groups.functionName', null),
    argumentExpressions: argumentExpressions === null ? argumentExpressions : argumentExpressions.split(',').filter(s => s).map(_lodash.trim)
  };
};
exports.parseCustomFunctionCall = parseCustomFunctionCall;
const isFunctionCallExpression = expression => (0, _lodash.isString)(expression) && expression.startsWith('#');
exports.isFunctionCallExpression = isFunctionCallExpression;
const runCustomFunctionCallExpression = ({
  customFunctions,
  functionName,
  argumentValues = [],
  transformationParentPath
}) => {
  const customFunction = (0, _lodash.get)(customFunctions, functionName);
  if (!customFunction) {
    throw new Error(`unrecognized custom function "${functionName}"`);
  }
  try {
    return customFunction(...argumentValues);
  } catch (error) {
    throw new Error(`Transforming ${transformationParentPath} failed, #${functionName} threw: "${error.message}" for arguments: ${JSON.stringify(argumentValues)}`);
  }
};
exports.runCustomFunctionCallExpression = runCustomFunctionCallExpression;
//# sourceMappingURL=custom-functions.js.map