{"version":3,"names":["_lodash","require","FUNCTION_CALL_EXPRESSION_REGEX","parseCustomFunctionCall","functionCallExpression","match","argumentExpressions","get","functionName","split","filter","s","map","trim","exports","isFunctionCallExpression","expression","isString","startsWith","runCustomFunctionCallExpression","customFunctions","argumentValues","transformationParentPath","customFunction","Error","error","message","JSON","stringify"],"sources":["../../../../src/lib/transformations/custom-functions.ts"],"sourcesContent":["import { get, isString, trim } from 'lodash';\n\n// eslint-disable-next-line max-len\nconst FUNCTION_CALL_EXPRESSION_REGEX =\n  /^#(?<functionName>[a-zA-Z0-9]+(\\.[a-zA-Z0-9]+)*)\\((?<argumentExpressions>[\\S ]*)\\)$/;\n\nconst parseCustomFunctionCall = (functionCallExpression) => {\n  const match = functionCallExpression.match(FUNCTION_CALL_EXPRESSION_REGEX);\n\n  const argumentExpressions = get(match, 'groups.argumentExpressions', null);\n\n  return {\n    functionName: get(match, 'groups.functionName', null),\n    argumentExpressions:\n      argumentExpressions === null\n        ? argumentExpressions\n        : argumentExpressions\n            .split(',')\n            .filter((s) => s)\n            .map(trim),\n  };\n};\n\nconst isFunctionCallExpression = (expression) =>\n  isString(expression) && expression.startsWith('#');\n\nconst runCustomFunctionCallExpression = ({\n  customFunctions,\n  functionName,\n  argumentValues = [],\n  transformationParentPath,\n}: {\n  customFunctions: any;\n  functionName: string;\n  argumentValues: string[];\n  transformationParentPath: string;\n}) => {\n  const customFunction = get(customFunctions, functionName);\n\n  if (!customFunction) {\n    throw new Error(`unrecognized custom function \"${functionName}\"`);\n  }\n\n  try {\n    return customFunction(...argumentValues);\n  } catch (error: any) {\n    throw new Error(\n      `Transforming ${transformationParentPath} failed, #${functionName} threw: \"${\n        error.message\n      }\" for arguments: ${JSON.stringify(argumentValues)}`,\n    );\n  }\n};\n\nexport {\n  isFunctionCallExpression,\n  parseCustomFunctionCall,\n  runCustomFunctionCallExpression,\n};\n"],"mappings":";;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AAEA;AACA,MAAMC,8BAA8B,GAClC,qFAAqF;AAEvF,MAAMC,uBAAuB,GAAIC,sBAAsB,IAAK;EAC1D,MAAMC,KAAK,GAAGD,sBAAsB,CAACC,KAAK,CAACH,8BAA8B,CAAC;EAE1E,MAAMI,mBAAmB,GAAG,IAAAC,WAAG,EAACF,KAAK,EAAE,4BAA4B,EAAE,IAAI,CAAC;EAE1E,OAAO;IACLG,YAAY,EAAE,IAAAD,WAAG,EAACF,KAAK,EAAE,qBAAqB,EAAE,IAAI,CAAC;IACrDC,mBAAmB,EACjBA,mBAAmB,KAAK,IAAI,GACxBA,mBAAmB,GACnBA,mBAAmB,CAChBG,KAAK,CAAC,GAAG,CAAC,CACVC,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAAC,CAChBC,GAAG,CAACC,YAAI;EACnB,CAAC;AACH,CAAC;AAACC,OAAA,CAAAX,uBAAA,GAAAA,uBAAA;AAEF,MAAMY,wBAAwB,GAAIC,UAAU,IAC1C,IAAAC,gBAAQ,EAACD,UAAU,CAAC,IAAIA,UAAU,CAACE,UAAU,CAAC,GAAG,CAAC;AAACJ,OAAA,CAAAC,wBAAA,GAAAA,wBAAA;AAErD,MAAMI,+BAA+B,GAAGA,CAAC;EACvCC,eAAe;EACfZ,YAAY;EACZa,cAAc,GAAG,EAAE;EACnBC;AAMF,CAAC,KAAK;EACJ,MAAMC,cAAc,GAAG,IAAAhB,WAAG,EAACa,eAAe,EAAEZ,YAAY,CAAC;EAEzD,IAAI,CAACe,cAAc,EAAE;IACnB,MAAM,IAAIC,KAAK,CAAE,iCAAgChB,YAAa,GAAE,CAAC;EACnE;EAEA,IAAI;IACF,OAAOe,cAAc,CAAC,GAAGF,cAAc,CAAC;EAC1C,CAAC,CAAC,OAAOI,KAAU,EAAE;IACnB,MAAM,IAAID,KAAK,CACZ,gBAAeF,wBAAyB,aAAYd,YAAa,YAChEiB,KAAK,CAACC,OACP,oBAAmBC,IAAI,CAACC,SAAS,CAACP,cAAc,CAAE,EACrD,CAAC;EACH;AACF,CAAC;AAACP,OAAA,CAAAK,+BAAA,GAAAA,+BAAA"}