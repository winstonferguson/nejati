{"version":3,"names":["_motionRuntimeTestContext","require","_lodash","_","_customFunctions","describe","test","each","argumentExpressions","expectedArgumentExpressions","functionName","aString","functionExpression","expect","parseCustomFunctionCall","toStrictEqual","expression","expectedResult","isFunctionCallExpression","value","transformationParentPath","joinWithDots","args","join","argumentValues","customFunctions","set","result","runCustomFunctionCallExpression","times","toThrow","Error","t","RegExp"],"sources":["../../../../src/__tests__/transformations/custom-functions.spec.ts"],"sourcesContent":["import { aString } from '@wix/motion-runtime-test-context';\nimport { set, times } from 'lodash';\n\nimport { isFunctionCallExpression, parseCustomFunctionCall } from '../..';\nimport { runCustomFunctionCallExpression } from '../../lib/transformations/custom-functions';\n\ndescribe('parseCustomFunctionCall', () => {\n  /* eslint-disable max-len */\n  test.each`\n    argumentCount                            | argumentExpressions                      | expectedArgumentExpressions\n    ${'a single argument'}                   | ${'$[0].some.path'}                      | ${['$[0].some.path']}\n    ${'multiple arguments'}                  | ${'$[0].some.path,someString'}           | ${['$[0].some.path', 'someString']}\n    ${'multiple arguments with whitespaces'} | ${'$[0].some.path,   someString , $[1]'} | ${['$[0].some.path', 'someString', '$[1]']}\n    ${'no arguments'}                        | ${''}                                    | ${[]}\n  `(\n    /* eslint-enable max-len */\n    'parses a custom-function call applied with $argumentCount',\n    ({ argumentExpressions, expectedArgumentExpressions }) => {\n      const functionName = aString();\n      const functionExpression = `#${functionName}(${argumentExpressions})`;\n\n      expect(parseCustomFunctionCall(functionExpression)).toStrictEqual({\n        functionName,\n        argumentExpressions: expectedArgumentExpressions,\n      });\n    },\n  );\n});\n\ndescribe('isFunctionCallExpression', () => {\n  test.each`\n    description                                      | expression                 | expectedResult\n    ${'a #-prefixed with a valid function name'}     | ${'#someInvalidName$#@#>'} | ${true}\n    ${'a non-# prefixed with a valid function name'} | ${'someFunctions($[1])'}   | ${false}\n    ${'a non-string value'}                          | ${[1, 2, 3]}               | ${false}\n  `(\n    'returns $expectedResult when $description function call expression is provided',\n    ({ expression, expectedResult }) => {\n      expect(isFunctionCallExpression(expression)).toStrictEqual(\n        expectedResult,\n      );\n    },\n  );\n});\n\ndescribe('runCustomFunctionCallExpression', () => {\n  const value = aString();\n  const transformationParentPath = aString();\n  const joinWithDots = (...args) => args.join('|');\n\n  describe.each`\n    argumentCount | argumentValues    | expectedResult\n    ${'single'}   | ${[value]}        | ${value}\n    ${'multi'}    | ${[value, value]} | ${`${value}|${value}`}\n    ${'no'}       | ${[]}             | ${''}\n  `(\n    '$argumentCount-argument expression',\n    ({ argumentValues, expectedResult }) => {\n      describe.each`\n        functionName                | description\n        ${'someFunction'}           | ${'an unscoped'}\n        ${'someScope.someFunction'} | ${'a scoped'}\n      `('$description custom function', ({ functionName }) => {\n        const customFunctions = set({}, functionName, joinWithDots);\n\n        test('runs it and returns its result', () => {\n          const result = runCustomFunctionCallExpression({\n            functionName,\n            customFunctions,\n            argumentValues,\n            transformationParentPath,\n          });\n\n          expect(result).toStrictEqual(expectedResult);\n        });\n      });\n    },\n  );\n\n  describe('error handling', () => {\n    const argumentValues = times(2, () => aString());\n\n    test('throws when the function is not recognized', () => {\n      const customFunctions = {};\n\n      expect(() =>\n        runCustomFunctionCallExpression({\n          functionName: 'someNonexistentFunction',\n          customFunctions,\n          argumentValues,\n          transformationParentPath,\n        }),\n      ).toThrow(`unrecognized custom function \"someNonexistentFunction\"`);\n    });\n\n    test('throws an error when the function call throws an error', () => {\n      const functionName = aString();\n\n      const customFunctions = {\n        [functionName]: () => {\n          throw new Error('Something went wrong in the custom function');\n        },\n      };\n\n      const t = () =>\n        runCustomFunctionCallExpression({\n          functionName,\n          customFunctions,\n          argumentValues,\n          transformationParentPath,\n        });\n\n      expect(t).toThrow(Error);\n      expect(t).toThrow(\n        new RegExp(\n          `Transforming ${transformationParentPath} failed, #${functionName} threw: \"Something went wrong in the custom function\" for arguments: .+`,\n        ),\n      );\n    });\n  });\n});\n"],"mappings":"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"}