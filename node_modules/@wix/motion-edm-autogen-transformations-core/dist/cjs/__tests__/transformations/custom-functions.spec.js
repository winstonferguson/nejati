"use strict";

var _motionRuntimeTestContext = require("@wix/motion-runtime-test-context");
var _lodash = require("lodash");
var _ = require("../..");
var _customFunctions = require("../../lib/transformations/custom-functions");
describe('parseCustomFunctionCall', () => {
  /* eslint-disable max-len */
  test.each`
    argumentCount                            | argumentExpressions                      | expectedArgumentExpressions
    ${'a single argument'}                   | ${'$[0].some.path'}                      | ${['$[0].some.path']}
    ${'multiple arguments'}                  | ${'$[0].some.path,someString'}           | ${['$[0].some.path', 'someString']}
    ${'multiple arguments with whitespaces'} | ${'$[0].some.path,   someString , $[1]'} | ${['$[0].some.path', 'someString', '$[1]']}
    ${'no arguments'}                        | ${''}                                    | ${[]}
  `( /* eslint-enable max-len */
  'parses a custom-function call applied with $argumentCount', ({
    argumentExpressions,
    expectedArgumentExpressions
  }) => {
    const functionName = (0, _motionRuntimeTestContext.aString)();
    const functionExpression = `#${functionName}(${argumentExpressions})`;
    expect((0, _.parseCustomFunctionCall)(functionExpression)).toStrictEqual({
      functionName,
      argumentExpressions: expectedArgumentExpressions
    });
  });
});
describe('isFunctionCallExpression', () => {
  test.each`
    description                                      | expression                 | expectedResult
    ${'a #-prefixed with a valid function name'}     | ${'#someInvalidName$#@#>'} | ${true}
    ${'a non-# prefixed with a valid function name'} | ${'someFunctions($[1])'}   | ${false}
    ${'a non-string value'}                          | ${[1, 2, 3]}               | ${false}
  `('returns $expectedResult when $description function call expression is provided', ({
    expression,
    expectedResult
  }) => {
    expect((0, _.isFunctionCallExpression)(expression)).toStrictEqual(expectedResult);
  });
});
describe('runCustomFunctionCallExpression', () => {
  const value = (0, _motionRuntimeTestContext.aString)();
  const transformationParentPath = (0, _motionRuntimeTestContext.aString)();
  const joinWithDots = (...args) => args.join('|');
  describe.each`
    argumentCount | argumentValues    | expectedResult
    ${'single'}   | ${[value]}        | ${value}
    ${'multi'}    | ${[value, value]} | ${`${value}|${value}`}
    ${'no'}       | ${[]}             | ${''}
  `('$argumentCount-argument expression', ({
    argumentValues,
    expectedResult
  }) => {
    describe.each`
        functionName                | description
        ${'someFunction'}           | ${'an unscoped'}
        ${'someScope.someFunction'} | ${'a scoped'}
      `('$description custom function', ({
      functionName
    }) => {
      const customFunctions = (0, _lodash.set)({}, functionName, joinWithDots);
      test('runs it and returns its result', () => {
        const result = (0, _customFunctions.runCustomFunctionCallExpression)({
          functionName,
          customFunctions,
          argumentValues,
          transformationParentPath
        });
        expect(result).toStrictEqual(expectedResult);
      });
    });
  });
  describe('error handling', () => {
    const argumentValues = (0, _lodash.times)(2, () => (0, _motionRuntimeTestContext.aString)());
    test('throws when the function is not recognized', () => {
      const customFunctions = {};
      expect(() => (0, _customFunctions.runCustomFunctionCallExpression)({
        functionName: 'someNonexistentFunction',
        customFunctions,
        argumentValues,
        transformationParentPath
      })).toThrow(`unrecognized custom function "someNonexistentFunction"`);
    });
    test('throws an error when the function call throws an error', () => {
      const functionName = (0, _motionRuntimeTestContext.aString)();
      const customFunctions = {
        [functionName]: () => {
          throw new Error('Something went wrong in the custom function');
        }
      };
      const t = () => (0, _customFunctions.runCustomFunctionCallExpression)({
        functionName,
        customFunctions,
        argumentValues,
        transformationParentPath
      });
      expect(t).toThrow(Error);
      expect(t).toThrow(new RegExp(`Transforming ${transformationParentPath} failed, #${functionName} threw: "Something went wrong in the custom function" for arguments: .+`));
    });
  });
});
//# sourceMappingURL=custom-functions.spec.js.map