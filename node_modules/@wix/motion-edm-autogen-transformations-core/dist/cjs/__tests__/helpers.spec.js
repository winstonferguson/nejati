"use strict";

var _motionEdmAutogenTestContext = require("@wix/motion-edm-autogen-test-context");
var _motionRuntimeTestContext = require("@wix/motion-runtime-test-context");
var _lodash = require("lodash");
var _helpers = require("../lib/helpers");
describe('helper functions', () => {
  const index = (0, _motionRuntimeTestContext.aNumber)({
    min: 0,
    max: 1
  });
  // @ts-expect-error
  const nestedPath = (0, _lodash.times)(3, (0, _motionRuntimeTestContext.aString)()).join('.');
  const simpleTransformation = `$[${index}]`;
  const simpleTransformationWithNestedPath = `$[${index}].${nestedPath}`;
  describe('isSimpleTransformation', () => {
    test.each`
      transformation                                    | expectedValue | transformationType
      ${(0, _motionEdmAutogenTestContext.aSimpleMappingTransformation)().simpleMapping}   | ${true}       | ${'simple'}
      ${(0, _motionEdmAutogenTestContext.aComplexMappingTransformation)().complexMapping} | ${false}      | ${'complex'}
    `('returns $expectedValue for $transformationType transformation', ({
      transformation,
      expectedValue
    }) => {
      expect((0, _helpers.isSimpleTransformation)(transformation)).toStrictEqual(expectedValue);
    });
  });
  describe('extractIndexAndPath', () => {
    test('extracts the index and nested-path of the argument from a simple tranformation', () => {
      expect((0, _helpers.extractIndexAndPath)(simpleTransformationWithNestedPath)).toStrictEqual({
        index,
        nestedPath
      });
    });
    test('sets the nestedPath to null when one could not be found', () => {
      expect((0, _helpers.extractIndexAndPath)(simpleTransformation)).toStrictEqual({
        index,
        nestedPath: null
      });
    });
  });
  describe('getArgumentIndex', () => {
    test('extracts the index of an argument within a jsonpath', () => {
      expect((0, _helpers.getArgumentIndex)(simpleTransformation)).toStrictEqual(index);
    });
    test('return null when no index was found', () => {
      expect((0, _helpers.getArgumentIndex)((0, _motionRuntimeTestContext.aString)())).toBeNull();
    });
  });
  describe('isJsonPathExpression', () => {
    test.each`
      description                | expression           | expectedResult
      ${'starts with $'}         | ${(0, _motionEdmAutogenTestContext.aRandomJsonPath)()} | ${true}
      ${'does not start with $'} | ${(0, _motionRuntimeTestContext.aString)()}         | ${false}
    `('return $expectedResult when the expression $description', ({
      expression,
      expectedResult
    }) => {
      expect((0, _helpers.isJsonPathExpression)(expression)).toStrictEqual(expectedResult);
    });
  });
  describe('stripJsonPathRootPrefix', () => {
    const nonJsonPathString = (0, _motionRuntimeTestContext.aString)();
    const jsonPath = (0, _motionEdmAutogenTestContext.aRandomResponseTransformationJsonPath)();
    test.each`
      description                | expression           | expectedResult
      ${'is $'}                  | ${'$'}               | ${'$'}
      ${'does not start with $'} | ${nonJsonPathString} | ${nonJsonPathString}
      ${'starts with $.'}        | ${jsonPath}          | ${jsonPath.slice(2)}
    `('return $expectedResult when the expression $description', ({
      expression,
      expectedResult
    }) => {
      expect((0, _helpers.stripJsonPathRootPrefix)(expression)).toStrictEqual(expectedResult);
    });
  });
  describe('isInvalidJsonValue', () => {
    test('returns true for an invalid json-value', () => {
      expect((0, _helpers.isInvalidJsonValue)('x-y-z')).toBeTruthy();
    });
    test('returns false for a valid json-value', () => {
      expect((0, _helpers.isInvalidJsonValue)('"string"')).toBeFalsy();
    });
  });
});
//# sourceMappingURL=helpers.spec.js.map