"use strict";

var _motionRuntimeTestContext = require("@wix/motion-runtime-test-context");
var _lodash = require("lodash");
var _reduceTransformation = require("../lib/transformations/reduceTransformation");
describe('reduceTransformation', () => {
  describe('simple transformations', () => {
    const visitorCallbackResult = (0, _motionRuntimeTestContext.aString)();
    test('traverses a simple transformation', () => {
      const visitorCallback = jest.fn().mockReturnValueOnce(visitorCallbackResult);
      const transformation = '$.a.b.c';
      const result = (0, _reduceTransformation.reduceTransformation)(transformation, {
        visitors: {
          TopLevelSimpleTransformationExpression: visitorCallback
        }
      });
      expect(visitorCallback).toHaveBeenCalledTimes(1);
      expect(visitorCallback).toHaveBeenCalledWith('$.a.b.c');
      expect(result).toStrictEqual(visitorCallbackResult);
    });
    describe('custom-functions', () => {
      test('traverses a valid custom-function expression', () => {
        const visitorCallback = jest.fn().mockReturnValueOnce(visitorCallbackResult);
        const transformation = '#someCustomFunction($.a.b.c,someOtherArg)';
        const result = (0, _reduceTransformation.reduceTransformation)(transformation, {
          visitors: {
            TopLevelCustomFunctionExpression: visitorCallback
          }
        });
        expect(visitorCallback).toHaveBeenCalledTimes(1);
        expect(visitorCallback).toHaveBeenCalledWith('someCustomFunction', ['$.a.b.c', 'someOtherArg'], transformation);
        expect(result).toStrictEqual(visitorCallbackResult);
      });
      test('does not fail for invalid custom-function expression', () => {
        const visitorCallback = jest.fn().mockReturnValueOnce(visitorCallbackResult);
        const transformationWithInvalidCustomFunctionExpression = '#($.a.b.c)';
        const result = (0, _reduceTransformation.reduceTransformation)(transformationWithInvalidCustomFunctionExpression, {
          visitors: {
            TopLevelCustomFunctionExpression: visitorCallback
          }
        });
        expect(visitorCallback).toHaveBeenCalledTimes(1);
        expect(visitorCallback).toHaveBeenCalledWith(null, null, transformationWithInvalidCustomFunctionExpression);
        expect(result).toStrictEqual(visitorCallbackResult);
      });
    });

    // TODO: replace with returning the invalid value, for constant-transformation
    test('invokes the TopLevelUnsupportedTransformationExpression otherwise', () => {
      const visitorCallback = jest.fn().mockReturnValueOnce(visitorCallbackResult);
      const transformation = (0, _motionRuntimeTestContext.aString)();
      const result = (0, _reduceTransformation.reduceTransformation)(transformation, {
        visitors: {
          TopLevelUnsupportedTransformationExpression: visitorCallback
        }
      });
      expect(visitorCallback).toHaveBeenCalledTimes(1);
      expect(visitorCallback).toHaveBeenCalledWith(transformation);
      expect(result).toStrictEqual(visitorCallbackResult);
    });
  });
  describe('complex transformation', () => {
    const accumulator = (0, _motionRuntimeTestContext.anObject)();
    test('traverses all string nodes that are transformation expressions', () => {
      const visitorCallback = jest.fn();
      const transformation = {
        a: {
          b: {
            c: '$[0].ddd.eee.ffff'
          },
          d: 2,
          e: ['$.ggg', 3, 4, 5]
        }
      };
      (0, _reduceTransformation.reduceTransformation)(transformation, {
        accumulator,
        visitors: {
          NestedSimpleTransformationExpression: visitorCallback
        }
      });
      expect(visitorCallback).toHaveBeenCalledTimes(2);
      expect(visitorCallback).toHaveBeenCalledWith(accumulator, 'a.b.c', '$[0].ddd.eee.ffff');
      expect(visitorCallback).toHaveBeenCalledWith(accumulator, 'a.e[0]', '$.ggg');
    });
    describe('spread operator', () => {
      const _times = (0, _lodash.times)(2, () => jest.fn()),
        topLevelSpreadOperatorCallback = _times[0],
        nestedSpreadOperatorCallback = _times[1];
      const argumentExpression = '$[1].d.e.f';
      const sibling = (0, _motionRuntimeTestContext.anObject)();
      const siblingKeys = Object.keys(sibling);
      const path = `${siblingKeys[0]}.b.c`;
      beforeEach(() => {
        [topLevelSpreadOperatorCallback, nestedSpreadOperatorCallback].forEach(mock => mock.mockClear());
      });
      test('invokes the spread operator visitor prior to its children', () => {
        const nestedOmitCallback = jest.fn();
        const omitExpression = {
          '@source': argumentExpression,
          '@omit': (0, _lodash.times)(2, () => (0, _motionRuntimeTestContext.aString)())
        };
        const transformation = {
          '*': omitExpression,
          ...sibling
        };
        (0, _reduceTransformation.reduceTransformation)(transformation, {
          accumulator,
          visitors: {
            TopLevelSpreadExpression: topLevelSpreadOperatorCallback,
            NestedOmit: nestedOmitCallback
          }
        });
        expect(topLevelSpreadOperatorCallback).toHaveBeenCalledTimes(1);
        expect(topLevelSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, omitExpression, siblingKeys);

        // expect(nestedOmitCallback).toHaveBeenCalled();
      });

      test('traverses top-level spread-operator transformation nodes', () => {
        const transformation = {
          '*': argumentExpression,
          ...sibling
        };
        (0, _reduceTransformation.reduceTransformation)(transformation, {
          accumulator,
          visitors: {
            TopLevelSpreadExpression: topLevelSpreadOperatorCallback,
            NestedSpreadExpression: nestedSpreadOperatorCallback
          }
        });
        expect(topLevelSpreadOperatorCallback).toHaveBeenCalledTimes(1);
        expect(topLevelSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, argumentExpression, siblingKeys);
        expect(nestedSpreadOperatorCallback).not.toHaveBeenCalled();
      });
      test('traverses nested spread-operator transformation nodes', () => {
        const transformation = (0, _lodash.set)({}, path, {
          '*': argumentExpression,
          ...sibling
        });
        const simpleTransformationCallback = jest.fn();
        (0, _reduceTransformation.reduceTransformation)(transformation, {
          accumulator,
          visitors: {
            TopLevelSpreadExpression: topLevelSpreadOperatorCallback,
            NestedSpreadExpression: nestedSpreadOperatorCallback,
            NestedSimpleTransformationExpression: simpleTransformationCallback
          }
        });
        expect(topLevelSpreadOperatorCallback).not.toHaveBeenCalled();
        expect(simpleTransformationCallback).not.toHaveBeenCalled();
        expect(nestedSpreadOperatorCallback).toHaveBeenCalledTimes(1);
        expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, argumentExpression, siblingKeys);
      });
      test('traverses items within an array of a spread-operator transformation nodes', () => {
        const simpleTransformationCallback = jest.fn();
        const transformation = (0, _lodash.set)({}, path, {
          '*': ['$[0].x.y.z', '$[1].d.e.f'],
          ...sibling
        });
        (0, _reduceTransformation.reduceTransformation)(transformation, {
          accumulator,
          visitors: {
            NestedSpreadExpression: nestedSpreadOperatorCallback,
            NestedSimpleTransformationExpression: simpleTransformationCallback
          }
        });
        expect(nestedSpreadOperatorCallback).toHaveBeenCalledTimes(2);
        expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, '$[0].x.y.z', siblingKeys);
        expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, '$[1].d.e.f', siblingKeys);
        expect(simpleTransformationCallback).not.toHaveBeenCalled();
      });
      test('sets the path to be the parent of the spread operator', () => {
        const anotherArgumentExpression = '$[0].x.y.z';
        const topLevelArgumentExpression = '$[1]';
        const transformation = (0, _lodash.set)({
          '*': topLevelArgumentExpression,
          ...sibling
        }, path, {
          '*': [anotherArgumentExpression, argumentExpression]
        });
        (0, _reduceTransformation.reduceTransformation)(transformation, {
          accumulator,
          visitors: {
            NestedSpreadExpression: nestedSpreadOperatorCallback,
            TopLevelSpreadExpression: topLevelSpreadOperatorCallback
          }
        });
        expect(nestedSpreadOperatorCallback).toHaveBeenCalledTimes(2);
        expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, argumentExpression, []);
        expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, anotherArgumentExpression, []);
        expect(topLevelSpreadOperatorCallback).toHaveBeenCalledTimes(1);
        expect(topLevelSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, topLevelArgumentExpression, siblingKeys);
      });
    });
    describe('custom functions', () => {
      test('traverses custom-function nodes', () => {
        const customFunctionExpressionCallback = jest.fn();
        const simpleTransformationCallback = jest.fn();
        const customFunctionExpression = '#someCustomFunction($[0].someCustomFunction)';
        const transformation = {
          a: {
            b: customFunctionExpression
          }
        };
        (0, _reduceTransformation.reduceTransformation)(transformation, {
          accumulator,
          visitors: {
            CustomFunctionExpression: customFunctionExpressionCallback,
            NestedSimpleTransformationExpression: simpleTransformationCallback
          }
        });
        expect(customFunctionExpressionCallback).toHaveBeenCalledTimes(1);
        expect(customFunctionExpressionCallback).toHaveBeenCalledWith(accumulator, 'a.b', 'someCustomFunction', ['$[0].someCustomFunction'], customFunctionExpression);
        expect(simpleTransformationCallback).not.toHaveBeenCalled();
      });
      test('does not fail on invalid custom-function nodes', () => {
        const customFunctionExpressionCallback = jest.fn();
        const simpleTransformationCallback = jest.fn();
        const invalidCustomFunctionExpression = '#($[0].someCustomFunction)';
        const transformation = {
          a: {
            b: invalidCustomFunctionExpression
          }
        };
        (0, _reduceTransformation.reduceTransformation)(transformation, {
          accumulator,
          visitors: {
            CustomFunctionExpression: customFunctionExpressionCallback,
            NestedSimpleTransformationExpression: simpleTransformationCallback
          }
        });
        expect(customFunctionExpressionCallback).toHaveBeenCalledTimes(1);
        expect(customFunctionExpressionCallback).toHaveBeenCalledWith(accumulator, 'a.b', null, null, invalidCustomFunctionExpression);
        expect(simpleTransformationCallback).not.toHaveBeenCalled();
      });
    });
    describe('constant annotation', () => {
      test('traverses a nested constant annotation expression', () => {
        const nestedConstantExpressionCallback = jest.fn();
        const undesiredVisitor = jest.fn();
        const transformation = {
          a: {
            b: {
              c: {
                '@constant': {
                  someConst: '$.value123'
                }
              }
            }
          }
        };
        (0, _reduceTransformation.reduceTransformation)(transformation, {
          accumulator,
          visitors: {
            NestedConstantValue: nestedConstantExpressionCallback,
            NestedSimpleTransformationExpression: undesiredVisitor
          }
        });
        expect(nestedConstantExpressionCallback).toHaveBeenCalledTimes(1);
        expect(nestedConstantExpressionCallback).toHaveBeenCalledWith({
          accumulator,
          path: 'a.b.c',
          value: {
            someConst: '$.value123'
          }
        });
        expect(undesiredVisitor).not.toHaveBeenCalled();
      });
    });
    test('returns the accumulator with changes made to it', () => {
      const countAccumulator = {
        count: 0
      };
      const transformation = {
        a: {
          b: 1,
          '*': '$[0].a.b.c'
        }
      };
      const result = (0, _reduceTransformation.reduceTransformation)(transformation, {
        accumulator: countAccumulator,
        visitors: {
          NestedSpreadExpression: () => {
            countAccumulator.count += 1;
          }
        }
      });
      expect(result).toStrictEqual({
        count: 1
      });
    });

    // TODO: replace with returning the invalid value, for constant-transformation
    test('invokes the NestedUnsupportedTransformationExpression otherwise', () => {
      const visitorCallback = jest.fn();
      const unsupportedTransformationValue = (0, _motionRuntimeTestContext.aString)();
      const transformation = {
        a: {
          b: {
            c: unsupportedTransformationValue
          }
        }
      };
      (0, _reduceTransformation.reduceTransformation)(transformation, {
        visitors: {
          NestedUnsupportedTransformationExpression: visitorCallback
        },
        accumulator
      });
      expect(visitorCallback).toHaveBeenCalledTimes(1);
      expect(visitorCallback).toHaveBeenCalledWith(accumulator, 'a.b.c', unsupportedTransformationValue);
    });
  });
  describe('mapping array items', () => {
    const visitorCallback = jest.fn();
    beforeEach(() => {
      visitorCallback.mockClear();
    });
    describe('top-level transformation', () => {
      test('invokes the TopLevelMapArrayItems visitor', () => {
        const transformation = {
          '@path': '$.d.e.f',
          '@itemTransformation': '$.g.h.i'
        };
        (0, _reduceTransformation.reduceTransformation)(transformation, {
          visitors: {
            TopLevelMapArrayItems: visitorCallback
          },
          accumulator: {}
        });
        expect(visitorCallback).toHaveBeenCalledTimes(1);
        expect(visitorCallback).toHaveBeenCalledWith('$.d.e.f', '$.g.h.i');
      });
    });
    describe('nested transformation', () => {
      const accumulator = {};
      const path = 'a.b.c';
      const withItemTransformation = itemTransformation => (0, _lodash.set)({}, path, {
        '@path': '$.d.e.f',
        '@itemTransformation': itemTransformation
      });
      describe('simple item-transformation', () => {
        test('invokes the MapArrayItems visitor', () => {
          (0, _reduceTransformation.reduceTransformation)(withItemTransformation('$.g.h.i'), {
            visitors: {
              MapArrayItems: visitorCallback
            },
            accumulator
          });
          expect(visitorCallback).toHaveBeenCalledTimes(1);
          expect(visitorCallback).toHaveBeenCalledWith(accumulator, path, '$.d.e.f', '$.g.h.i');
        });
      });
      describe('complex item-transformation', () => {
        test('invokes the MapArrayItems visitor', () => {
          const nestedSimpleTransformationVisitor = jest.fn();
          (0, _reduceTransformation.reduceTransformation)(withItemTransformation({
            yyy: '$.g.h.i',
            zzz: '$.j.k.l'
          }), {
            visitors: {
              MapArrayItems: visitorCallback,
              NestedSimpleTransformationExpression: nestedSimpleTransformationVisitor
            },
            accumulator
          });
          expect(visitorCallback).toHaveBeenCalledTimes(1);
          expect(visitorCallback).toHaveBeenCalledWith(accumulator, path, '$.d.e.f', {
            yyy: '$.g.h.i',
            zzz: '$.j.k.l'
          });
          expect(nestedSimpleTransformationVisitor).not.toHaveBeenCalled();
        });
      });
    });
  });
  describe('omit notation', () => {
    const fieldsToOmit = (0, _lodash.times)(2, () => (0, _motionRuntimeTestContext.aString)());
    const visitorCallback = jest.fn();
    const sourcePathExpression = '$.d.e.f';
    const path = 'a.b.c';
    const accumulator = {};
    beforeEach(() => {
      visitorCallback.mockClear();
    });
    describe('top-level transformation', () => {
      test('invokes the TopLevelOmit visitor', () => {
        const transformation = {
          '@source': sourcePathExpression,
          '@omit': fieldsToOmit
        };
        (0, _reduceTransformation.reduceTransformation)(transformation, {
          visitors: {
            TopLevelOmit: visitorCallback
          },
          accumulator
        });
        expect(visitorCallback).toHaveBeenCalledTimes(1);
        expect(visitorCallback).toHaveBeenCalledWith(sourcePathExpression, fieldsToOmit);
      });
    });
    describe('nested transformation', () => {
      test('invokes the NestedOmit visitor', () => {
        const transformation = (0, _lodash.set)({}, path, {
          '@source': sourcePathExpression,
          '@omit': fieldsToOmit
        });
        (0, _reduceTransformation.reduceTransformation)(transformation, {
          visitors: {
            NestedOmit: visitorCallback
          },
          accumulator
        });
        expect(visitorCallback).toHaveBeenCalledTimes(1);
        expect(visitorCallback).toHaveBeenCalledWith(accumulator, path, sourcePathExpression, fieldsToOmit);
      });
    });
  });
  describe('error handling', () => {
    describe.each`
      transformation                                       | visitorType
      ${'$.a.b.c'}                                         | ${'TopLevelSimpleTransformationExpression'}
      ${'#someCustomFunc($.a.b.c)'}                        | ${'TopLevelCustomFunctionExpression'}
      ${{
      a: {
        b: {
          c: 'unsupported transformation'
        }
      }
    }} | ${'NestedUnsupportedTransformationExpression'}
      ${{
      a: {
        b: {
          c: '$.d.e.f'
        }
      }
    }}                    | ${'NestedSimpleTransformationExpression'}
      ${{
      '*': '$.d.e.f'
    }}                                | ${'TopLevelSpreadExpression'}
      ${{
      a: {
        '*': '$.d.e.f'
      }
    }}                         | ${'NestedSpreadExpression'}
      ${{
      a: {
        b: '#someCustomFunction($.d.e.f)'
      }
    }}      | ${'CustomFunctionExpression'}
    `('$visitor visitor', ({
      transformation,
      visitorType
    }) => {
      test(`rethrows the error thrown by the ${visitorType} visitor`, () => {
        const errorMessage = (0, _motionRuntimeTestContext.aString)();
        const error = new Error(errorMessage);
        const visitorCallback = jest.fn().mockImplementationOnce(() => {
          throw error;
        });
        expect(() => (0, _reduceTransformation.reduceTransformation)(transformation, {
          visitors: {
            [visitorType]: visitorCallback
          }
        })).toThrow(error);
      });
      test(`does not fail when the ${visitorType} visitor is missing`, () => {
        expect(() => (0, _reduceTransformation.reduceTransformation)(transformation, {
          visitors: {
            [visitorType]: null
          }
        })).not.toThrow();
      });
    });
  });
});
//# sourceMappingURL=reduceTransformation.spec.js.map