{"version":3,"names":["_motionEdmAutogenTestContext","require","_motionRuntimeTestContext","_lodash","_helpers","describe","index","aNumber","min","max","nestedPath","times","aString","join","simpleTransformation","simpleTransformationWithNestedPath","test","each","aSimpleMappingTransformation","simpleMapping","aComplexMappingTransformation","complexMapping","transformation","expectedValue","expect","isSimpleTransformation","toStrictEqual","extractIndexAndPath","getArgumentIndex","toBeNull","aRandomJsonPath","expression","expectedResult","isJsonPathExpression","nonJsonPathString","jsonPath","aRandomResponseTransformationJsonPath","slice","stripJsonPathRootPrefix","isInvalidJsonValue","toBeTruthy","toBeFalsy"],"sources":["../../../src/__tests__/helpers.spec.ts"],"sourcesContent":["import {\n  aComplexMappingTransformation,\n  aRandomJsonPath,\n  aRandomResponseTransformationJsonPath,\n  aSimpleMappingTransformation,\n} from '@wix/motion-edm-autogen-test-context';\nimport { aNumber, aString } from '@wix/motion-runtime-test-context';\nimport { times } from 'lodash';\n\nimport {\n  extractIndexAndPath,\n  getArgumentIndex,\n  isInvalidJsonValue,\n  isJsonPathExpression,\n  isSimpleTransformation,\n  stripJsonPathRootPrefix,\n} from '../lib/helpers';\n\ndescribe('helper functions', () => {\n  const index = aNumber({ min: 0, max: 1 });\n  // @ts-expect-error\n  const nestedPath = times(3, aString()).join('.');\n  const simpleTransformation = `$[${index}]`;\n  const simpleTransformationWithNestedPath = `$[${index}].${nestedPath}`;\n\n  describe('isSimpleTransformation', () => {\n    test.each`\n      transformation                                    | expectedValue | transformationType\n      ${aSimpleMappingTransformation().simpleMapping}   | ${true}       | ${'simple'}\n      ${aComplexMappingTransformation().complexMapping} | ${false}      | ${'complex'}\n    `(\n      'returns $expectedValue for $transformationType transformation',\n      ({ transformation, expectedValue }) => {\n        expect(isSimpleTransformation(transformation)).toStrictEqual(\n          expectedValue,\n        );\n      },\n    );\n  });\n\n  describe('extractIndexAndPath', () => {\n    test('extracts the index and nested-path of the argument from a simple tranformation', () => {\n      expect(\n        extractIndexAndPath(simpleTransformationWithNestedPath),\n      ).toStrictEqual({ index, nestedPath });\n    });\n\n    test('sets the nestedPath to null when one could not be found', () => {\n      expect(extractIndexAndPath(simpleTransformation)).toStrictEqual({\n        index,\n        nestedPath: null,\n      });\n    });\n  });\n\n  describe('getArgumentIndex', () => {\n    test('extracts the index of an argument within a jsonpath', () => {\n      expect(getArgumentIndex(simpleTransformation)).toStrictEqual(index);\n    });\n\n    test('return null when no index was found', () => {\n      expect(getArgumentIndex(aString())).toBeNull();\n    });\n  });\n\n  describe('isJsonPathExpression', () => {\n    test.each`\n      description                | expression           | expectedResult\n      ${'starts with $'}         | ${aRandomJsonPath()} | ${true}\n      ${'does not start with $'} | ${aString()}         | ${false}\n    `(\n      'return $expectedResult when the expression $description',\n      ({ expression, expectedResult }) => {\n        expect(isJsonPathExpression(expression)).toStrictEqual(expectedResult);\n      },\n    );\n  });\n\n  describe('stripJsonPathRootPrefix', () => {\n    const nonJsonPathString = aString();\n    const jsonPath = aRandomResponseTransformationJsonPath();\n\n    test.each`\n      description                | expression           | expectedResult\n      ${'is $'}                  | ${'$'}               | ${'$'}\n      ${'does not start with $'} | ${nonJsonPathString} | ${nonJsonPathString}\n      ${'starts with $.'}        | ${jsonPath}          | ${jsonPath.slice(2)}\n    `(\n      'return $expectedResult when the expression $description',\n      ({ expression, expectedResult }) => {\n        expect(stripJsonPathRootPrefix(expression)).toStrictEqual(\n          expectedResult,\n        );\n      },\n    );\n  });\n\n  describe('isInvalidJsonValue', () => {\n    test('returns true for an invalid json-value', () => {\n      expect(isInvalidJsonValue('x-y-z')).toBeTruthy();\n    });\n\n    test('returns false for a valid json-value', () => {\n      expect(isInvalidJsonValue('\"string\"')).toBeFalsy();\n    });\n  });\n});\n"],"mappings":"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"}