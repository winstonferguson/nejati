{"version":3,"names":["_motionRuntimeTestContext","require","_lodash","_","validateRequestTransformation","validation","describe","validResults","isValid","validationErrors","test","validTransformation","expect","toStrictEqual","a","validationErrorWith","parentPath","invalidValue","description","arrayContaining","objectContaining","each","transformationKey","expectedValidationMessage","transformation","d","e","f","parentKey","aString","invalidSourceValue","invalidSourceTransformation","times","invalidTransformation","expectedParentPath","transformationWithOmitValue","value","nonArray","nonStringArray","aNumber","arrayWithInvalidPaths","invalidCustomFunctionCallExpression","b","c","invalidCustomFunctionExpression","transformationValue","specialField"],"sources":["../../../../src/__tests__/validations/validateRequestTransformation.spec.ts"],"sourcesContent":["import { aNumber, aString } from '@wix/motion-runtime-test-context';\nimport { times } from 'lodash';\n\nimport { validation } from '../..';\n\nconst { validateRequestTransformation } = validation;\n\ndescribe('validateRequestTransformation', () => {\n  describe('valid transformations', () => {\n    const validResults = { isValid: true, validationErrors: [] };\n\n    test('returns valid transformation response for a valid simple transformation', () => {\n      const validTransformation = '$[0].a.b.c';\n\n      expect(validateRequestTransformation(validTransformation)).toStrictEqual(\n        validResults,\n      );\n    });\n\n    test('returns valid transformation response for a valid complex transformation', () => {\n      const validTransformation = { a: '$[0].a.b.c' };\n\n      expect(validateRequestTransformation(validTransformation)).toStrictEqual(\n        validResults,\n      );\n    });\n  });\n\n  describe('invalid transformations', () => {\n    const validationErrorWith = ({\n      parentPath,\n      invalidValue,\n      description,\n    }) => ({\n      isValid: false,\n      validationErrors: expect.arrayContaining([\n        expect.objectContaining({\n          parentPath,\n          invalidValue,\n          description,\n        }),\n      ]),\n    });\n\n    describe('invalid complex-transformation keys', () => {\n      test.each`\n        description                      | transformationKey  | expectedValidationMessage\n        ${'refers to an argument index'} | ${'$[0]'}          | ${\"must start with '$.'\"}\n        ${'refers to a custom function'} | ${'#someFunction'} | ${'cannot be a custom function call'}\n      `(\n        'returns a validation error when a transformation value segment $description',\n        ({ transformationKey, expectedValidationMessage }) => {\n          const transformation = {\n            d: { e: { f: { [transformationKey]: '$[0].a.b.c' } } },\n            '*': '$[1]',\n          };\n\n          expect(validateRequestTransformation(transformation)).toStrictEqual(\n            validationErrorWith({\n              parentPath: 'd.e.f',\n              invalidValue: transformationKey,\n              description: expectedValidationMessage,\n            }),\n          );\n        },\n      );\n    });\n\n    describe('invalid transformations values', () => {\n      describe('omit transformation', () => {\n        const parentKey = aString();\n\n        describe('invalid source', () => {\n          const invalidSourceValue = '$[x].a.b.c';\n          const invalidSourceTransformation = {\n            '@source': invalidSourceValue,\n            '@omit': times(2, () => aString()),\n          };\n\n          test.each`\n            description    | invalidTransformation                           | expectedParentPath\n            ${'top level'} | ${invalidSourceTransformation}                  | ${'@source'}\n            ${'nested'}    | ${{ [parentKey]: invalidSourceTransformation }} | ${`${parentKey}.@source`}\n          `(\n            'returns a validation error when the @source value is invalid',\n            ({ invalidTransformation, expectedParentPath }) => {\n              expect(\n                validateRequestTransformation(invalidTransformation),\n              ).toStrictEqual(\n                validationErrorWith({\n                  parentPath: expectedParentPath,\n                  invalidValue: invalidSourceValue,\n                  description: 'must start with $[N] where N is an index',\n                }),\n              );\n            },\n          );\n        });\n\n        describe('invalid @omit', () => {\n          const transformationWithOmitValue = (value) => ({\n            '@source': '$[0].a.b.c',\n            '@omit': value,\n          });\n\n          const nonArray = aString();\n          const nonStringArray = times(2, () => aNumber());\n          const arrayWithInvalidPaths = ['a.b.c', aString()];\n\n          describe.each`\n            description    | invalidTransformation                                     | expectedParentPath\n            ${'top level'} | ${transformationWithOmitValue(nonArray)}                  | ${'@omit'}\n            ${'nested'}    | ${{ [parentKey]: transformationWithOmitValue(nonArray) }} | ${`${parentKey}.@omit`}\n          `(\n            '@omit is not an array',\n            ({ invalidTransformation, expectedParentPath }) => {\n              test('returns a validation error', () => {\n                expect(\n                  validateRequestTransformation(invalidTransformation),\n                ).toStrictEqual(\n                  validationErrorWith({\n                    parentPath: expectedParentPath,\n                    invalidValue: nonArray,\n                    description: 'must be an array of strings',\n                  }),\n                );\n              });\n            },\n          );\n\n          describe.each`\n            description    | invalidTransformation                                           | expectedParentPath\n            ${'top level'} | ${transformationWithOmitValue(nonStringArray)}                  | ${'@omit'}\n            ${'nested'}    | ${{ [parentKey]: transformationWithOmitValue(nonStringArray) }} | ${`${parentKey}.@omit`}\n          `(\n            '@omit is an array of non-strings',\n            ({ invalidTransformation, expectedParentPath }) => {\n              test('return a validation error', () => {\n                expect(\n                  validateRequestTransformation(invalidTransformation),\n                ).toStrictEqual(\n                  validationErrorWith({\n                    parentPath: expectedParentPath,\n                    invalidValue: nonStringArray,\n                    description: 'must be an array of strings',\n                  }),\n                );\n              });\n            },\n          );\n\n          /* eslint-disable max-len */\n          describe.each`\n            description    | invalidTransformation                                                  | expectedParentPath\n            ${'top level'} | ${transformationWithOmitValue(arrayWithInvalidPaths)}                  | ${'@omit'}\n            ${'nested'}    | ${{ [parentKey]: transformationWithOmitValue(arrayWithInvalidPaths) }} | ${`${parentKey}.@omit`}\n          `(\n            '@omit is an array with invalid string paths',\n            ({ description, invalidTransformation, expectedParentPath }) => {\n              /* eslint-enable max-len */\n              test(`returns a validation error for invalid ${description} transformation`, () => {\n                expect(\n                  validateRequestTransformation(invalidTransformation),\n                ).toStrictEqual(\n                  validationErrorWith({\n                    parentPath: expectedParentPath,\n                    invalidValue: arrayWithInvalidPaths,\n                    description: 'must contain non-nested paths only',\n                  }),\n                );\n              });\n            },\n          );\n        });\n      });\n\n      describe('custom function expressions', () => {\n        test('returns a validation error when an invalid custom function-name is used', () => {\n          const invalidCustomFunctionCallExpression = '#1a';\n          const transformation = {\n            a: { b: { c: invalidCustomFunctionCallExpression } },\n          };\n\n          expect(validateRequestTransformation(transformation)).toStrictEqual(\n            validationErrorWith({\n              parentPath: 'a.b.c',\n              invalidValue: invalidCustomFunctionCallExpression,\n              description: 'contains an invalid custom function expression',\n            }),\n          );\n        });\n\n        test('returns a validation error when a custom function argument is invalid for request transformation', () => {\n          const invalidCustomFunctionExpression = '#someFunction($.id)';\n          const transformation = {\n            a: { b: { c: invalidCustomFunctionExpression } },\n          };\n\n          expect(validateRequestTransformation(transformation)).toStrictEqual(\n            validationErrorWith({\n              parentPath: 'a.b.c',\n              invalidValue: '$.id',\n              description: 'must start with $[N] where N is an index',\n            }),\n          );\n        });\n\n        describe('#constant function', () => {\n          test('returns a validation error when passed value is not a valid json value', () => {\n            const invalidCustomFunctionExpression = '#constant(not-json)';\n            const transformation = {\n              a: { b: { c: invalidCustomFunctionExpression } },\n            };\n\n            expect(validateRequestTransformation(transformation)).toStrictEqual(\n              validationErrorWith({\n                parentPath: 'a.b.c',\n                invalidValue: 'not-json',\n                description: 'must be a valid json value',\n              }),\n            );\n          });\n\n          test('allows passing non json-path arguments to the #constant function', () => {\n            const transformation = { a: { b: { c: '#constant(\"abc\")' } } };\n\n            expect(validateRequestTransformation(transformation)).toStrictEqual(\n              {\n                isValid: true,\n                validationErrors: [],\n              },\n            );\n          });\n        });\n      });\n\n      /* eslint-disable max-len */\n      describe.each`\n        description                                                  | transformationValue | expectedValidationMessage\n        ${'does not start with $[N] where N is a numeric index'}     | ${'$[x].a.b.c'}     | ${'must start with $[N] where N is an index'}\n        ${'is not a valid json-path'}                                | ${'@'}              | ${'must start with $[N] where N is an index'}\n        ${'has several arguments referred to in the transformation'} | ${'$[0].$[1]'}      | ${'must have a single argument-index as the first path segment'}\n        ${'refers to * in the path'}                                 | ${'$[0].a.b.*'}     | ${'cannot refer to the * operator'}\n      `(\n        /* eslint-enable max-len */\n        'returns a validation error when a transformation value segment $description',\n        ({ transformationValue, expectedValidationMessage }) => {\n          test('simple transformation', () => {\n            expect(\n              validateRequestTransformation(transformationValue),\n            ).toStrictEqual(\n              validationErrorWith({\n                parentPath: null,\n                invalidValue: transformationValue,\n                description: expectedValidationMessage,\n              }),\n            );\n          });\n\n          test('complex transformation', () => {\n            const transformation = { a: { b: { c: transformationValue } } };\n\n            expect(validateRequestTransformation(transformation)).toStrictEqual(\n              validationErrorWith({\n                parentPath: 'a.b.c',\n                invalidValue: transformationValue,\n                description: expectedValidationMessage,\n              }),\n            );\n          });\n        },\n      );\n\n      describe('special fields', () => {\n        describe.each(['id', 'createdDate', 'updatedDate'])(\n          '%s',\n          (specialField) => {\n            const transformationValue = `$[0].a.b.${specialField}`;\n            // eslint-disable-next-line max-len\n            const expectedValidationMessage = `cannot refer to ${specialField} field, consider using _${specialField} instead`;\n\n            test('simple transformation', () => {\n              expect(\n                validateRequestTransformation(transformationValue),\n              ).toStrictEqual(\n                validationErrorWith({\n                  parentPath: null,\n                  invalidValue: transformationValue,\n                  description: expectedValidationMessage,\n                }),\n              );\n            });\n\n            test('complex transformation', () => {\n              const transformation = { a: { b: { c: transformationValue } } };\n\n              expect(\n                validateRequestTransformation(transformation),\n              ).toStrictEqual(\n                validationErrorWith({\n                  parentPath: 'a.b.c',\n                  invalidValue: transformationValue,\n                  description: expectedValidationMessage,\n                }),\n              );\n            });\n          },\n        );\n      });\n    });\n  });\n});\n"],"mappings":"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"}