"use strict";

var _motionRuntimeTestContext = require("@wix/motion-runtime-test-context");
var _lodash = require("lodash");
var _ = require("../..");
const validateRequestTransformation = _.validation.validateRequestTransformation;
describe('validateRequestTransformation', () => {
  describe('valid transformations', () => {
    const validResults = {
      isValid: true,
      validationErrors: []
    };
    test('returns valid transformation response for a valid simple transformation', () => {
      const validTransformation = '$[0].a.b.c';
      expect(validateRequestTransformation(validTransformation)).toStrictEqual(validResults);
    });
    test('returns valid transformation response for a valid complex transformation', () => {
      const validTransformation = {
        a: '$[0].a.b.c'
      };
      expect(validateRequestTransformation(validTransformation)).toStrictEqual(validResults);
    });
  });
  describe('invalid transformations', () => {
    const validationErrorWith = ({
      parentPath,
      invalidValue,
      description
    }) => ({
      isValid: false,
      validationErrors: expect.arrayContaining([expect.objectContaining({
        parentPath,
        invalidValue,
        description
      })])
    });
    describe('invalid complex-transformation keys', () => {
      test.each`
        description                      | transformationKey  | expectedValidationMessage
        ${'refers to an argument index'} | ${'$[0]'}          | ${"must start with '$.'"}
        ${'refers to a custom function'} | ${'#someFunction'} | ${'cannot be a custom function call'}
      `('returns a validation error when a transformation value segment $description', ({
        transformationKey,
        expectedValidationMessage
      }) => {
        const transformation = {
          d: {
            e: {
              f: {
                [transformationKey]: '$[0].a.b.c'
              }
            }
          },
          '*': '$[1]'
        };
        expect(validateRequestTransformation(transformation)).toStrictEqual(validationErrorWith({
          parentPath: 'd.e.f',
          invalidValue: transformationKey,
          description: expectedValidationMessage
        }));
      });
    });
    describe('invalid transformations values', () => {
      describe('omit transformation', () => {
        const parentKey = (0, _motionRuntimeTestContext.aString)();
        describe('invalid source', () => {
          const invalidSourceValue = '$[x].a.b.c';
          const invalidSourceTransformation = {
            '@source': invalidSourceValue,
            '@omit': (0, _lodash.times)(2, () => (0, _motionRuntimeTestContext.aString)())
          };
          test.each`
            description    | invalidTransformation                           | expectedParentPath
            ${'top level'} | ${invalidSourceTransformation}                  | ${'@source'}
            ${'nested'}    | ${{
            [parentKey]: invalidSourceTransformation
          }} | ${`${parentKey}.@source`}
          `('returns a validation error when the @source value is invalid', ({
            invalidTransformation,
            expectedParentPath
          }) => {
            expect(validateRequestTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
              parentPath: expectedParentPath,
              invalidValue: invalidSourceValue,
              description: 'must start with $[N] where N is an index'
            }));
          });
        });
        describe('invalid @omit', () => {
          const transformationWithOmitValue = value => ({
            '@source': '$[0].a.b.c',
            '@omit': value
          });
          const nonArray = (0, _motionRuntimeTestContext.aString)();
          const nonStringArray = (0, _lodash.times)(2, () => (0, _motionRuntimeTestContext.aNumber)());
          const arrayWithInvalidPaths = ['a.b.c', (0, _motionRuntimeTestContext.aString)()];
          describe.each`
            description    | invalidTransformation                                     | expectedParentPath
            ${'top level'} | ${transformationWithOmitValue(nonArray)}                  | ${'@omit'}
            ${'nested'}    | ${{
            [parentKey]: transformationWithOmitValue(nonArray)
          }} | ${`${parentKey}.@omit`}
          `('@omit is not an array', ({
            invalidTransformation,
            expectedParentPath
          }) => {
            test('returns a validation error', () => {
              expect(validateRequestTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
                parentPath: expectedParentPath,
                invalidValue: nonArray,
                description: 'must be an array of strings'
              }));
            });
          });
          describe.each`
            description    | invalidTransformation                                           | expectedParentPath
            ${'top level'} | ${transformationWithOmitValue(nonStringArray)}                  | ${'@omit'}
            ${'nested'}    | ${{
            [parentKey]: transformationWithOmitValue(nonStringArray)
          }} | ${`${parentKey}.@omit`}
          `('@omit is an array of non-strings', ({
            invalidTransformation,
            expectedParentPath
          }) => {
            test('return a validation error', () => {
              expect(validateRequestTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
                parentPath: expectedParentPath,
                invalidValue: nonStringArray,
                description: 'must be an array of strings'
              }));
            });
          });

          /* eslint-disable max-len */
          describe.each`
            description    | invalidTransformation                                                  | expectedParentPath
            ${'top level'} | ${transformationWithOmitValue(arrayWithInvalidPaths)}                  | ${'@omit'}
            ${'nested'}    | ${{
            [parentKey]: transformationWithOmitValue(arrayWithInvalidPaths)
          }} | ${`${parentKey}.@omit`}
          `('@omit is an array with invalid string paths', ({
            description,
            invalidTransformation,
            expectedParentPath
          }) => {
            /* eslint-enable max-len */
            test(`returns a validation error for invalid ${description} transformation`, () => {
              expect(validateRequestTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
                parentPath: expectedParentPath,
                invalidValue: arrayWithInvalidPaths,
                description: 'must contain non-nested paths only'
              }));
            });
          });
        });
      });
      describe('custom function expressions', () => {
        test('returns a validation error when an invalid custom function-name is used', () => {
          const invalidCustomFunctionCallExpression = '#1a';
          const transformation = {
            a: {
              b: {
                c: invalidCustomFunctionCallExpression
              }
            }
          };
          expect(validateRequestTransformation(transformation)).toStrictEqual(validationErrorWith({
            parentPath: 'a.b.c',
            invalidValue: invalidCustomFunctionCallExpression,
            description: 'contains an invalid custom function expression'
          }));
        });
        test('returns a validation error when a custom function argument is invalid for request transformation', () => {
          const invalidCustomFunctionExpression = '#someFunction($.id)';
          const transformation = {
            a: {
              b: {
                c: invalidCustomFunctionExpression
              }
            }
          };
          expect(validateRequestTransformation(transformation)).toStrictEqual(validationErrorWith({
            parentPath: 'a.b.c',
            invalidValue: '$.id',
            description: 'must start with $[N] where N is an index'
          }));
        });
        describe('#constant function', () => {
          test('returns a validation error when passed value is not a valid json value', () => {
            const invalidCustomFunctionExpression = '#constant(not-json)';
            const transformation = {
              a: {
                b: {
                  c: invalidCustomFunctionExpression
                }
              }
            };
            expect(validateRequestTransformation(transformation)).toStrictEqual(validationErrorWith({
              parentPath: 'a.b.c',
              invalidValue: 'not-json',
              description: 'must be a valid json value'
            }));
          });
          test('allows passing non json-path arguments to the #constant function', () => {
            const transformation = {
              a: {
                b: {
                  c: '#constant("abc")'
                }
              }
            };
            expect(validateRequestTransformation(transformation)).toStrictEqual({
              isValid: true,
              validationErrors: []
            });
          });
        });
      });

      /* eslint-disable max-len */
      describe.each`
        description                                                  | transformationValue | expectedValidationMessage
        ${'does not start with $[N] where N is a numeric index'}     | ${'$[x].a.b.c'}     | ${'must start with $[N] where N is an index'}
        ${'is not a valid json-path'}                                | ${'@'}              | ${'must start with $[N] where N is an index'}
        ${'has several arguments referred to in the transformation'} | ${'$[0].$[1]'}      | ${'must have a single argument-index as the first path segment'}
        ${'refers to * in the path'}                                 | ${'$[0].a.b.*'}     | ${'cannot refer to the * operator'}
      `( /* eslint-enable max-len */
      'returns a validation error when a transformation value segment $description', ({
        transformationValue,
        expectedValidationMessage
      }) => {
        test('simple transformation', () => {
          expect(validateRequestTransformation(transformationValue)).toStrictEqual(validationErrorWith({
            parentPath: null,
            invalidValue: transformationValue,
            description: expectedValidationMessage
          }));
        });
        test('complex transformation', () => {
          const transformation = {
            a: {
              b: {
                c: transformationValue
              }
            }
          };
          expect(validateRequestTransformation(transformation)).toStrictEqual(validationErrorWith({
            parentPath: 'a.b.c',
            invalidValue: transformationValue,
            description: expectedValidationMessage
          }));
        });
      });
      describe('special fields', () => {
        describe.each(['id', 'createdDate', 'updatedDate'])('%s', specialField => {
          const transformationValue = `$[0].a.b.${specialField}`;
          // eslint-disable-next-line max-len
          const expectedValidationMessage = `cannot refer to ${specialField} field, consider using _${specialField} instead`;
          test('simple transformation', () => {
            expect(validateRequestTransformation(transformationValue)).toStrictEqual(validationErrorWith({
              parentPath: null,
              invalidValue: transformationValue,
              description: expectedValidationMessage
            }));
          });
          test('complex transformation', () => {
            const transformation = {
              a: {
                b: {
                  c: transformationValue
                }
              }
            };
            expect(validateRequestTransformation(transformation)).toStrictEqual(validationErrorWith({
              parentPath: 'a.b.c',
              invalidValue: transformationValue,
              description: expectedValidationMessage
            }));
          });
        });
      });
    });
  });
});
//# sourceMappingURL=validateRequestTransformation.spec.js.map