"use strict";

var _motionRuntimeTestContext = require("@wix/motion-runtime-test-context");
var _lodash = require("lodash");
var _ = require("../..");
const validateResponseTransformation = _.validation.validateResponseTransformation;
describe('validateResponseTransformation', () => {
  describe('valid transformations', () => {
    const validResults = {
      isValid: true,
      validationErrors: []
    };
    test('returns valid transformation response for a valid simple transformation', () => {
      const validTransformation = '$.a.b.c';
      expect(validateResponseTransformation(validTransformation)).toStrictEqual(validResults);
    });
    test('returns valid transformation response for a valid complex transformation', () => {
      const validTransformation = {
        aaa: '$.a.b.c'
      };
      expect(validateResponseTransformation(validTransformation)).toStrictEqual(validResults);
    });
  });
  describe('invalid transformations', () => {
    const parentKey = (0, _motionRuntimeTestContext.aString)();
    const validationErrorWith = ({
      parentPath,
      invalidValue,
      description
    }) => ({
      isValid: false,
      validationErrors: expect.arrayContaining([expect.objectContaining({
        parentPath,
        invalidValue,
        description
      })])
    });
    describe('invalid simple transformations', () => {
      test('returns a validation error when the transformation starts with an index argument', () => {
        const transformation = '$[0].a.b.c';
        expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
          parentPath: null,
          invalidValue: transformation,
          description: "must be a string starting with '$.'"
        }));
      });
    });
    describe('invalid complex-transformation keys', () => {
      test.each`
        description                        | transformationKey  | expectedValidationMessage
        ${'refers to an argument index'}   | ${'$[0]'}          | ${"must be a string starting with '$.'"}
        ${'refers to the root identifier'} | ${'$'}             | ${'cannot refer to $ in a transformation key'}
        ${'refers to a custom function'}   | ${'#someFunction'} | ${'cannot be a custom function call'}
      `('returns a validation error when a transformation value segment $description', ({
        transformationKey,
        expectedValidationMessage
      }) => {
        const transformation = {
          d: {
            e: {
              f: {
                [transformationKey]: '$.a.b.c'
              }
            }
          },
          '*': '$[1]'
        };
        expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
          parentPath: 'd.e.f',
          invalidValue: transformationKey,
          description: expectedValidationMessage
        }));
      });
    });
    describe('invalid transformations values', () => {
      describe('custom function expressions', () => {
        const invalidCustomFunctionName = '#1a';
        describe('invalid custom function-name is used', () => {
          test.each`
            description    | transformation                                    | expectedParentPath
            ${'top level'} | ${invalidCustomFunctionName}                      | ${null}
            ${'nested'}    | ${{
            a: {
              b: {
                c: invalidCustomFunctionName
              }
            }
          }} | ${'a.b.c'}
          `('returns a validation error for $description cases', ({
            expectedParentPath,
            transformation
          }) => {
            expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
              parentPath: expectedParentPath,
              invalidValue: invalidCustomFunctionName,
              description: 'contains an invalid custom function expression'
            }));
          });
        });
        describe('a custom function argument is invalid in response transformation', () => {
          const invalidCustomFunctionExpression = '#someFunction($[0])';
          test.each`
            description    | transformation                                          | expectedParentPath
            ${'top level'} | ${invalidCustomFunctionExpression}                      | ${null}
            ${'nested'}    | ${{
            a: {
              b: {
                c: invalidCustomFunctionExpression
              }
            }
          }} | ${'a.b.c'}
          `('returns a validation error for $description cases', ({
            expectedParentPath,
            transformation
          }) => {
            expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
              parentPath: expectedParentPath,
              invalidValue: '$[0]',
              description: "must be a string starting with '$.'"
            }));
          });
        });
        test('returns a validation error when an argument index is used', () => {
          const argumentExpression = '$[1].a.b.c.';
          const path = 'd.e.f';
          const transformation = (0, _lodash.set)({}, path, argumentExpression);
          expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
            parentPath: path,
            invalidValue: argumentExpression,
            description: "must be a string starting with '$.'"
          }));
        });
      });
      describe.each`
        description                  | transformationValue | expectedValidationMessage
        ${'does not start with $'}   | ${'a.b.c'}          | ${"must be a string starting with '$.'"}
        ${'refers to * in the path'} | ${'$.a.b.*'}        | ${'cannot refer to the * operator'}
      `('returns a validation error when a transformation value segment $description', ({
        transformationValue,
        expectedValidationMessage
      }) => {
        test('simple transformation', () => {
          expect(validateResponseTransformation(transformationValue)).toStrictEqual(validationErrorWith({
            parentPath: null,
            invalidValue: transformationValue,
            description: expectedValidationMessage
          }));
        });
        test('complex transformation', () => {
          const transformation = {
            d: {
              e: {
                f: transformationValue
              }
            }
          };
          expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
            parentPath: 'd.e.f',
            invalidValue: transformationValue,
            description: expectedValidationMessage
          }));
        });
      });
      describe('special fields', () => {
        describe.each(['_id', '_createdDate', '_updatedDate'])('%s', specialField => {
          const expectedValidationMessage = `cannot refer to the ${specialField} field`;
          test('returns a validation error when a transformation value segment $description', () => {
            const transformation = {
              d: {
                e: {
                  f: {
                    [specialField]: '$.a.b.c'
                  }
                }
              },
              '*': '$[1]'
            };
            expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
              parentPath: 'd.e.f',
              invalidValue: specialField,
              description: expectedValidationMessage
            }));
          });
          describe('simple transformation', () => {
            test(`returns a validation error when a segment refers to the special field ${specialField}`, () => {
              const transformationValue = `$.a.b.${specialField}`;
              expect(validateResponseTransformation(transformationValue)).toStrictEqual(validationErrorWith({
                parentPath: null,
                invalidValue: transformationValue,
                description: expectedValidationMessage
              }));
            });
          });
          test('complex transformation', () => {
            const transformationValue = `$.a.b.${specialField}`;
            const transformation = {
              d: {
                e: {
                  f: transformationValue
                }
              }
            };
            expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
              parentPath: 'd.e.f',
              invalidValue: transformationValue,
              description: expectedValidationMessage
            }));
          });
        });
      });
    });
    describe('omit transformation', () => {
      describe('invalid @source', () => {
        const invalidSourceValue = 'a.b.c';
        const invalidSourceTransformation = {
          '@source': invalidSourceValue,
          '@omit': (0, _lodash.times)(2, () => (0, _motionRuntimeTestContext.aString)())
        };
        test.each`
          description    | invalidTransformation                           | expectedParentPath
          ${'top level'} | ${invalidSourceTransformation}                  | ${'@source'}
          ${'nested'}    | ${{
          [parentKey]: invalidSourceTransformation
        }} | ${`${parentKey}.@source`}
        `('returns a validation error when the @source value is invalid', ({
          invalidTransformation,
          expectedParentPath
        }) => {
          expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
            parentPath: expectedParentPath,
            invalidValue: invalidSourceValue,
            description: "must be a string starting with '$.'"
          }));
        });
      });
      describe('invalid @omit', () => {
        const transformationWithOmitValue = value => ({
          '@source': '$.a.b.c',
          '@omit': value
        });
        const nonArray = (0, _motionRuntimeTestContext.aString)();
        const nonStringArray = (0, _lodash.times)(2, () => (0, _motionRuntimeTestContext.aNumber)());
        const arrayWithInvalidPaths = ['a.b.c', (0, _motionRuntimeTestContext.aString)()];
        describe.each`
          description    | invalidTransformation                                     | expectedParentPath
          ${'top level'} | ${transformationWithOmitValue(nonArray)}                  | ${'@omit'}
          ${'nested'}    | ${{
          [parentKey]: transformationWithOmitValue(nonArray)
        }} | ${`${parentKey}.@omit`}
        `('@omit is not an array', ({
          description,
          invalidTransformation,
          expectedParentPath
        }) => {
          test(`returns a validation error for invalid ${description} transformation`, () => {
            expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
              parentPath: expectedParentPath,
              invalidValue: nonArray,
              description: 'must be an array of strings'
            }));
          });
        });
        describe.each`
          description    | invalidTransformation                                           | expectedParentPath
          ${'top level'} | ${transformationWithOmitValue(nonStringArray)}                  | ${'@omit'}
          ${'nested'}    | ${{
          [parentKey]: transformationWithOmitValue(nonStringArray)
        }} | ${`${parentKey}.@omit`}
        `('@omit is an array of non-strings', ({
          description,
          invalidTransformation,
          expectedParentPath
        }) => {
          test(`returns a validation error for invalid ${description} transformation`, () => {
            expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
              parentPath: expectedParentPath,
              invalidValue: nonStringArray,
              description: 'must be an array of strings'
            }));
          });
        });

        /* eslint-disable max-len */
        describe.each`
          description    | invalidTransformation                                                  | expectedParentPath
          ${'top level'} | ${transformationWithOmitValue(arrayWithInvalidPaths)}                  | ${'@omit'}
          ${'nested'}    | ${{
          [parentKey]: transformationWithOmitValue(arrayWithInvalidPaths)
        }} | ${`${parentKey}.@omit`}
        `('@omit is an array of invalid string paths', ({
          description,
          invalidTransformation,
          expectedParentPath
        }) => {
          /* eslint-enable max-len */
          test(`returns a validation error for invalid ${description} transformation`, () => {
            expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
              parentPath: expectedParentPath,
              invalidValue: arrayWithInvalidPaths,
              description: 'must contain non-nested paths only'
            }));
          });
        });
      });
    });
    describe('array-item transformation', () => {
      const validValue = '$.d.e.f';
      const invalidPathTransformationWith = invalidPathValue => ({
        '@path': invalidPathValue,
        '@itemTransformation': validValue
      });
      describe.each`
        invalidValue                                            | description
        ${'$[0].should.fail'}                                   | ${'invalid path value'}
        ${(0, _motionRuntimeTestContext.aRandomItemFrom)([(0, _motionRuntimeTestContext.aBoolean)(), (0, _motionRuntimeTestContext.aNumber)(), (0, _motionRuntimeTestContext.anObject)()])} | ${'invalid path type'}
      `('$description', ({
        invalidValue
      }) => {
        test.each`
          description    | invalidTransformation                                           | expectedParentPath
          ${'top-level'} | ${invalidPathTransformationWith(invalidValue)}                  | ${'@path'}
          ${'nested'}    | ${{
          [parentKey]: invalidPathTransformationWith(invalidValue)
        }} | ${`${parentKey}.@path`}
        `('returns a validation error when the @path value is invalid for $description transformation', ({
          invalidTransformation,
          expectedParentPath
        }) => {
          expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
            parentPath: expectedParentPath,
            invalidValue,
            description: "must be a string starting with '$.'"
          }));
        });
      });
      describe('invalid @itemTransformation', () => {
        const invalidValue = '$[0].should.fail';
        const invalidPathTransformation = {
          '@path': validValue,
          '@itemTransformation': invalidValue
        };
        test.each`
          description    | invalidTransformation                         | expectedParentPath
          ${'top-level'} | ${invalidPathTransformation}                  | ${'@itemTransformation'}
          ${'nested'}    | ${{
          [parentKey]: invalidPathTransformation
        }} | ${`${parentKey}.@itemTransformation`}
        `('returns a validation error when the @itemTransformation value is invalid for $description transformation', ({
          invalidTransformation,
          expectedParentPath
        }) => {
          expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
            parentPath: expectedParentPath,
            invalidValue,
            description: "must be a string starting with '$.'"
          }));
        });
      });
    });
  });
});
//# sourceMappingURL=validateResponseTransformation.spec.js.map