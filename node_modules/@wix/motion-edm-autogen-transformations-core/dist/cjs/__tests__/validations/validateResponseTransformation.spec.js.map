{"version":3,"names":["_motionRuntimeTestContext","require","_lodash","_","validateResponseTransformation","validation","describe","validResults","isValid","validationErrors","test","validTransformation","expect","toStrictEqual","aaa","parentKey","aString","validationErrorWith","parentPath","invalidValue","description","arrayContaining","objectContaining","transformation","each","transformationKey","expectedValidationMessage","d","e","f","invalidCustomFunctionName","a","b","c","expectedParentPath","invalidCustomFunctionExpression","argumentExpression","path","set","transformationValue","specialField","invalidSourceValue","invalidSourceTransformation","times","invalidTransformation","transformationWithOmitValue","value","nonArray","nonStringArray","aNumber","arrayWithInvalidPaths","validValue","invalidPathTransformationWith","invalidPathValue","aRandomItemFrom","aBoolean","anObject","invalidPathTransformation"],"sources":["../../../../src/__tests__/validations/validateResponseTransformation.spec.ts"],"sourcesContent":["import {\n  aBoolean,\n  anObject,\n  aNumber,\n  aRandomItemFrom,\n  aString,\n} from '@wix/motion-runtime-test-context';\nimport { set, times } from 'lodash';\n\nimport { validation } from '../..';\n\nconst { validateResponseTransformation } = validation;\n\ndescribe('validateResponseTransformation', () => {\n  describe('valid transformations', () => {\n    const validResults = { isValid: true, validationErrors: [] };\n\n    test('returns valid transformation response for a valid simple transformation', () => {\n      const validTransformation = '$.a.b.c';\n\n      expect(validateResponseTransformation(validTransformation)).toStrictEqual(\n        validResults,\n      );\n    });\n\n    test('returns valid transformation response for a valid complex transformation', () => {\n      const validTransformation = { aaa: '$.a.b.c' };\n\n      expect(validateResponseTransformation(validTransformation)).toStrictEqual(\n        validResults,\n      );\n    });\n  });\n\n  describe('invalid transformations', () => {\n    const parentKey = aString();\n\n    const validationErrorWith = ({\n      parentPath,\n      invalidValue,\n      description,\n    }) => ({\n      isValid: false,\n      validationErrors: expect.arrayContaining([\n        expect.objectContaining({\n          parentPath,\n          invalidValue,\n          description,\n        }),\n      ]),\n    });\n\n    describe('invalid simple transformations', () => {\n      test('returns a validation error when the transformation starts with an index argument', () => {\n        const transformation = '$[0].a.b.c';\n\n        expect(validateResponseTransformation(transformation)).toStrictEqual(\n          validationErrorWith({\n            parentPath: null,\n            invalidValue: transformation,\n            description: \"must be a string starting with '$.'\",\n          }),\n        );\n      });\n    });\n\n    describe('invalid complex-transformation keys', () => {\n      test.each`\n        description                        | transformationKey  | expectedValidationMessage\n        ${'refers to an argument index'}   | ${'$[0]'}          | ${\"must be a string starting with '$.'\"}\n        ${'refers to the root identifier'} | ${'$'}             | ${'cannot refer to $ in a transformation key'}\n        ${'refers to a custom function'}   | ${'#someFunction'} | ${'cannot be a custom function call'}\n      `(\n        'returns a validation error when a transformation value segment $description',\n        ({ transformationKey, expectedValidationMessage }) => {\n          const transformation = {\n            d: { e: { f: { [transformationKey]: '$.a.b.c' } } },\n            '*': '$[1]',\n          };\n\n          expect(validateResponseTransformation(transformation)).toStrictEqual(\n            validationErrorWith({\n              parentPath: 'd.e.f',\n              invalidValue: transformationKey,\n              description: expectedValidationMessage,\n            }),\n          );\n        },\n      );\n    });\n\n    describe('invalid transformations values', () => {\n      describe('custom function expressions', () => {\n        const invalidCustomFunctionName = '#1a';\n\n        describe('invalid custom function-name is used', () => {\n          test.each`\n            description    | transformation                                    | expectedParentPath\n            ${'top level'} | ${invalidCustomFunctionName}                      | ${null}\n            ${'nested'}    | ${{ a: { b: { c: invalidCustomFunctionName } } }} | ${'a.b.c'}\n          `(\n            'returns a validation error for $description cases',\n            ({ expectedParentPath, transformation }) => {\n              expect(\n                validateResponseTransformation(transformation),\n              ).toStrictEqual(\n                validationErrorWith({\n                  parentPath: expectedParentPath,\n                  invalidValue: invalidCustomFunctionName,\n                  description: 'contains an invalid custom function expression',\n                }),\n              );\n            },\n          );\n        });\n\n        describe('a custom function argument is invalid in response transformation', () => {\n          const invalidCustomFunctionExpression = '#someFunction($[0])';\n\n          test.each`\n            description    | transformation                                          | expectedParentPath\n            ${'top level'} | ${invalidCustomFunctionExpression}                      | ${null}\n            ${'nested'}    | ${{ a: { b: { c: invalidCustomFunctionExpression } } }} | ${'a.b.c'}\n          `(\n            'returns a validation error for $description cases',\n            ({ expectedParentPath, transformation }) => {\n              expect(\n                validateResponseTransformation(transformation),\n              ).toStrictEqual(\n                validationErrorWith({\n                  parentPath: expectedParentPath,\n                  invalidValue: '$[0]',\n                  description: \"must be a string starting with '$.'\",\n                }),\n              );\n            },\n          );\n        });\n\n        test('returns a validation error when an argument index is used', () => {\n          const argumentExpression = '$[1].a.b.c.';\n          const path = 'd.e.f';\n          const transformation = set({}, path, argumentExpression);\n\n          expect(validateResponseTransformation(transformation)).toStrictEqual(\n            validationErrorWith({\n              parentPath: path,\n              invalidValue: argumentExpression,\n              description: \"must be a string starting with '$.'\",\n            }),\n          );\n        });\n      });\n\n      describe.each`\n        description                  | transformationValue | expectedValidationMessage\n        ${'does not start with $'}   | ${'a.b.c'}          | ${\"must be a string starting with '$.'\"}\n        ${'refers to * in the path'} | ${'$.a.b.*'}        | ${'cannot refer to the * operator'}\n      `(\n        'returns a validation error when a transformation value segment $description',\n        ({ transformationValue, expectedValidationMessage }) => {\n          test('simple transformation', () => {\n            expect(\n              validateResponseTransformation(transformationValue),\n            ).toStrictEqual(\n              validationErrorWith({\n                parentPath: null,\n                invalidValue: transformationValue,\n                description: expectedValidationMessage,\n              }),\n            );\n          });\n\n          test('complex transformation', () => {\n            const transformation = { d: { e: { f: transformationValue } } };\n\n            expect(\n              validateResponseTransformation(transformation),\n            ).toStrictEqual(\n              validationErrorWith({\n                parentPath: 'd.e.f',\n                invalidValue: transformationValue,\n                description: expectedValidationMessage,\n              }),\n            );\n          });\n        },\n      );\n\n      describe('special fields', () => {\n        describe.each(['_id', '_createdDate', '_updatedDate'])(\n          '%s',\n          (specialField) => {\n            const expectedValidationMessage = `cannot refer to the ${specialField} field`;\n\n            test('returns a validation error when a transformation value segment $description', () => {\n              const transformation = {\n                d: { e: { f: { [specialField]: '$.a.b.c' } } },\n                '*': '$[1]',\n              };\n\n              expect(\n                validateResponseTransformation(transformation),\n              ).toStrictEqual(\n                validationErrorWith({\n                  parentPath: 'd.e.f',\n                  invalidValue: specialField,\n                  description: expectedValidationMessage,\n                }),\n              );\n            });\n\n            describe('simple transformation', () => {\n              test(`returns a validation error when a segment refers to the special field ${specialField}`, () => {\n                const transformationValue = `$.a.b.${specialField}`;\n\n                expect(\n                  validateResponseTransformation(transformationValue),\n                ).toStrictEqual(\n                  validationErrorWith({\n                    parentPath: null,\n                    invalidValue: transformationValue,\n                    description: expectedValidationMessage,\n                  }),\n                );\n              });\n            });\n\n            test('complex transformation', () => {\n              const transformationValue = `$.a.b.${specialField}`;\n              const transformation = { d: { e: { f: transformationValue } } };\n\n              expect(\n                validateResponseTransformation(transformation),\n              ).toStrictEqual(\n                validationErrorWith({\n                  parentPath: 'd.e.f',\n                  invalidValue: transformationValue,\n                  description: expectedValidationMessage,\n                }),\n              );\n            });\n          },\n        );\n      });\n    });\n\n    describe('omit transformation', () => {\n      describe('invalid @source', () => {\n        const invalidSourceValue = 'a.b.c';\n        const invalidSourceTransformation = {\n          '@source': invalidSourceValue,\n          '@omit': times(2, () => aString()),\n        };\n\n        test.each`\n          description    | invalidTransformation                           | expectedParentPath\n          ${'top level'} | ${invalidSourceTransformation}                  | ${'@source'}\n          ${'nested'}    | ${{ [parentKey]: invalidSourceTransformation }} | ${`${parentKey}.@source`}\n        `(\n          'returns a validation error when the @source value is invalid',\n          ({ invalidTransformation, expectedParentPath }) => {\n            expect(\n              validateResponseTransformation(invalidTransformation),\n            ).toStrictEqual(\n              validationErrorWith({\n                parentPath: expectedParentPath,\n                invalidValue: invalidSourceValue,\n                description: \"must be a string starting with '$.'\",\n              }),\n            );\n          },\n        );\n      });\n\n      describe('invalid @omit', () => {\n        const transformationWithOmitValue = (value) => ({\n          '@source': '$.a.b.c',\n          '@omit': value,\n        });\n\n        const nonArray = aString();\n        const nonStringArray = times(2, () => aNumber());\n        const arrayWithInvalidPaths = ['a.b.c', aString()];\n\n        describe.each`\n          description    | invalidTransformation                                     | expectedParentPath\n          ${'top level'} | ${transformationWithOmitValue(nonArray)}                  | ${'@omit'}\n          ${'nested'}    | ${{ [parentKey]: transformationWithOmitValue(nonArray) }} | ${`${parentKey}.@omit`}\n        `(\n          '@omit is not an array',\n          ({ description, invalidTransformation, expectedParentPath }) => {\n            test(`returns a validation error for invalid ${description} transformation`, () => {\n              expect(\n                validateResponseTransformation(invalidTransformation),\n              ).toStrictEqual(\n                validationErrorWith({\n                  parentPath: expectedParentPath,\n                  invalidValue: nonArray,\n                  description: 'must be an array of strings',\n                }),\n              );\n            });\n          },\n        );\n\n        describe.each`\n          description    | invalidTransformation                                           | expectedParentPath\n          ${'top level'} | ${transformationWithOmitValue(nonStringArray)}                  | ${'@omit'}\n          ${'nested'}    | ${{ [parentKey]: transformationWithOmitValue(nonStringArray) }} | ${`${parentKey}.@omit`}\n        `(\n          '@omit is an array of non-strings',\n          ({ description, invalidTransformation, expectedParentPath }) => {\n            test(`returns a validation error for invalid ${description} transformation`, () => {\n              expect(\n                validateResponseTransformation(invalidTransformation),\n              ).toStrictEqual(\n                validationErrorWith({\n                  parentPath: expectedParentPath,\n                  invalidValue: nonStringArray,\n                  description: 'must be an array of strings',\n                }),\n              );\n            });\n          },\n        );\n\n        /* eslint-disable max-len */\n        describe.each`\n          description    | invalidTransformation                                                  | expectedParentPath\n          ${'top level'} | ${transformationWithOmitValue(arrayWithInvalidPaths)}                  | ${'@omit'}\n          ${'nested'}    | ${{ [parentKey]: transformationWithOmitValue(arrayWithInvalidPaths) }} | ${`${parentKey}.@omit`}\n        `(\n          '@omit is an array of invalid string paths',\n          ({ description, invalidTransformation, expectedParentPath }) => {\n            /* eslint-enable max-len */\n            test(`returns a validation error for invalid ${description} transformation`, () => {\n              expect(\n                validateResponseTransformation(invalidTransformation),\n              ).toStrictEqual(\n                validationErrorWith({\n                  parentPath: expectedParentPath,\n                  invalidValue: arrayWithInvalidPaths,\n                  description: 'must contain non-nested paths only',\n                }),\n              );\n            });\n          },\n        );\n      });\n    });\n\n    describe('array-item transformation', () => {\n      const validValue = '$.d.e.f';\n\n      const invalidPathTransformationWith = (invalidPathValue) => ({\n        '@path': invalidPathValue,\n        '@itemTransformation': validValue,\n      });\n\n      describe.each`\n        invalidValue                                            | description\n        ${'$[0].should.fail'}                                   | ${'invalid path value'}\n        ${aRandomItemFrom([aBoolean(), aNumber(), anObject()])} | ${'invalid path type'}\n      `('$description', ({ invalidValue }) => {\n        test.each`\n          description    | invalidTransformation                                           | expectedParentPath\n          ${'top-level'} | ${invalidPathTransformationWith(invalidValue)}                  | ${'@path'}\n          ${'nested'}    | ${{ [parentKey]: invalidPathTransformationWith(invalidValue) }} | ${`${parentKey}.@path`}\n        `(\n          'returns a validation error when the @path value is invalid for $description transformation',\n          ({ invalidTransformation, expectedParentPath }) => {\n            expect(\n              validateResponseTransformation(invalidTransformation),\n            ).toStrictEqual(\n              validationErrorWith({\n                parentPath: expectedParentPath,\n                invalidValue,\n                description: \"must be a string starting with '$.'\",\n              }),\n            );\n          },\n        );\n      });\n\n      describe('invalid @itemTransformation', () => {\n        const invalidValue = '$[0].should.fail';\n        const invalidPathTransformation = {\n          '@path': validValue,\n          '@itemTransformation': invalidValue,\n        };\n\n        test.each`\n          description    | invalidTransformation                         | expectedParentPath\n          ${'top-level'} | ${invalidPathTransformation}                  | ${'@itemTransformation'}\n          ${'nested'}    | ${{ [parentKey]: invalidPathTransformation }} | ${`${parentKey}.@itemTransformation`}\n        `(\n          'returns a validation error when the @itemTransformation value is invalid for $description transformation',\n          ({ invalidTransformation, expectedParentPath }) => {\n            expect(\n              validateResponseTransformation(invalidTransformation),\n            ).toStrictEqual(\n              validationErrorWith({\n                parentPath: expectedParentPath,\n                invalidValue,\n                description: \"must be a string starting with '$.'\",\n              }),\n            );\n          },\n        );\n      });\n    });\n  });\n});\n"],"mappings":"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"}