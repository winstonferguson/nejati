import { __makeTemplateObject } from "tslib";
import { aBoolean, anObject, aNumber, aRandomItemFrom, aString, } from '@wix/motion-runtime-test-context';
import { set, times } from 'lodash';
import { validation } from '../..';
var validateResponseTransformation = validation.validateResponseTransformation;
describe('validateResponseTransformation', function () {
    describe('valid transformations', function () {
        var validResults = { isValid: true, validationErrors: [] };
        test('returns valid transformation response for a valid simple transformation', function () {
            var validTransformation = '$.a.b.c';
            expect(validateResponseTransformation(validTransformation)).toStrictEqual(validResults);
        });
        test('returns valid transformation response for a valid complex transformation', function () {
            var validTransformation = { aaa: '$.a.b.c' };
            expect(validateResponseTransformation(validTransformation)).toStrictEqual(validResults);
        });
    });
    describe('invalid transformations', function () {
        var parentKey = aString();
        var validationErrorWith = function (_a) {
            var parentPath = _a.parentPath, invalidValue = _a.invalidValue, description = _a.description;
            return ({
                isValid: false,
                validationErrors: expect.arrayContaining([
                    expect.objectContaining({
                        parentPath: parentPath,
                        invalidValue: invalidValue,
                        description: description,
                    }),
                ]),
            });
        };
        describe('invalid simple transformations', function () {
            test('returns a validation error when the transformation starts with an index argument', function () {
                var transformation = '$[0].a.b.c';
                expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
                    parentPath: null,
                    invalidValue: transformation,
                    description: "must be a string starting with '$.'",
                }));
            });
        });
        describe('invalid complex-transformation keys', function () {
            test.each(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n        description                        | transformationKey  | expectedValidationMessage\n        ", "   | ", "          | ", "\n        ", " | ", "             | ", "\n        ", "   | ", " | ", "\n      "], ["\n        description                        | transformationKey  | expectedValidationMessage\n        ", "   | ", "          | ", "\n        ", " | ", "             | ", "\n        ", "   | ", " | ", "\n      "])), 'refers to an argument index', '$[0]', "must be a string starting with '$.'", 'refers to the root identifier', '$', 'cannot refer to $ in a transformation key', 'refers to a custom function', '#someFunction', 'cannot be a custom function call')('returns a validation error when a transformation value segment $description', function (_a) {
                var _b;
                var transformationKey = _a.transformationKey, expectedValidationMessage = _a.expectedValidationMessage;
                var transformation = {
                    d: { e: { f: (_b = {}, _b[transformationKey] = '$.a.b.c', _b) } },
                    '*': '$[1]',
                };
                expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
                    parentPath: 'd.e.f',
                    invalidValue: transformationKey,
                    description: expectedValidationMessage,
                }));
            });
        });
        describe('invalid transformations values', function () {
            describe('custom function expressions', function () {
                var invalidCustomFunctionName = '#1a';
                describe('invalid custom function-name is used', function () {
                    test.each(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n            description    | transformation                                    | expectedParentPath\n            ", " | ", "                      | ", "\n            ", "    | ", " | ", "\n          "], ["\n            description    | transformation                                    | expectedParentPath\n            ", " | ", "                      | ", "\n            ", "    | ", " | ", "\n          "])), 'top level', invalidCustomFunctionName, null, 'nested', { a: { b: { c: invalidCustomFunctionName } } }, 'a.b.c')('returns a validation error for $description cases', function (_a) {
                        var expectedParentPath = _a.expectedParentPath, transformation = _a.transformation;
                        expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
                            parentPath: expectedParentPath,
                            invalidValue: invalidCustomFunctionName,
                            description: 'contains an invalid custom function expression',
                        }));
                    });
                });
                describe('a custom function argument is invalid in response transformation', function () {
                    var invalidCustomFunctionExpression = '#someFunction($[0])';
                    test.each(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n            description    | transformation                                          | expectedParentPath\n            ", " | ", "                      | ", "\n            ", "    | ", " | ", "\n          "], ["\n            description    | transformation                                          | expectedParentPath\n            ", " | ", "                      | ", "\n            ", "    | ", " | ", "\n          "])), 'top level', invalidCustomFunctionExpression, null, 'nested', { a: { b: { c: invalidCustomFunctionExpression } } }, 'a.b.c')('returns a validation error for $description cases', function (_a) {
                        var expectedParentPath = _a.expectedParentPath, transformation = _a.transformation;
                        expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
                            parentPath: expectedParentPath,
                            invalidValue: '$[0]',
                            description: "must be a string starting with '$.'",
                        }));
                    });
                });
                test('returns a validation error when an argument index is used', function () {
                    var argumentExpression = '$[1].a.b.c.';
                    var path = 'd.e.f';
                    var transformation = set({}, path, argumentExpression);
                    expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
                        parentPath: path,
                        invalidValue: argumentExpression,
                        description: "must be a string starting with '$.'",
                    }));
                });
            });
            describe.each(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n        description                  | transformationValue | expectedValidationMessage\n        ", "   | ", "          | ", "\n        ", " | ", "        | ", "\n      "], ["\n        description                  | transformationValue | expectedValidationMessage\n        ", "   | ", "          | ", "\n        ", " | ", "        | ", "\n      "])), 'does not start with $', 'a.b.c', "must be a string starting with '$.'", 'refers to * in the path', '$.a.b.*', 'cannot refer to the * operator')('returns a validation error when a transformation value segment $description', function (_a) {
                var transformationValue = _a.transformationValue, expectedValidationMessage = _a.expectedValidationMessage;
                test('simple transformation', function () {
                    expect(validateResponseTransformation(transformationValue)).toStrictEqual(validationErrorWith({
                        parentPath: null,
                        invalidValue: transformationValue,
                        description: expectedValidationMessage,
                    }));
                });
                test('complex transformation', function () {
                    var transformation = { d: { e: { f: transformationValue } } };
                    expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
                        parentPath: 'd.e.f',
                        invalidValue: transformationValue,
                        description: expectedValidationMessage,
                    }));
                });
            });
            describe('special fields', function () {
                describe.each(['_id', '_createdDate', '_updatedDate'])('%s', function (specialField) {
                    var expectedValidationMessage = "cannot refer to the ".concat(specialField, " field");
                    test('returns a validation error when a transformation value segment $description', function () {
                        var _a;
                        var transformation = {
                            d: { e: { f: (_a = {}, _a[specialField] = '$.a.b.c', _a) } },
                            '*': '$[1]',
                        };
                        expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
                            parentPath: 'd.e.f',
                            invalidValue: specialField,
                            description: expectedValidationMessage,
                        }));
                    });
                    describe('simple transformation', function () {
                        test("returns a validation error when a segment refers to the special field ".concat(specialField), function () {
                            var transformationValue = "$.a.b.".concat(specialField);
                            expect(validateResponseTransformation(transformationValue)).toStrictEqual(validationErrorWith({
                                parentPath: null,
                                invalidValue: transformationValue,
                                description: expectedValidationMessage,
                            }));
                        });
                    });
                    test('complex transformation', function () {
                        var transformationValue = "$.a.b.".concat(specialField);
                        var transformation = { d: { e: { f: transformationValue } } };
                        expect(validateResponseTransformation(transformation)).toStrictEqual(validationErrorWith({
                            parentPath: 'd.e.f',
                            invalidValue: transformationValue,
                            description: expectedValidationMessage,
                        }));
                    });
                });
            });
        });
        describe('omit transformation', function () {
            describe('invalid @source', function () {
                var _a;
                var invalidSourceValue = 'a.b.c';
                var invalidSourceTransformation = {
                    '@source': invalidSourceValue,
                    '@omit': times(2, function () { return aString(); }),
                };
                test.each(templateObject_5 || (templateObject_5 = __makeTemplateObject(["\n          description    | invalidTransformation                           | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "], ["\n          description    | invalidTransformation                           | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "])), 'top level', invalidSourceTransformation, '@source', 'nested', (_a = {}, _a[parentKey] = invalidSourceTransformation, _a), "".concat(parentKey, ".@source"))('returns a validation error when the @source value is invalid', function (_a) {
                    var invalidTransformation = _a.invalidTransformation, expectedParentPath = _a.expectedParentPath;
                    expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
                        parentPath: expectedParentPath,
                        invalidValue: invalidSourceValue,
                        description: "must be a string starting with '$.'",
                    }));
                });
            });
            describe('invalid @omit', function () {
                var _a, _b, _c;
                var transformationWithOmitValue = function (value) { return ({
                    '@source': '$.a.b.c',
                    '@omit': value,
                }); };
                var nonArray = aString();
                var nonStringArray = times(2, function () { return aNumber(); });
                var arrayWithInvalidPaths = ['a.b.c', aString()];
                describe.each(templateObject_6 || (templateObject_6 = __makeTemplateObject(["\n          description    | invalidTransformation                                     | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "], ["\n          description    | invalidTransformation                                     | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "])), 'top level', transformationWithOmitValue(nonArray), '@omit', 'nested', (_a = {}, _a[parentKey] = transformationWithOmitValue(nonArray), _a), "".concat(parentKey, ".@omit"))('@omit is not an array', function (_a) {
                    var description = _a.description, invalidTransformation = _a.invalidTransformation, expectedParentPath = _a.expectedParentPath;
                    test("returns a validation error for invalid ".concat(description, " transformation"), function () {
                        expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
                            parentPath: expectedParentPath,
                            invalidValue: nonArray,
                            description: 'must be an array of strings',
                        }));
                    });
                });
                describe.each(templateObject_7 || (templateObject_7 = __makeTemplateObject(["\n          description    | invalidTransformation                                           | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "], ["\n          description    | invalidTransformation                                           | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "])), 'top level', transformationWithOmitValue(nonStringArray), '@omit', 'nested', (_b = {}, _b[parentKey] = transformationWithOmitValue(nonStringArray), _b), "".concat(parentKey, ".@omit"))('@omit is an array of non-strings', function (_a) {
                    var description = _a.description, invalidTransformation = _a.invalidTransformation, expectedParentPath = _a.expectedParentPath;
                    test("returns a validation error for invalid ".concat(description, " transformation"), function () {
                        expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
                            parentPath: expectedParentPath,
                            invalidValue: nonStringArray,
                            description: 'must be an array of strings',
                        }));
                    });
                });
                /* eslint-disable max-len */
                describe.each(templateObject_8 || (templateObject_8 = __makeTemplateObject(["\n          description    | invalidTransformation                                                  | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "], ["\n          description    | invalidTransformation                                                  | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "])), 'top level', transformationWithOmitValue(arrayWithInvalidPaths), '@omit', 'nested', (_c = {}, _c[parentKey] = transformationWithOmitValue(arrayWithInvalidPaths), _c), "".concat(parentKey, ".@omit"))('@omit is an array of invalid string paths', function (_a) {
                    var description = _a.description, invalidTransformation = _a.invalidTransformation, expectedParentPath = _a.expectedParentPath;
                    /* eslint-enable max-len */
                    test("returns a validation error for invalid ".concat(description, " transformation"), function () {
                        expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
                            parentPath: expectedParentPath,
                            invalidValue: arrayWithInvalidPaths,
                            description: 'must contain non-nested paths only',
                        }));
                    });
                });
            });
        });
        describe('array-item transformation', function () {
            var validValue = '$.d.e.f';
            var invalidPathTransformationWith = function (invalidPathValue) { return ({
                '@path': invalidPathValue,
                '@itemTransformation': validValue,
            }); };
            describe.each(templateObject_9 || (templateObject_9 = __makeTemplateObject(["\n        invalidValue                                            | description\n        ", "                                   | ", "\n        ", " | ", "\n      "], ["\n        invalidValue                                            | description\n        ", "                                   | ", "\n        ", " | ", "\n      "])), '$[0].should.fail', 'invalid path value', aRandomItemFrom([aBoolean(), aNumber(), anObject()]), 'invalid path type')('$description', function (_a) {
                var _b;
                var invalidValue = _a.invalidValue;
                test.each(templateObject_10 || (templateObject_10 = __makeTemplateObject(["\n          description    | invalidTransformation                                           | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "], ["\n          description    | invalidTransformation                                           | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "])), 'top-level', invalidPathTransformationWith(invalidValue), '@path', 'nested', (_b = {}, _b[parentKey] = invalidPathTransformationWith(invalidValue), _b), "".concat(parentKey, ".@path"))('returns a validation error when the @path value is invalid for $description transformation', function (_a) {
                    var invalidTransformation = _a.invalidTransformation, expectedParentPath = _a.expectedParentPath;
                    expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
                        parentPath: expectedParentPath,
                        invalidValue: invalidValue,
                        description: "must be a string starting with '$.'",
                    }));
                });
            });
            describe('invalid @itemTransformation', function () {
                var _a;
                var invalidValue = '$[0].should.fail';
                var invalidPathTransformation = {
                    '@path': validValue,
                    '@itemTransformation': invalidValue,
                };
                test.each(templateObject_11 || (templateObject_11 = __makeTemplateObject(["\n          description    | invalidTransformation                         | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "], ["\n          description    | invalidTransformation                         | expectedParentPath\n          ", " | ", "                  | ", "\n          ", "    | ", " | ", "\n        "])), 'top-level', invalidPathTransformation, '@itemTransformation', 'nested', (_a = {}, _a[parentKey] = invalidPathTransformation, _a), "".concat(parentKey, ".@itemTransformation"))('returns a validation error when the @itemTransformation value is invalid for $description transformation', function (_a) {
                    var invalidTransformation = _a.invalidTransformation, expectedParentPath = _a.expectedParentPath;
                    expect(validateResponseTransformation(invalidTransformation)).toStrictEqual(validationErrorWith({
                        parentPath: expectedParentPath,
                        invalidValue: invalidValue,
                        description: "must be a string starting with '$.'",
                    }));
                });
            });
        });
    });
});
var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6, templateObject_7, templateObject_8, templateObject_9, templateObject_10, templateObject_11;
//# sourceMappingURL=validateResponseTransformation.spec.js.map