import { __assign, __makeTemplateObject } from "tslib";
import { anObject, aString } from '@wix/motion-runtime-test-context';
import { set, times } from 'lodash';
import { reduceTransformation } from '../lib/transformations/reduceTransformation';
describe('reduceTransformation', function () {
    describe('simple transformations', function () {
        var visitorCallbackResult = aString();
        test('traverses a simple transformation', function () {
            var visitorCallback = jest
                .fn()
                .mockReturnValueOnce(visitorCallbackResult);
            var transformation = '$.a.b.c';
            var result = reduceTransformation(transformation, {
                visitors: {
                    TopLevelSimpleTransformationExpression: visitorCallback,
                },
            });
            expect(visitorCallback).toHaveBeenCalledTimes(1);
            expect(visitorCallback).toHaveBeenCalledWith('$.a.b.c');
            expect(result).toStrictEqual(visitorCallbackResult);
        });
        describe('custom-functions', function () {
            test('traverses a valid custom-function expression', function () {
                var visitorCallback = jest
                    .fn()
                    .mockReturnValueOnce(visitorCallbackResult);
                var transformation = '#someCustomFunction($.a.b.c,someOtherArg)';
                var result = reduceTransformation(transformation, {
                    visitors: {
                        TopLevelCustomFunctionExpression: visitorCallback,
                    },
                });
                expect(visitorCallback).toHaveBeenCalledTimes(1);
                expect(visitorCallback).toHaveBeenCalledWith('someCustomFunction', ['$.a.b.c', 'someOtherArg'], transformation);
                expect(result).toStrictEqual(visitorCallbackResult);
            });
            test('does not fail for invalid custom-function expression', function () {
                var visitorCallback = jest
                    .fn()
                    .mockReturnValueOnce(visitorCallbackResult);
                var transformationWithInvalidCustomFunctionExpression = '#($.a.b.c)';
                var result = reduceTransformation(transformationWithInvalidCustomFunctionExpression, {
                    visitors: {
                        TopLevelCustomFunctionExpression: visitorCallback,
                    },
                });
                expect(visitorCallback).toHaveBeenCalledTimes(1);
                expect(visitorCallback).toHaveBeenCalledWith(null, null, transformationWithInvalidCustomFunctionExpression);
                expect(result).toStrictEqual(visitorCallbackResult);
            });
        });
        // TODO: replace with returning the invalid value, for constant-transformation
        test('invokes the TopLevelUnsupportedTransformationExpression otherwise', function () {
            var visitorCallback = jest
                .fn()
                .mockReturnValueOnce(visitorCallbackResult);
            var transformation = aString();
            var result = reduceTransformation(transformation, {
                visitors: {
                    TopLevelUnsupportedTransformationExpression: visitorCallback,
                },
            });
            expect(visitorCallback).toHaveBeenCalledTimes(1);
            expect(visitorCallback).toHaveBeenCalledWith(transformation);
            expect(result).toStrictEqual(visitorCallbackResult);
        });
    });
    describe('complex transformation', function () {
        var accumulator = anObject();
        test('traverses all string nodes that are transformation expressions', function () {
            var visitorCallback = jest.fn();
            var transformation = {
                a: {
                    b: { c: '$[0].ddd.eee.ffff' },
                    d: 2,
                    e: ['$.ggg', 3, 4, 5],
                },
            };
            reduceTransformation(transformation, {
                accumulator: accumulator,
                visitors: {
                    NestedSimpleTransformationExpression: visitorCallback,
                },
            });
            expect(visitorCallback).toHaveBeenCalledTimes(2);
            expect(visitorCallback).toHaveBeenCalledWith(accumulator, 'a.b.c', '$[0].ddd.eee.ffff');
            expect(visitorCallback).toHaveBeenCalledWith(accumulator, 'a.e[0]', '$.ggg');
        });
        describe('spread operator', function () {
            var _a = times(2, function () { return jest.fn(); }), topLevelSpreadOperatorCallback = _a[0], nestedSpreadOperatorCallback = _a[1];
            var argumentExpression = '$[1].d.e.f';
            var sibling = anObject();
            var siblingKeys = Object.keys(sibling);
            var path = "".concat(siblingKeys[0], ".b.c");
            beforeEach(function () {
                [topLevelSpreadOperatorCallback, nestedSpreadOperatorCallback].forEach(function (mock) { return mock.mockClear(); });
            });
            test('invokes the spread operator visitor prior to its children', function () {
                var nestedOmitCallback = jest.fn();
                var omitExpression = {
                    '@source': argumentExpression,
                    '@omit': times(2, function () { return aString(); }),
                };
                var transformation = __assign({ '*': omitExpression }, sibling);
                reduceTransformation(transformation, {
                    accumulator: accumulator,
                    visitors: {
                        TopLevelSpreadExpression: topLevelSpreadOperatorCallback,
                        NestedOmit: nestedOmitCallback,
                    },
                });
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledTimes(1);
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, omitExpression, siblingKeys);
                // expect(nestedOmitCallback).toHaveBeenCalled();
            });
            test('traverses top-level spread-operator transformation nodes', function () {
                var transformation = __assign({ '*': argumentExpression }, sibling);
                reduceTransformation(transformation, {
                    accumulator: accumulator,
                    visitors: {
                        TopLevelSpreadExpression: topLevelSpreadOperatorCallback,
                        NestedSpreadExpression: nestedSpreadOperatorCallback,
                    },
                });
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledTimes(1);
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, argumentExpression, siblingKeys);
                expect(nestedSpreadOperatorCallback).not.toHaveBeenCalled();
            });
            test('traverses nested spread-operator transformation nodes', function () {
                var transformation = set({}, path, __assign({ '*': argumentExpression }, sibling));
                var simpleTransformationCallback = jest.fn();
                reduceTransformation(transformation, {
                    accumulator: accumulator,
                    visitors: {
                        TopLevelSpreadExpression: topLevelSpreadOperatorCallback,
                        NestedSpreadExpression: nestedSpreadOperatorCallback,
                        NestedSimpleTransformationExpression: simpleTransformationCallback,
                    },
                });
                expect(topLevelSpreadOperatorCallback).not.toHaveBeenCalled();
                expect(simpleTransformationCallback).not.toHaveBeenCalled();
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledTimes(1);
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, argumentExpression, siblingKeys);
            });
            test('traverses items within an array of a spread-operator transformation nodes', function () {
                var simpleTransformationCallback = jest.fn();
                var transformation = set({}, path, __assign({ '*': ['$[0].x.y.z', '$[1].d.e.f'] }, sibling));
                reduceTransformation(transformation, {
                    accumulator: accumulator,
                    visitors: {
                        NestedSpreadExpression: nestedSpreadOperatorCallback,
                        NestedSimpleTransformationExpression: simpleTransformationCallback,
                    },
                });
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledTimes(2);
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, '$[0].x.y.z', siblingKeys);
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, '$[1].d.e.f', siblingKeys);
                expect(simpleTransformationCallback).not.toHaveBeenCalled();
            });
            test('sets the path to be the parent of the spread operator', function () {
                var anotherArgumentExpression = '$[0].x.y.z';
                var topLevelArgumentExpression = '$[1]';
                var transformation = set(__assign({ '*': topLevelArgumentExpression }, sibling), path, {
                    '*': [anotherArgumentExpression, argumentExpression],
                });
                reduceTransformation(transformation, {
                    accumulator: accumulator,
                    visitors: {
                        NestedSpreadExpression: nestedSpreadOperatorCallback,
                        TopLevelSpreadExpression: topLevelSpreadOperatorCallback,
                    },
                });
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledTimes(2);
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, argumentExpression, []);
                expect(nestedSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, path, anotherArgumentExpression, []);
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledTimes(1);
                expect(topLevelSpreadOperatorCallback).toHaveBeenCalledWith(accumulator, topLevelArgumentExpression, siblingKeys);
            });
        });
        describe('custom functions', function () {
            test('traverses custom-function nodes', function () {
                var customFunctionExpressionCallback = jest.fn();
                var simpleTransformationCallback = jest.fn();
                var customFunctionExpression = '#someCustomFunction($[0].someCustomFunction)';
                var transformation = {
                    a: {
                        b: customFunctionExpression,
                    },
                };
                reduceTransformation(transformation, {
                    accumulator: accumulator,
                    visitors: {
                        CustomFunctionExpression: customFunctionExpressionCallback,
                        NestedSimpleTransformationExpression: simpleTransformationCallback,
                    },
                });
                expect(customFunctionExpressionCallback).toHaveBeenCalledTimes(1);
                expect(customFunctionExpressionCallback).toHaveBeenCalledWith(accumulator, 'a.b', 'someCustomFunction', ['$[0].someCustomFunction'], customFunctionExpression);
                expect(simpleTransformationCallback).not.toHaveBeenCalled();
            });
            test('does not fail on invalid custom-function nodes', function () {
                var customFunctionExpressionCallback = jest.fn();
                var simpleTransformationCallback = jest.fn();
                var invalidCustomFunctionExpression = '#($[0].someCustomFunction)';
                var transformation = {
                    a: {
                        b: invalidCustomFunctionExpression,
                    },
                };
                reduceTransformation(transformation, {
                    accumulator: accumulator,
                    visitors: {
                        CustomFunctionExpression: customFunctionExpressionCallback,
                        NestedSimpleTransformationExpression: simpleTransformationCallback,
                    },
                });
                expect(customFunctionExpressionCallback).toHaveBeenCalledTimes(1);
                expect(customFunctionExpressionCallback).toHaveBeenCalledWith(accumulator, 'a.b', null, null, invalidCustomFunctionExpression);
                expect(simpleTransformationCallback).not.toHaveBeenCalled();
            });
        });
        describe('constant annotation', function () {
            test('traverses a nested constant annotation expression', function () {
                var nestedConstantExpressionCallback = jest.fn();
                var undesiredVisitor = jest.fn();
                var transformation = {
                    a: { b: { c: { '@constant': { someConst: '$.value123' } } } },
                };
                reduceTransformation(transformation, {
                    accumulator: accumulator,
                    visitors: {
                        NestedConstantValue: nestedConstantExpressionCallback,
                        NestedSimpleTransformationExpression: undesiredVisitor,
                    },
                });
                expect(nestedConstantExpressionCallback).toHaveBeenCalledTimes(1);
                expect(nestedConstantExpressionCallback).toHaveBeenCalledWith({
                    accumulator: accumulator,
                    path: 'a.b.c',
                    value: { someConst: '$.value123' },
                });
                expect(undesiredVisitor).not.toHaveBeenCalled();
            });
        });
        test('returns the accumulator with changes made to it', function () {
            var countAccumulator = { count: 0 };
            var transformation = {
                a: {
                    b: 1,
                    '*': '$[0].a.b.c',
                },
            };
            var result = reduceTransformation(transformation, {
                accumulator: countAccumulator,
                visitors: {
                    NestedSpreadExpression: function () {
                        countAccumulator.count += 1;
                    },
                },
            });
            expect(result).toStrictEqual({ count: 1 });
        });
        // TODO: replace with returning the invalid value, for constant-transformation
        test('invokes the NestedUnsupportedTransformationExpression otherwise', function () {
            var visitorCallback = jest.fn();
            var unsupportedTransformationValue = aString();
            var transformation = {
                a: { b: { c: unsupportedTransformationValue } },
            };
            reduceTransformation(transformation, {
                visitors: {
                    NestedUnsupportedTransformationExpression: visitorCallback,
                },
                accumulator: accumulator,
            });
            expect(visitorCallback).toHaveBeenCalledTimes(1);
            expect(visitorCallback).toHaveBeenCalledWith(accumulator, 'a.b.c', unsupportedTransformationValue);
        });
    });
    describe('mapping array items', function () {
        var visitorCallback = jest.fn();
        beforeEach(function () {
            visitorCallback.mockClear();
        });
        describe('top-level transformation', function () {
            test('invokes the TopLevelMapArrayItems visitor', function () {
                var transformation = {
                    '@path': '$.d.e.f',
                    '@itemTransformation': '$.g.h.i',
                };
                reduceTransformation(transformation, {
                    visitors: {
                        TopLevelMapArrayItems: visitorCallback,
                    },
                    accumulator: {},
                });
                expect(visitorCallback).toHaveBeenCalledTimes(1);
                expect(visitorCallback).toHaveBeenCalledWith('$.d.e.f', '$.g.h.i');
            });
        });
        describe('nested transformation', function () {
            var accumulator = {};
            var path = 'a.b.c';
            var withItemTransformation = function (itemTransformation) {
                return set({}, path, {
                    '@path': '$.d.e.f',
                    '@itemTransformation': itemTransformation,
                });
            };
            describe('simple item-transformation', function () {
                test('invokes the MapArrayItems visitor', function () {
                    reduceTransformation(withItemTransformation('$.g.h.i'), {
                        visitors: {
                            MapArrayItems: visitorCallback,
                        },
                        accumulator: accumulator,
                    });
                    expect(visitorCallback).toHaveBeenCalledTimes(1);
                    expect(visitorCallback).toHaveBeenCalledWith(accumulator, path, '$.d.e.f', '$.g.h.i');
                });
            });
            describe('complex item-transformation', function () {
                test('invokes the MapArrayItems visitor', function () {
                    var nestedSimpleTransformationVisitor = jest.fn();
                    reduceTransformation(withItemTransformation({ yyy: '$.g.h.i', zzz: '$.j.k.l' }), {
                        visitors: {
                            MapArrayItems: visitorCallback,
                            NestedSimpleTransformationExpression: nestedSimpleTransformationVisitor,
                        },
                        accumulator: accumulator,
                    });
                    expect(visitorCallback).toHaveBeenCalledTimes(1);
                    expect(visitorCallback).toHaveBeenCalledWith(accumulator, path, '$.d.e.f', {
                        yyy: '$.g.h.i',
                        zzz: '$.j.k.l',
                    });
                    expect(nestedSimpleTransformationVisitor).not.toHaveBeenCalled();
                });
            });
        });
    });
    describe('omit notation', function () {
        var fieldsToOmit = times(2, function () { return aString(); });
        var visitorCallback = jest.fn();
        var sourcePathExpression = '$.d.e.f';
        var path = 'a.b.c';
        var accumulator = {};
        beforeEach(function () {
            visitorCallback.mockClear();
        });
        describe('top-level transformation', function () {
            test('invokes the TopLevelOmit visitor', function () {
                var transformation = {
                    '@source': sourcePathExpression,
                    '@omit': fieldsToOmit,
                };
                reduceTransformation(transformation, {
                    visitors: {
                        TopLevelOmit: visitorCallback,
                    },
                    accumulator: accumulator,
                });
                expect(visitorCallback).toHaveBeenCalledTimes(1);
                expect(visitorCallback).toHaveBeenCalledWith(sourcePathExpression, fieldsToOmit);
            });
        });
        describe('nested transformation', function () {
            test('invokes the NestedOmit visitor', function () {
                var transformation = set({}, path, {
                    '@source': sourcePathExpression,
                    '@omit': fieldsToOmit,
                });
                reduceTransformation(transformation, {
                    visitors: {
                        NestedOmit: visitorCallback,
                    },
                    accumulator: accumulator,
                });
                expect(visitorCallback).toHaveBeenCalledTimes(1);
                expect(visitorCallback).toHaveBeenCalledWith(accumulator, path, sourcePathExpression, fieldsToOmit);
            });
        });
    });
    describe('error handling', function () {
        describe.each(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n      transformation                                       | visitorType\n      ", "                                         | ", "\n      ", "                        | ", "\n      ", " | ", "\n      ", "                    | ", "\n      ", "                                | ", "\n      ", "                         | ", "\n      ", "      | ", "\n    "], ["\n      transformation                                       | visitorType\n      ", "                                         | ", "\n      ", "                        | ", "\n      ", " | ", "\n      ", "                    | ", "\n      ", "                                | ", "\n      ", "                         | ", "\n      ", "      | ", "\n    "])), '$.a.b.c', 'TopLevelSimpleTransformationExpression', '#someCustomFunc($.a.b.c)', 'TopLevelCustomFunctionExpression', { a: { b: { c: 'unsupported transformation' } } }, 'NestedUnsupportedTransformationExpression', { a: { b: { c: '$.d.e.f' } } }, 'NestedSimpleTransformationExpression', { '*': '$.d.e.f' }, 'TopLevelSpreadExpression', { a: { '*': '$.d.e.f' } }, 'NestedSpreadExpression', { a: { b: '#someCustomFunction($.d.e.f)' } }, 'CustomFunctionExpression')('$visitor visitor', function (_a) {
            var transformation = _a.transformation, visitorType = _a.visitorType;
            test("rethrows the error thrown by the ".concat(visitorType, " visitor"), function () {
                var errorMessage = aString();
                var error = new Error(errorMessage);
                var visitorCallback = jest.fn().mockImplementationOnce(function () {
                    throw error;
                });
                expect(function () {
                    var _a;
                    return reduceTransformation(transformation, {
                        visitors: (_a = {},
                            _a[visitorType] = visitorCallback,
                            _a),
                    });
                }).toThrow(error);
            });
            test("does not fail when the ".concat(visitorType, " visitor is missing"), function () {
                expect(function () {
                    var _a;
                    return reduceTransformation(transformation, {
                        visitors: (_a = {},
                            _a[visitorType] = null,
                            _a),
                    });
                }).not.toThrow();
            });
        });
    });
});
var templateObject_1;
//# sourceMappingURL=reduceTransformation.spec.js.map