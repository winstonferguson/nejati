import { __assign, __spreadArray } from "tslib";
import { lastPathSegmentOf, parentPathOf, } from '@wix/motion-edm-autogen-common';
import { some } from 'lodash';
import { isReservedCorvidFieldName } from '../../corvid-entity';
import { hasValidArgumentIndex, isInvalidJsonPath, isRootObjectIdentifier, isSpreadOperator, } from '../../helpers';
import { transformations } from '../common';
import { isFunctionCallExpression } from '../custom-functions';
import { reduceTransformation } from '../reduceTransformation';
import { validateOmitTransformation, validationError } from './common';
var ARRAY_ITEMS_PATH_PROPERTY_NAME = transformations.ARRAY_ITEMS_PATH_PROPERTY_NAME, ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME = transformations.ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME;
var INVALID_PATH_STRING_MESSAGE = "must be a string starting with '$.'";
var validateArrayItemTransformation = function (sourceArrayExpression, itemTransformation, parentPath) {
    if (parentPath === void 0) { parentPath = null; }
    var withOptionalParentPath = function (path) { return function (err) { return (__assign(__assign({}, err), { 
        // @ts-expect-error
        parentPath: [parentPath, path, validationError.parentPath]
            .filter(function (s) { return s; })
            .join('.') })); }; };
    var validationErrors = [];
    if (isInvalidJsonPath(sourceArrayExpression)) {
        var fullPath = parentPath
            ? [parentPath, ARRAY_ITEMS_PATH_PROPERTY_NAME]
            : [ARRAY_ITEMS_PATH_PROPERTY_NAME];
        validationErrors.push(validationError(INVALID_PATH_STRING_MESSAGE, sourceArrayExpression, fullPath.join('.')));
    }
    validationErrors.push.apply(validationErrors, __spreadArray(__spreadArray([], validateResponseTransformation(sourceArrayExpression).validationErrors.map(withOptionalParentPath(ARRAY_ITEMS_PATH_PROPERTY_NAME)), false), validateResponseTransformation(itemTransformation).validationErrors.map(withOptionalParentPath(ARRAY_ITEM_TRANSFORMATION_PROPERTY_NAME)), false));
    return validationErrors;
};
var validateSimpleTransformationExpression = function (simpleTransformationExpression, path) {
    if (path === void 0) { path = null; }
    var transformationSegments = simpleTransformationExpression.split('.');
    var firstExpressionSegment = transformationSegments[0];
    var validationErrors = [];
    if (!isRootObjectIdentifier(firstExpressionSegment)) {
        validationErrors.push(validationError(INVALID_PATH_STRING_MESSAGE, simpleTransformationExpression, path));
    }
    if (some(transformationSegments, isSpreadOperator)) {
        validationErrors.push(validationError('cannot refer to the * operator', simpleTransformationExpression, path));
    }
    if (isInvalidJsonPath(simpleTransformationExpression)) {
        validationErrors.push(validationError('must be a valid json-path', simpleTransformationExpression, path));
    }
    transformationSegments
        .filter(isReservedCorvidFieldName)
        .forEach(function (invalidName) {
        return validationErrors.push(validationError("cannot refer to the ".concat(invalidName, " field"), simpleTransformationExpression, path));
    });
    return validationErrors;
};
var validateCustomFunctionExpression = function (_a) {
    var functionName = _a.functionName, argumentExpressions = _a.argumentExpressions, rawExpression = _a.rawExpression, _b = _a.path, path = _b === void 0 ? null : _b;
    var validationErrors = [];
    if (functionName === null || argumentExpressions === null) {
        validationErrors.push(validationError('contains an invalid custom function expression', rawExpression, path));
        return validationErrors;
    }
    // TODO: validate all arguments
    var argumentExpression = argumentExpressions[0];
    var firstSegment = argumentExpression.split('.')[0];
    if (isInvalidJsonPath(argumentExpression)) {
        validationErrors.push(validationError('must be a valid json-path', argumentExpression, path));
    }
    if (!isRootObjectIdentifier(firstSegment)) {
        validationErrors.push(validationError(INVALID_PATH_STRING_MESSAGE, argumentExpression, path));
    }
    return validationErrors;
};
function validateResponseTransformation(transformation) {
    var errors = reduceTransformation(transformation, {
        visitors: {
            TopLevelSimpleTransformationExpression: function (simpleTransformation) {
                return validateSimpleTransformationExpression(simpleTransformation);
            },
            TopLevelCustomFunctionExpression: function (functionName, argumentExpressions, rawExpression) {
                return validateCustomFunctionExpression({
                    functionName: functionName,
                    argumentExpressions: argumentExpressions,
                    rawExpression: rawExpression,
                });
            },
            CustomFunctionExpression: function (acc, path, functionName, argumentExpressions, rawExpression) {
                acc.push.apply(acc, validateCustomFunctionExpression({
                    functionName: functionName,
                    argumentExpressions: argumentExpressions,
                    rawExpression: rawExpression,
                    path: path,
                }));
            },
            NestedSimpleTransformationExpression: function (acc, path, simpleTransformationExpression) {
                var lastPathSegment = lastPathSegmentOf(path);
                var parentPath = parentPathOf(path);
                acc.push.apply(acc, validateSimpleTransformationExpression(simpleTransformationExpression, path));
                if (isFunctionCallExpression(lastPathSegment)) {
                    acc.push(validationError('cannot be a custom function call', lastPathSegment, parentPath));
                }
                if (isReservedCorvidFieldName(lastPathSegment)) {
                    acc.push(validationError("cannot refer to the ".concat(lastPathSegment, " field"), lastPathSegment, parentPath));
                }
                if (hasValidArgumentIndex(lastPathSegment)) {
                    acc.push(validationError(INVALID_PATH_STRING_MESSAGE, lastPathSegment, parentPath));
                }
                if (isRootObjectIdentifier(lastPathSegment)) {
                    acc.push(validationError('cannot refer to $ in a transformation key', lastPathSegment, parentPath));
                }
            },
            NestedUnsupportedTransformationExpression: function (acc, path, value) {
                acc.push(validationError(INVALID_PATH_STRING_MESSAGE, value, path));
            },
            TopLevelUnsupportedTransformationExpression: function (unsupportedTransformation) { return [
                validationError(INVALID_PATH_STRING_MESSAGE, unsupportedTransformation),
            ]; },
            TopLevelOmit: function (source, fieldsToOmit) {
                return validateOmitTransformation({
                    source: source,
                    fieldsToOmit: fieldsToOmit,
                    validateSource: validateResponseTransformation,
                });
            },
            NestedOmit: function (acc, path, source, fieldsToOmit) {
                return acc.push.apply(acc, validateOmitTransformation({
                    source: source,
                    fieldsToOmit: fieldsToOmit,
                    parentPath: path,
                    validateSource: validateResponseTransformation,
                }));
            },
            MapArrayItems: function (acc, path, sourceArrayExpression, itemTransformation) {
                acc.push.apply(acc, validateArrayItemTransformation(sourceArrayExpression, itemTransformation, path));
            },
            TopLevelMapArrayItems: function (sourceArrayExpression, itemTransformation) {
                return validateArrayItemTransformation(sourceArrayExpression, itemTransformation);
            },
        },
        accumulator: [],
    });
    return {
        isValid: errors.length === 0,
        validationErrors: errors,
    };
}
export { validateResponseTransformation };
//# sourceMappingURL=validateResponseTransformation.js.map