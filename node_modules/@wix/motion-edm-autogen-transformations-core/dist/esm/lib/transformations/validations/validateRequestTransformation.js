import { lastPathSegmentOf, parentPathOf, } from '@wix/motion-edm-autogen-common';
import { filter, some } from 'lodash';
import { isReservedCommonFieldName, toCorvidName } from '../../corvid-entity';
import { hasValidArgumentIndex, isInvalidJsonPath, isInvalidJsonValue, isSpreadOperator, } from '../../helpers';
import { isFunctionCallExpression } from '../custom-functions';
import { reduceTransformation } from '../reduceTransformation';
import { validateOmitTransformation, validationError } from './common';
var validateSimpleTransformation = function (simpleTransformation, path) {
    if (path === void 0) { path = null; }
    var validationErrors = [];
    var transformationSegments = simpleTransformation.split('.');
    var firstSegment = transformationSegments[0];
    transformationSegments
        .filter(isReservedCommonFieldName)
        .forEach(function (invalidName) {
        return validationErrors.push(validationError("cannot refer to ".concat(invalidName, " field, consider using ").concat(toCorvidName(invalidName), " instead"), simpleTransformation, path));
    });
    if (some(transformationSegments, isSpreadOperator)) {
        validationErrors.push(validationError('cannot refer to the * operator', simpleTransformation, path));
    }
    if (!hasValidArgumentIndex(firstSegment)) {
        validationErrors.push(validationError('must start with $[N] where N is an index', simpleTransformation, path));
    }
    if (filter(transformationSegments, hasValidArgumentIndex).length > 1) {
        validationErrors.push(validationError('must have a single argument-index as the first path segment', simpleTransformation, path));
    }
    return validationErrors;
};
function validateRequestTransformation(transformation) {
    var errors = reduceTransformation(transformation, {
        visitors: {
            TopLevelSimpleTransformationExpression: function (simpleTransformation) {
                return validateSimpleTransformation(simpleTransformation);
            },
            CustomFunctionExpression: function (acc, path, functionName, argumentExpressions, rawExpression) {
                if (functionName === null || argumentExpressions === null) {
                    acc.push(validationError('contains an invalid custom function expression', rawExpression, path));
                }
                else {
                    var argumentExpression_1 = argumentExpressions[0];
                    if (functionName === 'constant') {
                        if (isInvalidJsonValue(argumentExpression_1)) {
                            acc.push(validationError('must be a valid json value', argumentExpression_1, path));
                        }
                    }
                    else {
                        // TODO: validate all arguments
                        var _a = argumentExpression_1.split('.'), firstSegment = _a[0], nestedPathSegments = _a.slice(1);
                        if (isInvalidJsonPath(argumentExpression_1)) {
                            acc.push(validationError('must be a valid json-path', argumentExpression_1, path));
                        }
                        if (!hasValidArgumentIndex(firstSegment)) {
                            acc.push(validationError('must start with $[N] where N is an index', argumentExpression_1, path));
                        }
                        nestedPathSegments.forEach(function (nestedPathSegment) {
                            if (hasValidArgumentIndex(nestedPathSegment)) {
                                acc.push(validationError('must have a single argument-index as the first path segment', argumentExpression_1, path));
                            }
                        });
                    }
                }
            },
            NestedSimpleTransformationExpression: function (acc, path, simpleTransformationExpression) {
                var lastPathSegment = lastPathSegmentOf(path);
                var parentPath = parentPathOf(path);
                if (isFunctionCallExpression(lastPathSegment)) {
                    acc.push(validationError('cannot be a custom function call', lastPathSegment, parentPath));
                }
                if (hasValidArgumentIndex(lastPathSegment)) {
                    acc.push(validationError("must start with '$.'", lastPathSegment, parentPath));
                }
                if (isSpreadOperator(lastPathSegment)) {
                    acc.push(validationError('cannot refer to the * operator', lastPathSegment, parentPath));
                }
                acc.push.apply(acc, validateSimpleTransformation(simpleTransformationExpression, path));
            },
            NestedUnsupportedTransformationExpression: function (acc, path, value) {
                acc.push(validationError('must start with $[N] where N is an index', value, path));
            },
            TopLevelUnsupportedTransformationExpression: function (unsupportedTransformation) { return [
                validationError('must start with $[N] where N is an index', unsupportedTransformation),
            ]; },
            TopLevelOmit: function (source, fieldsToOmit) {
                return validateOmitTransformation({
                    source: source,
                    fieldsToOmit: fieldsToOmit,
                    validateSource: validateRequestTransformation,
                });
            },
            NestedOmit: function (acc, path, source, fieldsToOmit) {
                return acc.push.apply(acc, validateOmitTransformation({
                    source: source,
                    fieldsToOmit: fieldsToOmit,
                    parentPath: path,
                    validateSource: validateRequestTransformation,
                }));
            },
        },
        accumulator: [],
    });
    return {
        isValid: errors.length === 0,
        validationErrors: errors,
    };
}
export { validateRequestTransformation };
//# sourceMappingURL=validateRequestTransformation.js.map