// src/common.ts
var PUBLIC_METADATA_KEY = "__metadata";
var API_URL = "www.wixapis.com";
var READ_ONLY_API_URL = "readonly.wixapis.com";
var FORCE_WRITE_API_URLS = ["/ecom/v1/carts/current"];

// src/helpers.ts
var getDefaultContentHeader = (options) => {
  if (options?.method && ["post", "put", "patch"].includes(options.method.toLocaleLowerCase()) && options.body) {
    return { "Content-Type": "application/json" };
  }
  return {};
};
var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);

// src/host-modules.ts
var isHostModule = (val) => isObject(val) && val.__type === "host";
function buildHostModule(val, host) {
  return val.create(host);
}

// src/bi/biHeaderGenerator.ts
var WixBIHeaderName = "x-wix-bi-gateway";
function biHeaderGenerator(apiMetadata, publicMetadata) {
  return {
    [WixBIHeaderName]: objectToKeyValue({
      environment: "js-sdk",
      "package-name": apiMetadata.packageName ?? publicMetadata?.PACKAGE_NAME,
      "method-fqn": apiMetadata.methodFqn,
      entity: apiMetadata.entityFqdn
    })
  };
}
function objectToKeyValue(input) {
  return Object.entries(input).filter(([_, value]) => Boolean(value)).map(([key, value]) => `${key}=${value}`).join(",");
}

// src/rest-modules.ts
function buildRESTDescriptor(origFunc, publicMetadata, boundFetch) {
  return origFunc({
    request: async (factory) => {
      const requestOptions = factory({ host: API_URL });
      let request = requestOptions;
      if (request.method === "GET" && request.fallback?.length && request.params.toString().length > 4e3) {
        request = requestOptions.fallback[0];
      }
      const domain = request.method === "GET" && !FORCE_WRITE_API_URLS.some((url2) => request.url === url2) ? READ_ONLY_API_URL : API_URL;
      let url = `https://${domain}${request.url}`;
      if (request.params && request.params.toString()) {
        url += `?${request.params.toString()}`;
      }
      try {
        const biHeader = biHeaderGenerator(requestOptions, publicMetadata);
        const res = await boundFetch(url, {
          method: request.method,
          ...request.data && {
            body: JSON.stringify(request.data)
          },
          headers: {
            ...biHeader
          }
        });
        if (res.status !== 200) {
          let dataError = null;
          try {
            dataError = await res.json();
          } catch (e) {
          }
          throw errorBuilder(
            res.status,
            dataError?.message,
            dataError?.details,
            {
              requestId: res.headers.get("X-Wix-Request-Id"),
              details: dataError
            }
          );
        }
        const data = await res.json();
        return {
          data,
          headers: res.headers,
          status: res.status,
          statusText: res.statusText
        };
      } catch (e) {
        if (e.message?.includes("fetch is not defined")) {
          console.error("Node.js v18+ is required");
        }
        throw e;
      }
    }
  });
}
var errorBuilder = (code, description, details, data) => {
  return {
    response: {
      data: {
        details: {
          ...!details?.validationError && {
            applicationError: {
              description,
              code,
              data
            }
          },
          ...details
        },
        message: description
      },
      status: code
    }
  };
};

// src/wixClient.ts
function createClient(config) {
  const _headers = config.headers || { Authorization: "" };
  const authStrategy = config.auth || {
    getAuthHeaders: () => Promise.resolve({ headers: {} })
  };
  const boundFetch = async (url, options) => {
    const authHeaders = await authStrategy.getAuthHeaders(config.host);
    const defaultContentTypeHeader = getDefaultContentHeader(options);
    return fetch(url, {
      ...options,
      headers: {
        ...defaultContentTypeHeader,
        ..._headers,
        ...authHeaders?.headers,
        ...options?.headers
      }
    });
  };
  const use = (modules, metadata) => {
    if (isHostModule(modules) && config.host) {
      return buildHostModule(modules, config.host);
    } else if (typeof modules === "function") {
      return buildRESTDescriptor(
        modules,
        metadata ?? {},
        boundFetch
      );
    } else if (isObject(modules)) {
      return Object.fromEntries(
        Object.entries(
          modules
        ).map(([key, value]) => {
          return [key, use(value, modules[PUBLIC_METADATA_KEY])];
        })
      );
    } else {
      return modules;
    }
  };
  const setHeaders = (headers) => {
    for (const k in headers) {
      _headers[k] = headers[k];
    }
  };
  const wrappedModules = config.modules ? use(config.modules) : {};
  return {
    ...wrappedModules,
    auth: authStrategy,
    setHeaders,
    use,
    fetch: (relativeUrl, options) => {
      const finalUrl = new URL(relativeUrl, `https://${API_URL}`);
      finalUrl.host = API_URL;
      finalUrl.protocol = "https";
      return boundFetch(finalUrl, options);
    }
  };
}

// src/wixMedia.ts
import { sdk } from "@wix/image-kit";
import { parse } from "querystring";
var URL_HASH_PREFIX = "#";
var WIX_PROTOCOL = "wix:";
var WIX_IMAGE = "image";
var WIX_IMAGE_URL = "https://static.wixstatic.com/media/";
function getScaledToFillImageUrl(wixMediaIdentifier, targetWidth, targetHeight, options) {
  const img = getImageUrl(wixMediaIdentifier);
  return sdk.getScaleToFillImageURL(
    img.id,
    img.height,
    img.width,
    targetWidth,
    targetHeight,
    options
  );
}
function getScaledToFitImageUrl(wixMediaIdentifier, targetWidth, targetHeight, options) {
  const img = getImageUrl(wixMediaIdentifier);
  return sdk.getScaleToFitImageURL(
    img.id,
    img.height,
    img.width,
    targetWidth,
    targetHeight,
    options
  );
}
function getCroppedImageUrl(wixMediaIdentifier, cropX, cropY, cropWidth, cropHeight, targetWidth, targetHeight, options) {
  const img = getImageUrl(wixMediaIdentifier);
  return sdk.getCropImageURL(
    img.id,
    img.height,
    img.width,
    cropX,
    cropY,
    cropWidth,
    cropHeight,
    targetWidth,
    targetHeight,
    options
  );
}
function getImageUrl(val) {
  let id, filenameOrAltText;
  let height, width;
  if (val.startsWith(WIX_IMAGE_URL)) {
    id = val.split(WIX_IMAGE_URL).pop().split("/")[0];
    width = val.split("/w_").pop().split(",")[0];
    height = val.split(",h_").pop().split(",")[0];
  } else {
    const alignedImage = alignIfLegacy(val, WIX_IMAGE);
    const { hash, pathname } = new URL(alignedImage);
    ({ originHeight: height, originWidth: width } = parse(
      hash.replace(URL_HASH_PREFIX, "")
    ));
    [id, filenameOrAltText] = pathname.replace(`${WIX_IMAGE}://v1/`, "").split("/");
  }
  const decodedFilenameOrAltText = decodeText(filenameOrAltText);
  const res = {
    id,
    url: `${WIX_IMAGE_URL}${id}`,
    height: Number(height),
    width: Number(width)
  };
  if (!decodedFilenameOrAltText) {
    return res;
  }
  return {
    ...res,
    altText: decodedFilenameOrAltText,
    filename: decodedFilenameOrAltText
  };
}
function decodeText(s) {
  if (!s) {
    return s;
  }
  return decodeURIComponent(s);
}
function alignIfLegacy(url, type) {
  const { protocol } = new URL(url);
  return protocol === `${type}:` ? `${WIX_PROTOCOL}${url}` : url;
}
var media = {
  getCroppedImageUrl,
  getScaledToFillImageUrl,
  getScaledToFitImageUrl,
  getImageUrl
};

// src/auth/oauth2/OAuthStrategy.ts
import { redirects } from "@wix/redirects";

// src/tokenHelpers.ts
function getCurrentDate() {
  return Math.floor(Date.now() / 1e3);
}
function isTokenExpired(token) {
  const currentDate = getCurrentDate();
  return token.expiresAt < currentDate;
}
function createAccessToken(accessToken, expiresIn) {
  const now = getCurrentDate();
  return { value: accessToken, expiresAt: Number(expiresIn) + now };
}

// src/auth/oauth2/OAuthStrategy.ts
import pkceChallenge from "pkce-challenge";
import { authentication, recovery, verification } from "@wix/identity";

// src/auth/oauth2/types.ts
var LoginState = /* @__PURE__ */ ((LoginState2) => {
  LoginState2["SUCCESS"] = "SUCCESS";
  LoginState2["INITIAL"] = "INITIAL";
  LoginState2["FAILURE"] = "FAILURE";
  LoginState2["EMAIL_VERIFICATION_REQUIRED"] = "EMAIL_VERIFICATION_REQUIRED";
  LoginState2["OWNER_APPROVAL_REQUIRED"] = "OWNER_APPROVAL_REQUIRED";
  LoginState2["USER_CAPTCHA_REQUIRED"] = "USER_CAPTCHA_REQUIRED";
  LoginState2["SILENT_CAPTCHA_REQUIRED"] = "SILENT_CAPTCHA_REQUIRED";
  return LoginState2;
})(LoginState || {});
var TokenRole = /* @__PURE__ */ ((TokenRole2) => {
  TokenRole2["NONE"] = "none";
  TokenRole2["VISITOR"] = "visitor";
  TokenRole2["MEMBER"] = "member";
  return TokenRole2;
})(TokenRole || {});

// src/iframeUtils.ts
function addListener(eventTarget, name, fn) {
  if (eventTarget.addEventListener) {
    eventTarget.addEventListener(name, fn);
  } else {
    eventTarget.attachEvent("on" + name, fn);
  }
}
function removeListener(eventTarget, name, fn) {
  if (eventTarget.removeEventListener) {
    eventTarget.removeEventListener(name, fn);
  } else {
    eventTarget.detachEvent("on" + name, fn);
  }
}
function loadFrame(src) {
  const iframe = document.createElement("iframe");
  iframe.style.display = "none";
  iframe.src = src;
  return document.body.appendChild(iframe);
}
function addPostMessageListener(state) {
  let responseHandler;
  let timeoutId;
  const msgReceivedOrTimeout = new Promise((resolve, reject) => {
    responseHandler = (e) => {
      if (!e.data || e.data.state !== state) {
        return;
      }
      resolve(e.data);
    };
    addListener(window, "message", responseHandler);
    timeoutId = setTimeout(() => {
      reject(new Error("OAuth flow timed out"));
    }, 12e4);
  });
  return msgReceivedOrTimeout.finally(() => {
    clearTimeout(timeoutId);
    removeListener(window, "message", responseHandler);
  });
}

// src/auth/oauth2/constants.ts
var MISSING_CAPTCHA = "-19971";
var INVALID_CAPTCHA = "-19970";
var EMAIL_EXISTS = "-19995";
var INVALID_PASSWORD = "-19976";
var RESET_PASSWORD = "-19973";

// src/auth/oauth2/OAuthStrategy.ts
var moduleWithTokens = { redirects, authentication, recovery, verification };
function OAuthStrategy(config) {
  const _tokens = config.tokens || {
    accessToken: { value: "", expiresAt: 0 },
    refreshToken: { value: "", role: "none" /* NONE */ }
  };
  const setTokens = (tokens) => {
    _tokens.accessToken = tokens.accessToken;
    _tokens.refreshToken = tokens.refreshToken;
  };
  let _state = {
    loginState: "INITIAL" /* INITIAL */
  };
  const getAuthHeaders = async () => {
    if (!_tokens.accessToken?.value || isTokenExpired(_tokens.accessToken)) {
      const tokens = await generateVisitorTokens({
        refreshToken: _tokens.refreshToken
      });
      setTokens(tokens);
    }
    return Promise.resolve({
      headers: { Authorization: _tokens.accessToken.value }
    });
  };
  const wixClientWithTokens = createClient({
    modules: moduleWithTokens,
    auth: { getAuthHeaders }
  });
  const generateVisitorTokens = async (tokens) => {
    if (tokens?.accessToken?.value && tokens?.refreshToken?.value && !isTokenExpired(tokens.accessToken)) {
      return tokens;
    }
    if (tokens?.refreshToken?.value) {
      try {
        const newTokens = await renewToken(tokens.refreshToken);
        return newTokens;
      } catch (e) {
      }
    }
    const tokensResponse = await fetchTokens({
      clientId: config.clientId,
      grantType: "anonymous"
    });
    return {
      accessToken: createAccessToken(
        tokensResponse.access_token,
        tokensResponse.expires_in
      ),
      refreshToken: {
        value: tokensResponse.refresh_token,
        role: "visitor" /* VISITOR */
      }
    };
  };
  const renewToken = async (refreshToken) => {
    const tokensResponse = await fetchTokens({
      refreshToken: refreshToken.value,
      grantType: "refresh_token"
    });
    const accessToken = createAccessToken(
      tokensResponse.access_token,
      tokensResponse.expires_in
    );
    return {
      accessToken,
      refreshToken
    };
  };
  const generatePKCE = () => {
    const pkceState = pkceChallenge();
    return {
      codeChallenge: pkceState.code_challenge,
      codeVerifier: pkceState.code_verifier,
      state: pkceChallenge().code_challenge
    };
  };
  const generateOAuthData = (redirectUri, originalUri) => {
    const state = { redirectUri };
    const pkceState = generatePKCE();
    return {
      ...state,
      originalUri: originalUri ?? "",
      codeChallenge: pkceState.codeChallenge,
      codeVerifier: pkceState.codeVerifier,
      state: pkceChallenge().code_challenge
    };
  };
  const getAuthorizationUrlWithOptions = async (oauthData, responseMode, prompt, sessionToken) => {
    const { redirectSession } = await wixClientWithTokens.redirects.createRedirectSession({
      auth: {
        authRequest: {
          redirectUri: oauthData.redirectUri,
          ...oauthData.redirectUri && {
            redirectUri: oauthData.redirectUri
          },
          clientId: config.clientId,
          codeChallenge: oauthData.codeChallenge,
          codeChallengeMethod: "S256",
          responseMode,
          responseType: "code",
          scope: "offline_access",
          state: oauthData.state,
          ...sessionToken && { sessionToken }
        },
        prompt: redirects.Prompt[prompt]
      }
    });
    return { authUrl: redirectSession.fullUrl };
  };
  const getAuthUrl = async (oauthData, opts = {
    prompt: "login"
  }) => {
    return getAuthorizationUrlWithOptions(
      oauthData,
      opts.responseMode ?? "fragment",
      opts.prompt ?? "login"
    );
  };
  const parseFromUrl = (url, responseMode = "fragment") => {
    const parsedUrl = new URL(url ?? window.location.href);
    const params = responseMode === "query" ? parsedUrl.searchParams : new URLSearchParams(parsedUrl.hash.substring(1));
    const code = params.get("code");
    const state = params.get("state");
    const error = params.get("error");
    const errorDescription = params.get("error_description");
    return { code, state, ...error && { error, errorDescription } };
  };
  const getMemberTokens = async (code, state, oauthData) => {
    if (!code || !state) {
      throw new Error("Missing code or _state");
    } else if (state !== oauthData.state) {
      throw new Error("Invalid _state");
    }
    try {
      const tokensResponse = await fetchTokens({
        clientId: config.clientId,
        grantType: "authorization_code",
        ...oauthData.redirectUri && { redirectUri: oauthData.redirectUri },
        code,
        codeVerifier: oauthData.codeVerifier
      });
      return {
        accessToken: createAccessToken(
          tokensResponse.access_token,
          tokensResponse.expires_in
        ),
        refreshToken: {
          value: tokensResponse.refresh_token,
          role: "member" /* MEMBER */
        }
      };
    } catch (e) {
      throw new Error("Failed to get member tokens");
    }
  };
  const logout = async (originalUrl) => {
    const { redirectSession } = await wixClientWithTokens.redirects.createRedirectSession({
      logout: { clientId: config.clientId },
      callbacks: {
        postFlowUrl: originalUrl
      }
    });
    _tokens.accessToken = { value: "", expiresAt: 0 };
    _tokens.refreshToken = { value: "", role: "none" /* NONE */ };
    return { logoutUrl: redirectSession.fullUrl };
  };
  const handleState = (response) => {
    if (response.state === authentication.StateType.SUCCESS) {
      return {
        loginState: "SUCCESS" /* SUCCESS */,
        data: { sessionToken: response.sessionToken }
      };
    } else if (response.state === authentication.StateType.REQUIRE_OWNER_APPROVAL) {
      return {
        loginState: "OWNER_APPROVAL_REQUIRED" /* OWNER_APPROVAL_REQUIRED */
      };
    } else if (response.state === authentication.StateType.REQUIRE_EMAIL_VERIFICATION) {
      _state = {
        loginState: "EMAIL_VERIFICATION_REQUIRED" /* EMAIL_VERIFICATION_REQUIRED */,
        data: { stateToken: response.stateToken }
      };
      return _state;
    }
    return {
      loginState: "FAILURE" /* FAILURE */,
      error: "Unknown _state"
    };
  };
  const register = async (params) => {
    try {
      const res = await wixClientWithTokens.authentication.registerV2(
        {
          email: params.email
        },
        {
          password: params.password,
          profile: params.profile,
          ...params.captchaTokens && {
            captchaTokens: [
              {
                Recaptcha: params.captchaTokens?.recaptchaToken,
                InvisibleRecaptcha: params.captchaTokens?.invisibleRecaptchaToken
              }
            ]
          }
        }
      );
      return handleState(res);
    } catch (e) {
      const emailValidation = e.details.validationError?.fieldViolations?.find(
        (v) => v.data.type === "EMAIL"
      );
      if (emailValidation) {
        return {
          loginState: "FAILURE" /* FAILURE */,
          error: emailValidation.description,
          errorCode: "invalidEmail"
        };
      }
      if (e.details.applicationError?.code === MISSING_CAPTCHA) {
        return {
          loginState: "FAILURE" /* FAILURE */,
          error: e.message,
          errorCode: "missingCaptchaToken"
        };
      }
      if (e.details.applicationError?.code === EMAIL_EXISTS) {
        return {
          loginState: "FAILURE" /* FAILURE */,
          error: e.message,
          errorCode: "emailAlreadyExists"
        };
      }
      if (e.details.applicationError?.code === INVALID_CAPTCHA) {
        return {
          loginState: "FAILURE" /* FAILURE */,
          error: e.message,
          errorCode: "invalidCaptchaToken"
        };
      }
      return {
        loginState: "FAILURE" /* FAILURE */,
        error: e.message
      };
    }
  };
  const login = async (params) => {
    try {
      const res = await wixClientWithTokens.authentication.loginV2(
        {
          email: params.email
        },
        {
          password: params.password,
          ...params.captchaTokens && {
            captchaTokens: [
              {
                Recaptcha: params.captchaTokens?.recaptchaToken,
                InvisibleRecaptcha: params.captchaTokens?.invisibleRecaptchaToken
              }
            ]
          }
        }
      );
      return handleState(res);
    } catch (e) {
      return {
        loginState: "FAILURE" /* FAILURE */,
        error: e.message,
        errorCode: e.details.applicationError?.code === MISSING_CAPTCHA ? "missingCaptchaToken" : e.details.applicationError?.code === INVALID_CAPTCHA ? "invalidCaptchaToken" : e.details.applicationError.code === INVALID_PASSWORD ? "invalidPassword" : e.details.applicationError.code === RESET_PASSWORD ? "resetPassword" : "invalidEmail"
      };
    }
  };
  const processVerification = async (nextInputs, state) => {
    const stateToUse = state ?? _state;
    if (stateToUse.loginState === "EMAIL_VERIFICATION_REQUIRED" /* EMAIL_VERIFICATION_REQUIRED */) {
      const code = nextInputs.verificationCode ?? nextInputs.code;
      const res = await wixClientWithTokens.verification.verifyDuringAuthentication(
        code,
        { stateToken: stateToUse.data.stateToken }
      );
      return handleState(res);
    }
    return {
      loginState: "FAILURE" /* FAILURE */,
      error: "Unknown _state"
    };
  };
  const getMemberTokensForDirectLogin = async (sessionToken) => {
    const oauthPKCE = generatePKCE();
    const { authUrl } = await getAuthorizationUrlWithOptions(
      oauthPKCE,
      "web_message",
      "none",
      sessionToken
    );
    const iframePromise = addPostMessageListener(oauthPKCE.state);
    const iframeEl = loadFrame(authUrl);
    return iframePromise.then((res) => {
      return getMemberTokens(res.code, res.state, oauthPKCE);
    }).finally(() => {
      if (document.body.contains(iframeEl)) {
        iframeEl.parentElement?.removeChild(iframeEl);
      }
    });
  };
  const sendPasswordResetEmail = async (email, redirectUri) => {
    await wixClientWithTokens.recovery.sendRecoveryEmail(email, {
      redirect: { url: redirectUri, clientId: config.clientId }
    });
  };
  const loggedIn = () => {
    return _tokens.refreshToken.role === "member" /* MEMBER */;
  };
  return {
    generateVisitorTokens,
    renewToken,
    parseFromUrl,
    getAuthUrl,
    getMemberTokens,
    generateOAuthData,
    getAuthHeaders,
    setTokens,
    getTokens: () => _tokens,
    loggedIn,
    logout,
    register,
    processVerification,
    login,
    getMemberTokensForDirectLogin,
    sendPasswordResetEmail,
    captchaInvisibleSiteKey: "6LdoPaUfAAAAAJphvHoUoOob7mx0KDlXyXlgrx5v",
    captchaVisibleSiteKey: "6Ld0J8IcAAAAANyrnxzrRlX1xrrdXsOmsepUYosy"
  };
}
var fetchTokens = async (payload) => {
  const res = await fetch(`https://${API_URL}/oauth2/token`, {
    method: "POST",
    body: JSON.stringify(payload),
    headers: {
      ...biHeaderGenerator({
        entityFqdn: "wix.identity.oauth.v1.refresh_token",
        methodFqn: "wix.identity.oauth2.v1.Oauth2Ng.Token",
        packageName: "@wix/sdk"
      }),
      "Content-Type": "application/json"
    }
  });
  if (res.status !== 200) {
    throw new Error("something went wrong");
  }
  const json = await res.json();
  return json;
};

// src/auth/ApiKeyAuthStrategy.ts
function ApiKeyStrategy({
  siteId,
  accountId,
  apiKey
}) {
  const headers = { Authorization: apiKey };
  if (siteId) {
    headers["wix-site-id"] = siteId;
  }
  if (accountId) {
    headers["wix-account-id"] = accountId;
  }
  return {
    setSiteId(_siteId) {
      headers["wix-site-id"] = _siteId;
    },
    setAccountId(_accountId) {
      headers["wix-account-id"] = _accountId;
    },
    async getAuthHeaders() {
      return {
        headers
      };
    }
  };
}

// src/index.ts
export * from "@wix/sdk-types";
export {
  ApiKeyStrategy,
  LoginState,
  OAuthStrategy,
  TokenRole,
  createClient,
  decodeText,
  media
};
