import { Host, RESTFunctionDescriptor, BuildRESTFunction, HostModule, HostModuleAPI, AuthenticationStrategy } from '@wix/sdk-types';
export * from '@wix/sdk-types';
import { ConditionalExcept, EmptyObject } from 'type-fest';
import { ImageTransformOptions } from '@wix/image-kit';
import { authentication } from '@wix/identity';

type PublicMetadata = {
    PACKAGE_NAME?: string;
};

type Headers = {
    Authorization: string;
} & Record<string, string>;
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined> = BuildRESTDescriptors<T> & (H extends Host<any> ? BuildHostDescriptors<T> : {});
type BuildRESTDescriptors<T extends Descriptors> = T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : ConditionalExcept<{
    [Key in keyof T]: T[Key] extends Descriptors ? BuildRESTDescriptors<T[Key]> : never;
}, EmptyObject>;
type BuildHostDescriptors<T extends Descriptors> = T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
    [Key in keyof T]: T[Key] extends Descriptors ? BuildHostDescriptors<T[Key]> : never;
}, EmptyObject>;
/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | HostModule<any, any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type is used in `createClient` to ensure that the given host matches the host of the given descriptors.
 * If the host does not match, the descriptor is replaced with a host module that will throw an error when used.
 */
type AssertHostMatches<T extends Descriptors, H extends Host<any>> = T extends HostModule<any, infer U> ? H extends undefined ? never : H extends U ? T : HostModule<any, H> : T extends RESTFunctionDescriptor<any> ? T : {
    [Key in keyof T]: T[Key] extends Descriptors ? AssertHostMatches<T[Key], H> : T[Key];
};
type WixClient<H extends Host<any> | undefined = undefined, Z extends AuthenticationStrategy<H> = AuthenticationStrategy<H>, T extends Descriptors = Descriptors> = {
    setHeaders(headers: Headers): void;
    auth: Z;
    fetch(relativeUrl: string, options: RequestInit): Promise<Response>;
    use<R extends Descriptors = EmptyObject>(modules: H extends Host<any> ? AssertHostMatches<R, H> : R): BuildDescriptors<R, H>;
} & BuildDescriptors<T, H>;
declare function createClient<H extends Host<any> | undefined = undefined, Z extends AuthenticationStrategy<H> = AuthenticationStrategy<H>, T extends Descriptors = EmptyObject>(config: {
    modules?: H extends Host<any> ? AssertHostMatches<T, H> : T;
    auth?: Z;
    headers?: Headers;
    host?: H;
}): WixClient<H, Z, T>;

declare function getScaledToFillImageUrl(wixMediaIdentifier: string, targetWidth: number, targetHeight: number, options: ImageTransformOptions): string;
declare function getScaledToFitImageUrl(wixMediaIdentifier: string, targetWidth: number, targetHeight: number, options: ImageTransformOptions): string;
declare function getCroppedImageUrl(wixMediaIdentifier: string, cropX: number, cropY: number, cropWidth: number, cropHeight: number, targetWidth: number, targetHeight: number, options?: ImageTransformOptions): string;
declare function getImageUrl(val: string): {
    id: string;
    url: string;
    height: number;
    width: number;
} | {
    altText: string;
    filename: string;
    id: string;
    url: string;
    height: number;
    width: number;
};
declare function decodeText(s: string): string;
declare const media: {
    getCroppedImageUrl: typeof getCroppedImageUrl;
    getScaledToFillImageUrl: typeof getScaledToFillImageUrl;
    getScaledToFitImageUrl: typeof getScaledToFitImageUrl;
    getImageUrl: typeof getImageUrl;
};

interface Tokens {
    accessToken: AccessToken;
    refreshToken: RefreshToken;
}
interface Token {
    value: string;
}
interface AccessToken extends Token {
    expiresAt: number;
}
interface RefreshToken extends Token {
    role: TokenRole;
}
interface OauthData extends OauthPKCE {
    originalUri: string;
    redirectUri: string;
}
interface OauthPKCE {
    codeVerifier: string;
    codeChallenge: string;
    state: string;
}
interface RegisterParams extends LoginParams {
    profile?: authentication.IdentityProfile;
}
interface LoginParams {
    email: string;
    password: string;
    captchaTokens?: {
        invisibleRecaptchaToken?: string;
        recaptchaToken?: string;
    };
}
interface IOAuthStrategy extends AuthenticationStrategy {
    generateVisitorTokens(tokens?: {
        refreshToken?: RefreshToken;
        accessToken?: AccessToken;
    }): Promise<Tokens>;
    renewToken: (refreshToken: RefreshToken) => Promise<Tokens>;
    setTokens: (tokens: Tokens) => void;
    getTokens: () => Tokens;
    generateOAuthData: (redirectUri: string, originalUri?: string) => OauthData;
    getAuthUrl: (oauthData: OauthData, opts?: {
        prompt?: 'login' | 'none';
        responseMode?: 'fragment' | 'web_message' | 'query';
    }) => Promise<{
        authUrl: string;
    }>;
    getMemberTokens: (code: string, state: string, oauthData: OauthData) => Promise<Tokens>;
    logout: (originalUrl: string) => Promise<{
        logoutUrl: string;
    }>;
    parseFromUrl: (url?: string, responseMode?: 'query' | 'fragment') => {
        code: string;
        state: string;
        error?: string;
        errorDescription?: string;
    };
    register: (params: RegisterParams) => Promise<StateMachine>;
    login: (params: LoginParams) => Promise<StateMachine>;
    processVerification<T extends ProcessableState>(nextInputs: CalculateNextState<T>, state?: StateMachine): Promise<StateMachine>;
    getMemberTokensForDirectLogin: (sessionToken: string) => Promise<Tokens>;
    sendPasswordResetEmail: (email: string, redirectUri: string) => Promise<void>;
    captchaInvisibleSiteKey: string;
    captchaVisibleSiteKey: string;
    loggedIn: () => boolean;
}
declare enum LoginState {
    SUCCESS = "SUCCESS",
    INITIAL = "INITIAL",
    FAILURE = "FAILURE",
    EMAIL_VERIFICATION_REQUIRED = "EMAIL_VERIFICATION_REQUIRED",
    OWNER_APPROVAL_REQUIRED = "OWNER_APPROVAL_REQUIRED",
    USER_CAPTCHA_REQUIRED = "USER_CAPTCHA_REQUIRED",
    SILENT_CAPTCHA_REQUIRED = "SILENT_CAPTCHA_REQUIRED"
}
interface LoginResults<LK extends LoginState> {
    loginState: LK;
}
interface SuccessState extends LoginResults<LoginState.SUCCESS> {
    data: {
        sessionToken: string;
    };
}
interface InitialState extends LoginResults<LoginState.INITIAL> {
}
interface ErrorState extends LoginResults<LoginState.FAILURE> {
    errorCode?: 'invalidEmail' | 'invalidPassword' | 'resetPassword' | 'missingCaptchaToken' | 'emailAlreadyExists' | 'invalidCaptchaToken';
    error: string;
}
interface EmailVerificationRequiredState extends LoginResults<LoginState.EMAIL_VERIFICATION_REQUIRED> {
    data: {
        stateToken: string;
    };
}
interface OwnerApprovalRequiredState extends LoginResults<LoginState.OWNER_APPROVAL_REQUIRED> {
}
interface SilentCaptchaRequiredState extends LoginResults<LoginState.SILENT_CAPTCHA_REQUIRED> {
    data: {
        stateToken: string;
    };
}
interface UserCaptchaRequiredState extends LoginResults<LoginState.USER_CAPTCHA_REQUIRED> {
    data: {
        stateToken: string;
    };
}
declare enum TokenRole {
    NONE = "none",
    VISITOR = "visitor",
    MEMBER = "member"
}
type StateMachine = InitialState | SuccessState | ErrorState | EmailVerificationRequiredState | OwnerApprovalRequiredState | SilentCaptchaRequiredState | UserCaptchaRequiredState;
type VerificationCode = {
    verificationCode: string;
};
type CalculateNextState<T> = T extends EmailVerificationRequiredState ? VerificationCode : never;
type ProcessableState = EmailVerificationRequiredState;

declare function OAuthStrategy(config: {
    clientId: string;
    tokens?: Tokens;
}): IOAuthStrategy;
interface TokenResponse {
    access_token: string;
    expires_in: number;
    refresh_token: string | null;
    token_type: string;
    scope?: string | null;
}

interface IApiKeyStrategy extends AuthenticationStrategy {
    setSiteId(siteId?: string): void;
    setAccountId(accountId?: string): void;
}
type Context = {
    siteId: string;
    accountId?: string;
} | {
    siteId?: string;
    accountId: string;
};
declare function ApiKeyStrategy({ siteId, accountId, apiKey, }: {
    apiKey: string;
} & Context): IApiKeyStrategy;

export { AccessToken, ApiKeyStrategy, AssertHostMatches, BuildDescriptors, CalculateNextState, Descriptors, IApiKeyStrategy, IOAuthStrategy, LoginParams, LoginState, OAuthStrategy, OauthData, OauthPKCE, ProcessableState, RefreshToken, RegisterParams, StateMachine, Token, TokenResponse, TokenRole, Tokens, WixClient, createClient, decodeText, media };
