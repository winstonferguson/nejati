declare const FilterBuilder_base: {
    new (obj?: {
        filterTree?: any;
        invalidArguments?: any;
        encoder?: any;
    }): {
        [x: string]: any;
        filterTree: any;
        invalidArguments: any;
        encoder: any;
        eq(...args: any[]): any;
        ne(...args: any[]): any;
        ge(...args: any[]): any;
        gt(...args: any[]): any;
        le(...args: any[]): any;
        lt(...args: any[]): any;
        isNotEmpty(field: any): any;
        isEmpty(field: any): any;
        startsWith(...args: any[]): any;
        endsWith(...args: any[]): any;
        contains(...args: any[]): any;
        hasSome(...args: any[]): any;
        hasAll(...args: any[]): any;
        or(orQuery: any): any;
        and(andQuery: any): any;
        not(notQuery: any): any;
        between(field: any, rangeStart: any, rangeEnd: any): any;
        getFilterModel(): any;
        setFilterModel(filterModel: any): any;
        _binaryAnd(filterOperatorSymbol: any, operatorName: any, args: any): any;
        _AndLogicalEquivalence(filterOperatorSymbol: any, operatorName: any, args: any): any;
        _AndStringOperand(filterOperatorName: any, operatorName: any, args: any): any;
        _AndSetOperand(filterOperatorName: any, operatorName: any, args: any): any;
        _makeNewFilter(field: any, filterOperatorName: any, operand: any): any;
        _buildFilter(field: any, filterOperatorName: any, operand: any): {};
        _encode(operand: any): any;
        _copy(filterTree: any, invalidArguments: any): any;
        _filterValidator(filterOperatorName: any): import("./validator").Validator;
    };
    [x: string]: any;
};
export declare class FilterBuilder extends FilterBuilder_base {
    get constructorName(): string;
    _build(): any;
}
export declare function filterBuilder(params?: {}): FilterBuilder;
export default filterBuilder;
//# sourceMappingURL=filter-builder.d.ts.map