import chai from 'chai';
import { filterBuilder, wixDataEncoder } from '..';
var expect = chai.expect;
function inAnd() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return { $and: args };
}
describe('filter', function () {
    var filter = filterBuilder();
    describe('custom encoders', function () {
        it('encode date with wixDataEncoder', function () {
            var now = new Date();
            var filterWithEncoder = filterBuilder({ encoder: wixDataEncoder });
            expect(filterWithEncoder.eq('x', now).getFilterModel()).to.be.eql({
                x: { $date: now.toJSON() },
            });
        });
        it('encode with custom encoder', function () {
            var encoder = function () { return 3; };
            var filterWithEncoder = filterBuilder({ encoder: encoder });
            expect(filterWithEncoder.eq('x', 'a').getFilterModel()).to.be.eql({
                x: 3,
            });
        });
    });
    describe('filter comparison operators', function () {
        it('should produce the correct filter tree', function () {
            expect(filter.eq('x', 1).getFilterModel()).to.be.eql({ x: 1 });
            expect(filter.ne('x', 1).getFilterModel()).to.be.eql({ x: { $ne: 1 } });
            expect(filter.gt('x', 1).getFilterModel()).to.be.eql({ x: { $gt: 1 } });
            expect(filter.ge('x', 1).getFilterModel()).to.be.eql({ x: { $gte: 1 } });
            expect(filter.lt('x', 1).getFilterModel()).to.be.eql({ x: { $lt: 1 } });
            expect(filter.le('x', 1).getFilterModel()).to.be.eql({ x: { $lte: 1 } });
            expect(filter.isNotEmpty('x').getFilterModel()).to.be.eql({
                x: { $ne: null },
            });
            expect(filter.isEmpty('x').getFilterModel()).to.be.eql({ x: null });
            expect(filter.startsWith('x', 'A').getFilterModel()).to.be.eql({
                x: { $startsWith: 'A' },
            });
            expect(filter.endsWith('x', 'A').getFilterModel()).to.be.eql({
                x: { $endsWith: 'A' },
            });
            expect(filter.contains('x', 'A').getFilterModel()).to.be.eql({
                x: { $contains: 'A' },
            });
            expect(filter.hasSome('x', [1, 2]).getFilterModel()).to.be.eql({
                x: { $hasSome: [1, 2] },
            });
            expect(filter.hasSome('x', 1, 2).getFilterModel()).to.be.eql({
                x: { $hasSome: [1, 2] },
            });
            expect(filter.hasAll('x', [1, 2]).getFilterModel()).to.be.eql({
                x: { $hasAll: [1, 2] },
            });
            expect(filter.hasAll('x', 1, 2).getFilterModel()).to.be.eql({
                x: { $hasAll: [1, 2] },
            });
        });
        it('should accept valid arguments for all types of queries', function () {
            expect(function () { return filter.eq('x', 0); }).to.not.throw(Error);
            expect(function () { return filter.ne('x', 0); }).to.not.throw(Error);
            expect(function () { return filter.gt('x', 0); }).to.not.throw(Error);
            expect(function () { return filter.ge('x', 0); }).to.not.throw(Error);
            expect(function () { return filter.lt('x', 0); }).to.not.throw(Error);
            expect(function () { return filter.le('x', 0); }).to.not.throw(Error);
            expect(function () { return filter.startsWith('x', ''); }).to.not.throw(Error);
            expect(function () { return filter.endsWith('x', ''); }).to.not.throw(Error);
            expect(function () { return filter.contains('x', ''); }).to.not.throw(Error);
        });
        var filterTreeGetters = ['_build', 'getFilterModel'];
        filterTreeGetters.forEach(function (filterTreeGetter) {
            describe(filterTreeGetter, function () {
                it('should throw error if builder is called with too little arguments', function () {
                    expect(function () { return filter.eq('x')._build(); }).to.throw('Invalid .eq usage. .eq requires two parameters.');
                    expect(function () { return filter.ne('x')._build(); }).to.throw('Invalid .ne usage. .ne requires two parameters.');
                    expect(function () { return filter.gt('x')._build(); }).to.throw('Invalid .gt usage. .gt requires two parameters.');
                    expect(function () { return filter.ge('x')._build(); }).to.throw('Invalid .ge usage. .ge requires two parameters.');
                    expect(function () { return filter.lt('x')._build(); }).to.throw('Invalid .lt usage. .lt requires two parameters.');
                    expect(function () { return filter.le('x')._build(); }).to.throw('Invalid .le usage. .le requires two parameters.');
                    expect(function () { return filter.startsWith('x')._build(); }).to.throw('Invalid .startsWith usage. .startsWith requires two parameters.');
                    expect(function () { return filter.endsWith('x')._build(); }).to.throw('Invalid .endsWith usage. .endsWith requires two parameters.');
                    expect(function () { return filter.contains('x')._build(); }).to.throw('Invalid .contains usage. .contains requires two parameters.');
                    expect(function () { return filter.isNotEmpty()._build(); }).to.throw('Invalid .isNotEmpty usage. .isNotEmpty requires one parameter.');
                    expect(function () { return filter.isEmpty()._build(); }).to.throw('Invalid .isEmpty usage. .isEmpty requires one parameter.');
                    expect(function () { return filter.isNotEmpty(1)._build(); }).to.throw('Invalid .isNotEmpty field value [Number]. .isNotEmpty field must be a String.');
                    expect(function () { return filter.isEmpty(1)._build(); }).to.throw('Invalid .isEmpty field value [Number]. .isEmpty field must be a String.');
                    expect(function () { return filter.or()._build(); }).to.throw('Invalid .or usage. .or requires one parameter.');
                    expect(function () { return filter.and()._build(); }).to.throw('Invalid .and usage. .and requires one parameter.');
                    expect(function () { return filter.not()._build(); }).to.throw('Invalid .not usage. .not requires one parameter.');
                    expect(function () { return filter.between()._build(); }).to.throw('Invalid .between usage. .between requires three parameters.');
                    expect(function () { return filter.between('x')._build(); }).to.throw('Invalid .between usage. .between requires three parameters.');
                    expect(function () { return filter.between('x', 'x')._build(); }).to.throw('Invalid .between usage. .between requires three parameters.');
                    expect(function () { return filter.hasSome('x')._build(); }).to.throw('Invalid .hasSome usage. .hasSome requires at least two parameters.');
                    expect(function () { return filter.hasAll('x')._build(); }).to.throw('Invalid .hasAll usage. .hasAll requires at least two parameters.');
                });
                it('should validate the type of the other query', function () {
                    expect(function () { return filter.or(null)._build(); }).to.throw('Invalid .or parameter [Null]. .or expects FilterBuilder only.');
                    expect(function () { return filter.or({})._build(); }).to.throw('Invalid .or parameter [Object]. .or expects FilterBuilder only.');
                    expect(function () { return filter.or([])._build(); }).to.throw('Invalid .or parameter [Array]. .or expects FilterBuilder only.');
                    expect(function () { return filter.not(null)._build(); }).to.throw('Invalid .not parameter [Null]. .not expects FilterBuilder only');
                    expect(function () { return filter.not({})._build(); }).to.throw('Invalid .not parameter [Object]. .not expects FilterBuilder only');
                    expect(function () { return filter.not([])._build(); }).to.throw('Invalid .not parameter [Array]. .not expects FilterBuilder only');
                });
                it('should return filter tree', function () {
                    expect(filter.ge('a', 'b').eq('a', 1).le('a', 4)[filterTreeGetter]()).to.be.eql({
                        $and: [{ a: { $gte: 'b' } }, { a: 1 }, { a: { $lte: 4 } }],
                    });
                    expect(filter
                        .eq('a', 1)
                        .lt('a', 2)
                        .or(filter.ge('a', 'b'))[filterTreeGetter]()).to.be.eql({
                        $or: [
                            { $and: [{ a: 1 }, { a: { $lt: 2 } }] },
                            { a: { $gte: 'b' } },
                        ],
                    });
                    expect(filter.eq('a', 3).ne('a', 2)[filterTreeGetter]()).to.be.eql(inAnd({ a: 3 }, { a: { $ne: 2 } }));
                });
            });
        });
    });
    describe('filter.or', function () {
        it('should produce correct filter tree', function () {
            var f = filter.eq('x', 1).or(filter.eq('y', 2));
            expect(f.getFilterModel()).to.be.eql({ $or: [{ x: 1 }, { y: 2 }] });
            expect(f.eq('z', 3).getFilterModel()).to.be.eql(inAnd({ $or: [{ x: 1 }, { y: 2 }] }, { z: 3 }));
        });
        it('should produce valid query if used directly', function () {
            var f = filter.or(filter.eq('x', 1));
            expect(f.filterTree).to.be.eql(inAnd({ $or: [inAnd({ x: 1 })] }));
        });
    });
    describe('filter.and', function () {
        it('should produce correct filter tree', function () {
            var f = filter.eq('x', 1).and(filter.eq('y', 2));
            expect(f.getFilterModel()).to.be.eql({ x: 1, y: 2 });
            expect(f.eq('x', 3).getFilterModel()).to.be.eql({
                $and: [{ x: 1 }, { y: 2 }, { x: 3 }],
            });
        });
        it('should produce valid query if used directly', function () {
            var f = filter.and(filter.eq('x', 1));
            expect(f.filterTree).to.be.eql(inAnd({ $and: [{ x: 1 }] }));
        });
    });
    describe('filter.not', function () {
        it('should produce the correct filter tree', function () {
            var f = filter.eq('x', 1).not(filter.eq('y', 2).eq('z', 3));
            expect(f.getFilterModel()).to.be.eql(inAnd({ x: 1 }, { $not: [{ y: 2, z: 3 }] }));
        });
    });
    describe('between', function () {
        it('should produce the correct filter tree for numbers', function () {
            var f = filter.between('field', 1, 3);
            expect(f.getFilterModel()).to.be.eql(inAnd({ field: { $gte: 1 } }, { field: { $lt: 3 } }));
        });
        it('should produce the correct filter tree for dates', function () {
            var startDate = new Date();
            var endDate = new Date();
            endDate.setYear(startDate.getYear() + 1);
            var f = filter.between('field', startDate, endDate);
            expect(f.getFilterModel()).to.be.eql(inAnd({ field: { $gte: startDate } }, { field: { $lt: endDate } }));
        });
        it('should produce the correct filter tree for strings', function () {
            var f = filter.between('field', 'start', 'end');
            expect(f.getFilterModel()).to.be.eql(inAnd({ field: { $gte: 'start' } }, { field: { $lt: 'end' } }));
        });
        describe('validation', function () {
            var filterTreeGetters = ['_build', 'getFilterModel'];
            filterTreeGetters.forEach(function (filterTreeGetter) {
                describe(filterTreeGetter, function () {
                    var invalidExamples = [
                        [1, new Date(), 'Number', 'Date'],
                        [1, '2015-02-02', 'Number', 'String'],
                        [new Date(), '2015-01-01', 'Date', 'String'],
                        [null, new Date(), 'Null', 'Date'],
                        [undefined, new Date(), 'Undefined', 'Date'],
                    ];
                    invalidExamples.forEach(function (_a) {
                        var first = _a[0], second = _a[1], firstType = _a[2], secondType = _a[3];
                        it("should reject invalid query.between('x'," +
                            first +
                            ',' +
                            second +
                            ')', function () {
                            expect(function () {
                                filter.between('x', first, second)[filterTreeGetter]();
                            }).to.throw("Invalid .between parameter values [".concat(firstType, "] and [").concat(secondType, "]. Both parameters must be of the same type."));
                            expect(function () {
                                filter.between('x', second, first)[filterTreeGetter]();
                            }).to.throw("Invalid .between parameter values [".concat(secondType, "] and [").concat(firstType, "]. Both parameters must be of the same type."));
                        });
                    });
                });
            });
        });
    });
    describe('setFilterModel', function () {
        it('should return a new filter instance with the new filterTree value set', function () {
            var newFilter = filter.setFilterModel(inAnd({ a: { $gte: 'b' } }, { a: 1 }, { a: { $lte: 4 } }));
            expect(newFilter).not.to.equal(filter);
        });
        it('should set filterTree to the filterModel value when the value is a valid filterTree', function () {
            var newFilter = filter.setFilterModel(inAnd({ a: { $gte: 'b' } }, { a: 1 }, { a: { $lte: 4 } }));
            expect(newFilter.getFilterModel()).to.be.eql(inAnd({ a: { $gte: 'b' } }, { a: 1 }, { a: { $lte: 4 } }));
        });
        it('should set filterTree to the filterModel value even when the value is not a valid filterTree', function () {
            var newFilter = filter.setFilterModel(5);
            expect(newFilter.getFilterModel()).to.be.eql(5);
        });
        it('should set invalidArguments to an empty array when the value is a valid filterTree', function () {
            var invalidFilter = filter.eq('x');
            var newFilter = invalidFilter.setFilterModel(inAnd({ a: { $gte: 'b' } }, { a: 1 }, { a: { $lte: 4 } }));
            expect(newFilter.invalidArguments).to.be.eql([]);
        });
        it('should set invalidArguments to an empty array when the value is not a valid filterTree', function () {
            var invalidFilter = filter.eq('x');
            var newFilter = invalidFilter.setFilterModel(5);
            expect(newFilter.invalidArguments).to.be.eql([]);
        });
    });
});
//# sourceMappingURL=filter.spec.js.map