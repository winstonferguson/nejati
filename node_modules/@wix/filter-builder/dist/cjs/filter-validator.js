"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.FilterValidator = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typeUtils = require("./type-utils");
var _clone = _interopRequireDefault(require("./clone"));
class FilterValidator {
  constructor(operatorName, previousInvalidArguments, ctor) {
    (0, _defineProperty2.default)(this, "ctor", void 0);
    (0, _defineProperty2.default)(this, "_invalidArguments", void 0);
    (0, _defineProperty2.default)(this, "_validations", void 0);
    (0, _defineProperty2.default)(this, "operatorName", void 0);
    this._validations = [];
    this.operatorName = operatorName;
    this.ctor = ctor;
    this._invalidArguments = (0, _clone.default)(previousInvalidArguments);
  }
  typeIsString(value) {
    return this.addValidation(() => (0, _typeUtils.isString)(value), () => `Invalid ${this.operatorName} parameter value [${(0, _typeUtils.typeForDisplay)(value)}]. ${this.operatorName} parameter must be a String.`);
  }
  typeIsStringNumberOrDate(value) {
    return this.addValidation(() => isDateStringOrNumber(value), () => `Invalid ${this.operatorName} parameter value [${(0, _typeUtils.typeForDisplay)(value)}]. Valid ${this.operatorName} parameter types are String, Number or Date.`);
  }
  sameType(first, second) {
    return this.addValidation(() => (0, _typeUtils.typeForDisplay)(first) === (0, _typeUtils.typeForDisplay)(second), () => `Invalid ${this.operatorName} parameter values [${(0, _typeUtils.typeForDisplay)(first)}] and [${(0, _typeUtils.typeForDisplay)(second)}]. Both parameters must be of the same type.`);
  }
  typeIsStringNumberOrDateForAll(values) {
    return this.addValidation(() => values.every(isDateStringOrNumber), () => `Invalid ${this.operatorName} usage. ${this.operatorName} supports only Number, String or Date items.`);
  }
  validFieldName(field) {
    return this.addValidation(() => (0, _typeUtils.isString)(field), () => `Invalid ${this.operatorName} field value [${(0, _typeUtils.typeForDisplay)(field)}]. ${this.operatorName} field must be a String.`);
  }
  isInstanceOfSameClass(obj) {
    return this.addValidation(() => obj instanceof this.ctor, () => `Invalid ${this.operatorName} parameter [${(0, _typeUtils.typeForDisplay)(obj)}]. ${this.operatorName} expects FilterBuilder only.`);
  }
  arityIsOne(args) {
    return this.addValidation(() => args.length === 1, () => `Invalid ${this.operatorName} usage. ${this.operatorName} requires one parameter.`);
  }
  arityIsTwo(args) {
    return this.addValidation(() => args.length === 2, () => `Invalid ${this.operatorName} usage. ${this.operatorName} requires two parameters.`);
  }
  arityIsThree(args) {
    return this.addValidation(() => args.length === 3, () => `Invalid ${this.operatorName} usage. ${this.operatorName} requires three parameters.`);
  }
  arityIsAtLeastTwo(args) {
    return this.addValidation(() => args.length >= 2, () => `Invalid ${this.operatorName} usage. ${this.operatorName} requires at least two parameters.`);
  }
  addValidation(predicateFn, messageFn) {
    this._validations.push({
      predicateFn,
      messageFn
    });
    return this;
  }
  validateAndAggregate() {
    const valid = this._validations.every(({
      predicateFn,
      messageFn
    }) => this._appendIfInvalid(predicateFn(), messageFn()));
    return [this._invalidArguments, valid];
  }
  _appendIfInvalid(valid, message) {
    if (!valid) {
      this._invalidArguments.push(message);
      return false;
    }
    return true;
  }
}
exports.FilterValidator = FilterValidator;
function isDateStringOrNumber(value) {
  return (0, _typeUtils.isString)(value) || (0, _typeUtils.isNumber)(value) || (0, _typeUtils.isDate)(value);
}
//# sourceMappingURL=filter-validator.js.map