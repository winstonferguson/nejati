"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _typeUtils = require("./type-utils");
var _clone = _interopRequireDefault(require("./clone"));
var _filterValidator = require("./filter-validator");
var _queryOptimiser = require("./query-optimiser");
const filterMixin = (Base = class {}) => class extends Base {
  constructor(obj = {}) {
    super(obj);
    (0, _defineProperty2.default)(this, "filterTree", void 0);
    (0, _defineProperty2.default)(this, "invalidArguments", void 0);
    (0, _defineProperty2.default)(this, "encoder", void 0);
    this.filterTree = obj.filterTree || {
      $and: []
    };
    this.invalidArguments = obj.invalidArguments || [];
    this.encoder = obj.encoder || {};
  }
  eq(...args) {
    return this._binaryAnd('$eq', '.eq', args);
  }
  ne(...args) {
    return this._binaryAnd('$ne', '.ne', args);
  }
  ge(...args) {
    return this._AndLogicalEquivalence('$gte', '.ge', args);
  }
  gt(...args) {
    return this._AndLogicalEquivalence('$gt', '.gt', args);
  }
  le(...args) {
    return this._AndLogicalEquivalence('$lte', '.le', args);
  }
  lt(...args) {
    return this._AndLogicalEquivalence('$lt', '.lt', args);
  }
  isNotEmpty(field) {
    const _this$_filterValidato = this._filterValidator('.isNotEmpty').arityIsOne(arguments).validFieldName(field).validateAndAggregate(),
      newInvalidArguments = _this$_filterValidato[0],
      valid = _this$_filterValidato[1];
    if (valid) {
      return this.ne(field, null);
    }
    return this._copy(this.filterTree, newInvalidArguments);
  }
  isEmpty(field) {
    const _this$_filterValidato2 = this._filterValidator('.isEmpty').arityIsOne(arguments).validFieldName(field).validateAndAggregate(),
      newInvalidArguments = _this$_filterValidato2[0],
      valid = _this$_filterValidato2[1];
    if (valid) {
      return this.eq(field, null);
    }
    return this._copy(this.filterTree, newInvalidArguments);
  }
  startsWith(...args) {
    return this._AndStringOperand('$startsWith', '.startsWith', args);
  }
  endsWith(...args) {
    return this._AndStringOperand('$endsWith', '.endsWith', args);
  }
  contains(...args) {
    return this._AndStringOperand('$contains', '.contains', args);
  }
  hasSome(...args) {
    return this._AndSetOperand('$hasSome', '.hasSome', args);
  }
  hasAll(...args) {
    return this._AndSetOperand('$hasAll', '.hasAll', args);
  }
  or(orQuery) {
    const _this$_filterValidato3 = this._filterValidator('.or').arityIsOne(arguments).isInstanceOfSameClass(orQuery).validateAndAggregate(),
      newInvalidArguments = _this$_filterValidato3[0],
      valid = _this$_filterValidato3[1];
    if (valid) {
      const prefix = isEmptyAnd(this.filterTree) ? [] : [this.filterTree];
      return this._copy(inAnd({
        $or: [...prefix, orQuery.filterTree]
      }), newInvalidArguments.concat(orQuery.invalidArguments));
    } else {
      return this._copy(this.filterTree, newInvalidArguments);
    }
  }
  and(andQuery) {
    const _this$_filterValidato4 = this._filterValidator('.and').arityIsOne(arguments).isInstanceOfSameClass(andQuery).validateAndAggregate(),
      newInvalidArguments = _this$_filterValidato4[0],
      valid = _this$_filterValidato4[1];
    if (valid) {
      const prefix = isEmptyAnd(this.filterTree) ? [] : [this.filterTree];
      return this._copy(inAnd(...prefix, andQuery.filterTree), newInvalidArguments.concat(andQuery.invalidArguments));
    } else {
      return this._copy(this.filterTree, newInvalidArguments);
    }
  }
  not(notQuery) {
    const _this$_filterValidato5 = this._filterValidator('.not').arityIsOne(arguments).isInstanceOfSameClass(notQuery).validateAndAggregate(),
      newInvalidArguments = _this$_filterValidato5[0],
      valid = _this$_filterValidato5[1];
    if (valid) {
      const newFilterTree = (0, _clone.default)(this.filterTree);
      const notClause = {
        $not: [notQuery.filterTree]
      };
      const resultingFilter = inAndOptimized(newFilterTree, notClause);
      return this._copy(resultingFilter, newInvalidArguments.concat(notQuery.invalidArguments));
    } else {
      return this._copy(this.filterTree, newInvalidArguments);
    }
  }
  between(field, rangeStart, rangeEnd) {
    const _this$_filterValidato6 = this._filterValidator('.between').arityIsThree(arguments).sameType(rangeStart, rangeEnd).typeIsStringNumberOrDate(rangeStart).typeIsStringNumberOrDate(rangeEnd).validateAndAggregate(),
      newInvalidArguments = _this$_filterValidato6[0],
      valid = _this$_filterValidato6[1];
    if (valid) {
      return this.ge(field, rangeStart).lt(field, rangeEnd);
    }
    return this._copy(this.filterTree, newInvalidArguments);
  }
  getFilterModel() {
    if (this.invalidArguments.length > 0) {
      throw new Error(this.invalidArguments.join(' '));
    }
    return (0, _queryOptimiser.optimisedQuery)(this.filterTree);
  }
  setFilterModel(filterModel) {
    return this._copy(filterModel, []);
  }
  _binaryAnd(filterOperatorSymbol, operatorName, args) {
    const _Array$prototype$slic = Array.prototype.slice.call(args),
      field = _Array$prototype$slic[0],
      operand = _Array$prototype$slic[1];
    const _this$_filterValidato7 = this._filterValidator(operatorName).arityIsTwo(args).validFieldName(field).validateAndAggregate(),
      newInvalidArguments = _this$_filterValidato7[0];
    const newFilterTree = this._makeNewFilter(field, filterOperatorSymbol, operand);
    return this._copy(newFilterTree, newInvalidArguments);
  }
  _AndLogicalEquivalence(filterOperatorSymbol, operatorName, args) {
    const _Array$prototype$slic2 = Array.prototype.slice.call(args),
      field = _Array$prototype$slic2[0],
      operand = _Array$prototype$slic2[1];
    const _this$_filterValidato8 = this._filterValidator(operatorName).arityIsTwo(args).validFieldName(field).typeIsStringNumberOrDate(operand).validateAndAggregate(),
      newInvalidArguments = _this$_filterValidato8[0];
    const newFilterTree = this._makeNewFilter(field, filterOperatorSymbol, operand);
    return this._copy(newFilterTree, newInvalidArguments);
  }
  _AndStringOperand(filterOperatorName, operatorName, args) {
    const _Array$prototype$slic3 = Array.prototype.slice.call(args),
      field = _Array$prototype$slic3[0],
      operand = _Array$prototype$slic3[1];
    const _this$_filterValidato9 = this._filterValidator(operatorName).arityIsTwo(args).validFieldName(field).typeIsString(operand).validateAndAggregate(),
      newInvalidArguments = _this$_filterValidato9[0];
    const newFilterTree = this._makeNewFilter(field, filterOperatorName, operand);
    return this._copy(newFilterTree, newInvalidArguments);
  }
  _AndSetOperand(filterOperatorName, operatorName, args) {
    const _Array$prototype$slic4 = Array.prototype.slice.call(args),
      field = _Array$prototype$slic4[0],
      rawOperands = _Array$prototype$slic4.slice(1);
    const operands = (0, _typeUtils.isArray)(rawOperands[0]) ? rawOperands[0] : rawOperands;
    const _this$_filterValidato10 = this._filterValidator(operatorName).arityIsAtLeastTwo(args).validFieldName(field).typeIsStringNumberOrDateForAll(operands).validateAndAggregate(),
      newInvalidArguments = _this$_filterValidato10[0];
    const newFilterTree = this._makeNewFilter(field, filterOperatorName, operands);
    return this._copy(newFilterTree, newInvalidArguments);
  }
  _makeNewFilter(field, filterOperatorName, operand) {
    const newFilterTree = (0, _clone.default)(this.filterTree);

    // filters with 'undefined' value are lost during serialization,
    // e.g. { val: { $ne: undefined } | translates to { val: {} }
    // Replacing 'undefined' with 'null' retains the filter.
    const serializableOperand = operand === undefined ? null : operand;
    const newFilter = this._buildFilter(field, filterOperatorName, serializableOperand);
    if ((0, _typeUtils.isArray)(newFilterTree.$and)) {
      newFilterTree.$and.push(newFilter);
      return newFilterTree;
    } else {
      const result = isEmptyObject(newFilterTree) ? inAnd(newFilter) : inAnd(newFilterTree, newFilter);
      return result;
    }
  }
  _buildFilter(field, filterOperatorName, operand) {
    if (filterOperatorName !== '$eq') {
      const newFilter = {};
      newFilter[field] = {};
      newFilter[field][filterOperatorName] = this._encode(operand);
      return newFilter;
    } else {
      const newFilter = {};
      newFilter[field] = this._encode(operand);
      return newFilter;
    }
  }
  _encode(operand) {
    if ((0, _typeUtils.isFunction)(this.encoder)) {
      return this.encoder(operand);
    } else {
      return operand;
    }
  }
  _copy(filterTree, invalidArguments) {
    // @ts-ignore-next-line
    return new this.constructor({
      ...this,
      filterTree,
      invalidArguments
    });
  }
  _filterValidator(filterOperatorName) {
    return new _filterValidator.FilterValidator(filterOperatorName, this.invalidArguments, this.constructor);
  }
};
function isConjunctiveFormFilter(filterTree) {
  return (0, _typeUtils.isArray)(filterTree.$and);
}
function isEmptyObject(obj) {
  return Object.keys(obj).length === 0;
}
function inAnd(...args) {
  return {
    $and: args
  };
}
function inAndOptimized(...args) {
  return {
    $and: args.reduce((aggr, val) => isConjunctiveFormFilter(val) ? aggr.concat(val.$and) : aggr.concat([val]), [])
  };
}
function isEmptyAnd(node) {
  return node && node.$and && node.$and.length === 0;
}
var _default = filterMixin;
exports.default = _default;
//# sourceMappingURL=filter-mixin.js.map