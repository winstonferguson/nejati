"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _chai = _interopRequireDefault(require("chai"));
var _queryOptimiser = require("../query-optimiser");
const expect = _chai.default.expect;
describe('query optimisations', () => {
  describe('$and with single element', () => {
    testCase('gets unwrapped', {
      $and: [{
        a: 1
      }]
    }, {
      a: 1
    });
  });
  describe('$and with object pieces', () => {
    testCase('gets unwrapped as object', {
      $and: [{
        a: 1
      }, {
        b: 2
      }]
    }, {
      a: 1,
      b: 2
    });
    testCase('remains if keys overlap', {
      $and: [{
        a: 1
      }, {
        b: 2
      }, {
        a: 1
      }]
    }, {
      $and: [{
        a: 1
      }, {
        b: 2
      }, {
        a: 1
      }]
    });
    testCase("nested operators don't get merged", {
      $and: [{
        a: 1
      }, {
        $lte: 4
      }, {
        b: 2
      }]
    }, {
      $and: [{
        a: 1,
        b: 2
      }, {
        $lte: 4
      }]
    });
    it('merges empty objects', () => {
      const actualOutput = (0, _queryOptimiser.optimisedQuery)({
        $and: [{}, {}, {}]
      });
      expect(actualOutput).to.be.eql({});
    });
  });
  describe('empty $and', () => {
    testCase('is removed', {
      $and: [{
        $and: []
      }]
    }, {});
    testCase('is removed when nested', {
      $and: [{
        $and: []
      }]
    }, {});
  });
  describe('nested $and', () => {
    testCase('get flattened', {
      $and: [{
        a: 1
      }, {
        $and: [{
          a: 1
        }]
      }, {
        $and: [{
          a: 1
        }, {
          a: 1
        }]
      }]
    }, {
      $and: [{
        a: 1
      }, {
        a: 1
      }, {
        a: 1
      }, {
        a: 1
      }]
    });
  });
  describe('nested $or', () => {
    testCase('get flattened', {
      $or: [{
        a: 1
      }, {
        $or: [{
          a: 1
        }]
      }, {
        $or: [{
          a: 1
        }, {
          a: 1
        }]
      }]
    }, {
      $or: [{
        a: 1
      }, {
        a: 1
      }, {
        a: 1
      }, {
        a: 1
      }]
    });
  });
  describe('type compatibility', () => {
    testCase('maintains date objects', {
      x: [new Date('2020-01-01T00:00:00Z')]
    }, {
      x: [new Date('2020-01-01T00:00:00Z')]
    });
  });
});
function testCase(description, input, expectedOutput) {
  it(description, () => {
    const actualOutput = (0, _queryOptimiser.optimisedQuery)(input);
    expect(actualOutput).to.be.eql(expectedOutput);
  });
}
//# sourceMappingURL=query-optimizer.spec.js.map