"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _chai = _interopRequireDefault(require("chai"));
var _ = require("..");
const expect = _chai.default.expect;
function inAnd(...args) {
  return {
    $and: args
  };
}
describe('filter', function () {
  const filter = (0, _.filterBuilder)();
  describe('custom encoders', function () {
    it('encode date with wixDataEncoder', function () {
      const now = new Date();
      const filterWithEncoder = (0, _.filterBuilder)({
        encoder: _.wixDataEncoder
      });
      expect(filterWithEncoder.eq('x', now).getFilterModel()).to.be.eql({
        x: {
          $date: now.toJSON()
        }
      });
    });
    it('encode with custom encoder', function () {
      const encoder = () => 3;
      const filterWithEncoder = (0, _.filterBuilder)({
        encoder
      });
      expect(filterWithEncoder.eq('x', 'a').getFilterModel()).to.be.eql({
        x: 3
      });
    });
  });
  describe('filter comparison operators', function () {
    it('should produce the correct filter tree', function () {
      expect(filter.eq('x', 1).getFilterModel()).to.be.eql({
        x: 1
      });
      expect(filter.ne('x', 1).getFilterModel()).to.be.eql({
        x: {
          $ne: 1
        }
      });
      expect(filter.gt('x', 1).getFilterModel()).to.be.eql({
        x: {
          $gt: 1
        }
      });
      expect(filter.ge('x', 1).getFilterModel()).to.be.eql({
        x: {
          $gte: 1
        }
      });
      expect(filter.lt('x', 1).getFilterModel()).to.be.eql({
        x: {
          $lt: 1
        }
      });
      expect(filter.le('x', 1).getFilterModel()).to.be.eql({
        x: {
          $lte: 1
        }
      });
      expect(filter.isNotEmpty('x').getFilterModel()).to.be.eql({
        x: {
          $ne: null
        }
      });
      expect(filter.isEmpty('x').getFilterModel()).to.be.eql({
        x: null
      });
      expect(filter.startsWith('x', 'A').getFilterModel()).to.be.eql({
        x: {
          $startsWith: 'A'
        }
      });
      expect(filter.endsWith('x', 'A').getFilterModel()).to.be.eql({
        x: {
          $endsWith: 'A'
        }
      });
      expect(filter.contains('x', 'A').getFilterModel()).to.be.eql({
        x: {
          $contains: 'A'
        }
      });
      expect(filter.hasSome('x', [1, 2]).getFilterModel()).to.be.eql({
        x: {
          $hasSome: [1, 2]
        }
      });
      expect(filter.hasSome('x', 1, 2).getFilterModel()).to.be.eql({
        x: {
          $hasSome: [1, 2]
        }
      });
      expect(filter.hasAll('x', [1, 2]).getFilterModel()).to.be.eql({
        x: {
          $hasAll: [1, 2]
        }
      });
      expect(filter.hasAll('x', 1, 2).getFilterModel()).to.be.eql({
        x: {
          $hasAll: [1, 2]
        }
      });
    });
    it('should accept valid arguments for all types of queries', function () {
      expect(() => filter.eq('x', 0)).to.not.throw(Error);
      expect(() => filter.ne('x', 0)).to.not.throw(Error);
      expect(() => filter.gt('x', 0)).to.not.throw(Error);
      expect(() => filter.ge('x', 0)).to.not.throw(Error);
      expect(() => filter.lt('x', 0)).to.not.throw(Error);
      expect(() => filter.le('x', 0)).to.not.throw(Error);
      expect(() => filter.startsWith('x', '')).to.not.throw(Error);
      expect(() => filter.endsWith('x', '')).to.not.throw(Error);
      expect(() => filter.contains('x', '')).to.not.throw(Error);
    });
    const filterTreeGetters = ['_build', 'getFilterModel'];
    filterTreeGetters.forEach(function (filterTreeGetter) {
      describe(filterTreeGetter, function () {
        it('should throw error if builder is called with too little arguments', function () {
          expect(() => filter.eq('x')._build()).to.throw('Invalid .eq usage. .eq requires two parameters.');
          expect(() => filter.ne('x')._build()).to.throw('Invalid .ne usage. .ne requires two parameters.');
          expect(() => filter.gt('x')._build()).to.throw('Invalid .gt usage. .gt requires two parameters.');
          expect(() => filter.ge('x')._build()).to.throw('Invalid .ge usage. .ge requires two parameters.');
          expect(() => filter.lt('x')._build()).to.throw('Invalid .lt usage. .lt requires two parameters.');
          expect(() => filter.le('x')._build()).to.throw('Invalid .le usage. .le requires two parameters.');
          expect(() => filter.startsWith('x')._build()).to.throw('Invalid .startsWith usage. .startsWith requires two parameters.');
          expect(() => filter.endsWith('x')._build()).to.throw('Invalid .endsWith usage. .endsWith requires two parameters.');
          expect(() => filter.contains('x')._build()).to.throw('Invalid .contains usage. .contains requires two parameters.');
          // @ts-expect-error
          expect(() => filter.isNotEmpty()._build()).to.throw('Invalid .isNotEmpty usage. .isNotEmpty requires one parameter.');
          // @ts-expect-error
          expect(() => filter.isEmpty()._build()).to.throw('Invalid .isEmpty usage. .isEmpty requires one parameter.');
          expect(() => filter.isNotEmpty(1)._build()).to.throw('Invalid .isNotEmpty field value [Number]. .isNotEmpty field must be a String.');
          expect(() => filter.isEmpty(1)._build()).to.throw('Invalid .isEmpty field value [Number]. .isEmpty field must be a String.');
          // @ts-expect-error
          expect(() => filter.or()._build()).to.throw('Invalid .or usage. .or requires one parameter.');
          // @ts-expect-error
          expect(() => filter.and()._build()).to.throw('Invalid .and usage. .and requires one parameter.');
          // @ts-expect-error
          expect(() => filter.not()._build()).to.throw('Invalid .not usage. .not requires one parameter.');
          // @ts-expect-error
          expect(() => filter.between()._build()).to.throw('Invalid .between usage. .between requires three parameters.');
          // @ts-expect-error
          expect(() => filter.between('x')._build()).to.throw('Invalid .between usage. .between requires three parameters.');
          // @ts-expect-error
          expect(() => filter.between('x', 'x')._build()).to.throw('Invalid .between usage. .between requires three parameters.');
          expect(() => filter.hasSome('x')._build()).to.throw('Invalid .hasSome usage. .hasSome requires at least two parameters.');
          expect(() => filter.hasAll('x')._build()).to.throw('Invalid .hasAll usage. .hasAll requires at least two parameters.');
        });
        it('should validate the type of the other query', function () {
          expect(() => filter.or(null)._build()).to.throw('Invalid .or parameter [Null]. .or expects FilterBuilder only.');
          expect(() => filter.or({})._build()).to.throw('Invalid .or parameter [Object]. .or expects FilterBuilder only.');
          expect(() => filter.or([])._build()).to.throw('Invalid .or parameter [Array]. .or expects FilterBuilder only.');
          expect(() => filter.not(null)._build()).to.throw('Invalid .not parameter [Null]. .not expects FilterBuilder only');
          expect(() => filter.not({})._build()).to.throw('Invalid .not parameter [Object]. .not expects FilterBuilder only');
          expect(() => filter.not([])._build()).to.throw('Invalid .not parameter [Array]. .not expects FilterBuilder only');
        });
        it('should return filter tree', function () {
          expect(filter.ge('a', 'b').eq('a', 1).le('a', 4)[filterTreeGetter]()).to.be.eql({
            $and: [{
              a: {
                $gte: 'b'
              }
            }, {
              a: 1
            }, {
              a: {
                $lte: 4
              }
            }]
          });
          expect(filter.eq('a', 1).lt('a', 2).or(filter.ge('a', 'b'))[filterTreeGetter]()).to.be.eql({
            $or: [{
              $and: [{
                a: 1
              }, {
                a: {
                  $lt: 2
                }
              }]
            }, {
              a: {
                $gte: 'b'
              }
            }]
          });
          expect(filter.eq('a', 3).ne('a', 2)[filterTreeGetter]()).to.be.eql(inAnd({
            a: 3
          }, {
            a: {
              $ne: 2
            }
          }));
        });
      });
    });
  });
  describe('filter.or', function () {
    it('should produce correct filter tree', function () {
      const f = filter.eq('x', 1).or(filter.eq('y', 2));
      expect(f.getFilterModel()).to.be.eql({
        $or: [{
          x: 1
        }, {
          y: 2
        }]
      });
      expect(f.eq('z', 3).getFilterModel()).to.be.eql(inAnd({
        $or: [{
          x: 1
        }, {
          y: 2
        }]
      }, {
        z: 3
      }));
    });
    it('should produce valid query if used directly', function () {
      const f = filter.or(filter.eq('x', 1));
      expect(f.filterTree).to.be.eql(inAnd({
        $or: [inAnd({
          x: 1
        })]
      }));
    });
  });
  describe('filter.and', function () {
    it('should produce correct filter tree', function () {
      const f = filter.eq('x', 1).and(filter.eq('y', 2));
      expect(f.getFilterModel()).to.be.eql({
        x: 1,
        y: 2
      });
      expect(f.eq('x', 3).getFilterModel()).to.be.eql({
        $and: [{
          x: 1
        }, {
          y: 2
        }, {
          x: 3
        }]
      });
    });
    it('should produce valid query if used directly', function () {
      const f = filter.and(filter.eq('x', 1));
      expect(f.filterTree).to.be.eql(inAnd({
        $and: [{
          x: 1
        }]
      }));
    });
  });
  describe('filter.not', function () {
    it('should produce the correct filter tree', function () {
      const f = filter.eq('x', 1).not(filter.eq('y', 2).eq('z', 3));
      expect(f.getFilterModel()).to.be.eql(inAnd({
        x: 1
      }, {
        $not: [{
          y: 2,
          z: 3
        }]
      }));
    });
  });
  describe('between', function () {
    it('should produce the correct filter tree for numbers', function () {
      const f = filter.between('field', 1, 3);
      expect(f.getFilterModel()).to.be.eql(inAnd({
        field: {
          $gte: 1
        }
      }, {
        field: {
          $lt: 3
        }
      }));
    });
    it('should produce the correct filter tree for dates', function () {
      const startDate = new Date();
      const endDate = new Date();
      endDate.setYear(startDate.getYear() + 1);
      const f = filter.between('field', startDate, endDate);
      expect(f.getFilterModel()).to.be.eql(inAnd({
        field: {
          $gte: startDate
        }
      }, {
        field: {
          $lt: endDate
        }
      }));
    });
    it('should produce the correct filter tree for strings', function () {
      const f = filter.between('field', 'start', 'end');
      expect(f.getFilterModel()).to.be.eql(inAnd({
        field: {
          $gte: 'start'
        }
      }, {
        field: {
          $lt: 'end'
        }
      }));
    });
    describe('validation', function () {
      const filterTreeGetters = ['_build', 'getFilterModel'];
      filterTreeGetters.forEach(function (filterTreeGetter) {
        describe(filterTreeGetter, function () {
          const invalidExamples = [[1, new Date(), 'Number', 'Date'], [1, '2015-02-02', 'Number', 'String'], [new Date(), '2015-01-01', 'Date', 'String'], [null, new Date(), 'Null', 'Date'], [undefined, new Date(), 'Undefined', 'Date']];
          invalidExamples.forEach(function ([first, second, firstType, secondType]) {
            it("should reject invalid query.between('x'," + first + ',' + second + ')', function () {
              expect(function () {
                filter.between('x', first, second)[filterTreeGetter]();
              }).to.throw(`Invalid .between parameter values [${firstType}] and [${secondType}]. Both parameters must be of the same type.`);
              expect(function () {
                filter.between('x', second, first)[filterTreeGetter]();
              }).to.throw(`Invalid .between parameter values [${secondType}] and [${firstType}]. Both parameters must be of the same type.`);
            });
          });
        });
      });
    });
  });
  describe('setFilterModel', function () {
    it('should return a new filter instance with the new filterTree value set', function () {
      const newFilter = filter.setFilterModel(inAnd({
        a: {
          $gte: 'b'
        }
      }, {
        a: 1
      }, {
        a: {
          $lte: 4
        }
      }));
      expect(newFilter).not.to.equal(filter);
    });
    it('should set filterTree to the filterModel value when the value is a valid filterTree', function () {
      const newFilter = filter.setFilterModel(inAnd({
        a: {
          $gte: 'b'
        }
      }, {
        a: 1
      }, {
        a: {
          $lte: 4
        }
      }));
      expect(newFilter.getFilterModel()).to.be.eql(inAnd({
        a: {
          $gte: 'b'
        }
      }, {
        a: 1
      }, {
        a: {
          $lte: 4
        }
      }));
    });
    it('should set filterTree to the filterModel value even when the value is not a valid filterTree', function () {
      const newFilter = filter.setFilterModel(5);
      expect(newFilter.getFilterModel()).to.be.eql(5);
    });
    it('should set invalidArguments to an empty array when the value is a valid filterTree', function () {
      const invalidFilter = filter.eq('x');
      const newFilter = invalidFilter.setFilterModel(inAnd({
        a: {
          $gte: 'b'
        }
      }, {
        a: 1
      }, {
        a: {
          $lte: 4
        }
      }));
      expect(newFilter.invalidArguments).to.be.eql([]);
    });
    it('should set invalidArguments to an empty array when the value is not a valid filterTree', function () {
      const invalidFilter = filter.eq('x');
      const newFilter = invalidFilter.setFilterModel(5);
      expect(newFilter.invalidArguments).to.be.eql([]);
    });
  });
});
//# sourceMappingURL=filter.spec.js.map