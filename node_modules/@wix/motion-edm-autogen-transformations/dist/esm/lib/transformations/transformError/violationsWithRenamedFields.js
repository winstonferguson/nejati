import { __assign } from "tslib";
import { reduceTransformation, transformations, } from '@wix/motion-edm-autogen-transformations-core';
import _ from 'lodash';
import { withRenamedArgument } from './withRenamedArgument';
var JS_SINGLE_ARG_UNCHANGED = transformations.JS_SINGLE_ARG_UNCHANGED;
var chain = _.chain, some = _.some;
var collectArgumentExpressions = function (transformation) {
    var accumulator = {
        spreadPathsToArguments: {},
        explicitPathsToArguments: {},
    };
    reduceTransformation(transformation, {
        visitors: {
            NestedSpreadExpression: function (acc, spreadOperatorParentPath, argumentExpressionToSpread) {
                acc.spreadPathsToArguments[spreadOperatorParentPath] =
                    argumentExpressionToSpread;
            },
            NestedSimpleTransformationExpression: function (acc, path, simpleTransformationExpression) {
                acc.explicitPathsToArguments[path] = simpleTransformationExpression;
            },
            CustomFunctionExpression: function (acc, path, functionName, _a) {
                var transformationPath = _a[0], wrappingName = _a[1];
                switch (functionName) {
                    case 'wrap':
                        acc.explicitPathsToArguments["".concat(path, ".").concat(wrappingName)] =
                            transformationPath;
                        break;
                    default:
                    // ignore
                }
            },
        },
        accumulator: accumulator,
    });
    return accumulator;
};
var violationsWithRenamedFields = function (_a) {
    var transformation = _a.transformation, fieldViolations = _a.fieldViolations, argumentNames = _a.argumentNames;
    var _b = collectArgumentExpressions(transformation), spreadPathsToArguments = _b.spreadPathsToArguments, explicitPathsToArguments = _b.explicitPathsToArguments;
    var allPathsToArguments = __assign(__assign({}, spreadPathsToArguments), explicitPathsToArguments);
    var allPathsToArgumentsKeys = Object.keys(allPathsToArguments);
    return _(fieldViolations)
        .map(function (fieldViolation) {
        // In some cases, the violations error will include both some.nested and some.nested.path,
        // so we'll pick the more specific one if it's covered by the paths in the transformation.
        var containedInAMoreSpecificViolationField = some(fieldViolations, function (anotherViolation) {
            return anotherViolation.field.length > fieldViolation.field.length &&
                anotherViolation.field.startsWith(fieldViolation.field) &&
                allPathsToArgumentsKeys.includes(anotherViolation.field);
        });
        if (containedInAMoreSpecificViolationField) {
            return null;
        }
        // This means we've got some.nested.field in the violation,
        // matched against { some: { nested: { field: $[0].a.b.c } } } in the transformation.
        // some.nested.field is replaced entirely with $[0].a.b.c, with $[0] replaced with the name of argument 0
        var exactMatchArgumentExpression = explicitPathsToArguments[fieldViolation.field];
        if (exactMatchArgumentExpression) {
            return __assign(__assign({}, fieldViolation), { field: withRenamedArgument(exactMatchArgumentExpression, argumentNames) });
        }
        var longestPartialPathMatch = chain(allPathsToArgumentsKeys)
            .sortBy('length')
            .reverse()
            .find(function (path) { return fieldViolation.field.startsWith(path); })
            .value();
        // This means we've got some.nested.field in the violation,
        // matched against { some: { nested: { *: $[0].a.b.c } } } in the transformation.
        // Only the prefix some.nested is replaced with $[0].a.b.c, with $[0] replaced with the name of argument 0
        // This can also happen in the case where the #wrap function is used.
        var partialMatchArgumentExpression = allPathsToArguments[longestPartialPathMatch];
        if (partialMatchArgumentExpression) {
            return __assign(__assign({}, fieldViolation), { field: fieldViolation.field.replace(longestPartialPathMatch, withRenamedArgument(partialMatchArgumentExpression, argumentNames)) });
        }
        if (transformation === JS_SINGLE_ARG_UNCHANGED) {
            return __assign(__assign({}, fieldViolation), { field: "".concat(argumentNames[0], ".").concat(fieldViolation.field) });
        }
        return fieldViolation;
    })
        .compact()
        .value();
};
export { violationsWithRenamedFields };
//# sourceMappingURL=violationsWithRenamedFields.js.map