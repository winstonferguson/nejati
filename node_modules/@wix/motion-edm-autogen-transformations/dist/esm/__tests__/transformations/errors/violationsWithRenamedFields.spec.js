import { anObject, aString } from '@wix/motion-runtime-test-context';
import { set, times } from 'lodash';
import { violationsWithRenamedFields } from '../../../lib/transformations/transformError/violationsWithRenamedFields';
describe('violationsWithRenamedFields', function () {
    var argumentNames = times(3, function () { return aString(); });
    var propertyName = aString();
    var description = aString();
    var originalPath = "some.nested.path.".concat(propertyName);
    var fieldViolations = [{ field: originalPath, description: description }];
    describe('identity transformation', function () {
        test('prepends the path with the single argument name', function () {
            var transformation = '$[0]';
            expect(violationsWithRenamedFields({
                transformation: transformation,
                fieldViolations: fieldViolations,
                argumentNames: argumentNames,
            })).toStrictEqual([
                {
                    field: "".concat(argumentNames[0], ".").concat(originalPath),
                    description: description,
                },
            ]);
        });
    });
    describe('complex transformation', function () {
        test('replaces an argument reference with its name in a given field-path', function () {
            var transformation = set({}, originalPath, '$[1].another.field');
            expect(violationsWithRenamedFields({
                transformation: transformation,
                fieldViolations: fieldViolations,
                argumentNames: argumentNames,
            })).toStrictEqual([
                {
                    field: "".concat(argumentNames[1], ".another.field"),
                    description: description,
                },
            ]);
        });
        test('ignores violations with a path overlapping another violation with a more specific path', function () {
            var overlappingFieldViolations = [
                {
                    field: 'something',
                    description: 'is invalid',
                },
                {
                    field: 'something.displayName',
                    description: description,
                },
            ];
            var transformation = {
                something: { displayName: '$[1]', key: '$[0]' },
            };
            expect(violationsWithRenamedFields({
                transformation: transformation,
                fieldViolations: overlappingFieldViolations,
                argumentNames: argumentNames,
            })).toStrictEqual([{ field: argumentNames[1], description: description }]);
        });
        test('handles the #wrap custom function', function () {
            var fieldName = 'emails';
            var path = "info.".concat(fieldName);
            var wrapper = 'items';
            var subField = aString();
            var wrappedFieldViolations = [
                { field: "".concat(path, ".").concat(wrapper, "[0].").concat(subField), description: description },
            ];
            var transformation = set({}, path, "#wrap($[0].".concat(fieldName, ", ").concat(wrapper, ")"));
            expect(violationsWithRenamedFields({
                transformation: transformation,
                fieldViolations: wrappedFieldViolations,
                argumentNames: argumentNames,
            })).toStrictEqual([
                {
                    field: "".concat(argumentNames[0], ".").concat(fieldName, "[0].").concat(subField),
                    description: description,
                },
            ]);
        });
        // TODO: this assumes that the value against "*" is always a string referencing an argument.
        // This needs to be added to the transformation validation-rules
        describe('when a direct match could not be found', function () {
            test('attempts to match with spread-notation path, using the deepest possible match', function () {
                var transformation = {
                    some: {
                        nested: { '*': '$[2]', path: { '*': '$[1].another.object' } },
                    },
                };
                expect(violationsWithRenamedFields({
                    transformation: transformation,
                    fieldViolations: fieldViolations,
                    argumentNames: argumentNames,
                })).toStrictEqual([
                    {
                        field: "".concat(argumentNames[1], ".another.object.").concat(propertyName),
                        description: description,
                    },
                ]);
            });
            test('returns the the path unchanged in case no match was found', function () {
                var transformation = anObject();
                expect(violationsWithRenamedFields({
                    transformation: transformation,
                    fieldViolations: fieldViolations,
                    argumentNames: argumentNames,
                })).toStrictEqual(fieldViolations);
            });
        });
    });
});
//# sourceMappingURL=violationsWithRenamedFields.spec.js.map