"use strict";

var _motionRuntimeTestContext = require("@wix/motion-runtime-test-context");
var _lodash = require("lodash");
var _violationsWithRenamedFields = require("../../../lib/transformations/transformError/violationsWithRenamedFields");
describe('violationsWithRenamedFields', () => {
  const argumentNames = (0, _lodash.times)(3, () => (0, _motionRuntimeTestContext.aString)());
  const propertyName = (0, _motionRuntimeTestContext.aString)();
  const description = (0, _motionRuntimeTestContext.aString)();
  const originalPath = `some.nested.path.${propertyName}`;
  const fieldViolations = [{
    field: originalPath,
    description
  }];
  describe('identity transformation', () => {
    test('prepends the path with the single argument name', () => {
      const transformation = '$[0]';
      expect((0, _violationsWithRenamedFields.violationsWithRenamedFields)({
        transformation,
        fieldViolations,
        argumentNames
      })).toStrictEqual([{
        field: `${argumentNames[0]}.${originalPath}`,
        description
      }]);
    });
  });
  describe('complex transformation', () => {
    test('replaces an argument reference with its name in a given field-path', () => {
      const transformation = (0, _lodash.set)({}, originalPath, '$[1].another.field');
      expect((0, _violationsWithRenamedFields.violationsWithRenamedFields)({
        transformation,
        fieldViolations,
        argumentNames
      })).toStrictEqual([{
        field: `${argumentNames[1]}.another.field`,
        description
      }]);
    });
    test('ignores violations with a path overlapping another violation with a more specific path', () => {
      const overlappingFieldViolations = [{
        field: 'something',
        description: 'is invalid'
      }, {
        field: 'something.displayName',
        description
      }];
      const transformation = {
        something: {
          displayName: '$[1]',
          key: '$[0]'
        }
      };
      expect((0, _violationsWithRenamedFields.violationsWithRenamedFields)({
        transformation,
        fieldViolations: overlappingFieldViolations,
        argumentNames
      })).toStrictEqual([{
        field: argumentNames[1],
        description
      }]);
    });
    test('handles the #wrap custom function', () => {
      const fieldName = 'emails';
      const path = `info.${fieldName}`;
      const wrapper = 'items';
      const subField = (0, _motionRuntimeTestContext.aString)();
      const wrappedFieldViolations = [{
        field: `${path}.${wrapper}[0].${subField}`,
        description
      }];
      const transformation = (0, _lodash.set)({}, path, `#wrap($[0].${fieldName}, ${wrapper})`);
      expect((0, _violationsWithRenamedFields.violationsWithRenamedFields)({
        transformation,
        fieldViolations: wrappedFieldViolations,
        argumentNames
      })).toStrictEqual([{
        field: `${argumentNames[0]}.${fieldName}[0].${subField}`,
        description
      }]);
    });

    // TODO: this assumes that the value against "*" is always a string referencing an argument.
    // This needs to be added to the transformation validation-rules
    describe('when a direct match could not be found', () => {
      test('attempts to match with spread-notation path, using the deepest possible match', () => {
        const transformation = {
          some: {
            nested: {
              '*': '$[2]',
              path: {
                '*': '$[1].another.object'
              }
            }
          }
        };
        expect((0, _violationsWithRenamedFields.violationsWithRenamedFields)({
          transformation,
          fieldViolations,
          argumentNames
        })).toStrictEqual([{
          field: `${argumentNames[1]}.another.object.${propertyName}`,
          description
        }]);
      });
      test('returns the the path unchanged in case no match was found', () => {
        const transformation = (0, _motionRuntimeTestContext.anObject)();
        expect((0, _violationsWithRenamedFields.violationsWithRenamedFields)({
          transformation,
          fieldViolations,
          argumentNames
        })).toStrictEqual(fieldViolations);
      });
    });
  });
});
//# sourceMappingURL=violationsWithRenamedFields.spec.js.map