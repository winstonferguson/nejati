"use strict";

var _motionRuntimeTestContext = require("@wix/motion-runtime-test-context");
var _lodash = require("lodash");
var _customTransformations = require("../../../lib/transformations/custom-transformations");
describe('transformation contract tests', () => {
  const sourceObjectPath = 'a.b.c';
  describe.each`
    transformationFunction       | expression                    | sourceFactory                     | undefinedFallback
    ${_customTransformations.transformToRequestMessage} | ${`$[0].${sourceObjectPath}`} | ${sourceValue => [sourceValue]} | ${{}}
    ${_customTransformations.transformResponseMessage}  | ${`$.${sourceObjectPath}`}    | ${sourceValue => sourceValue}   | ${undefined}
  `('$transformationFunction.name - omitting fields', ({
    transformationFunction,
    expression,
    sourceFactory,
    undefinedFallback
  }) => {
    const _times = (0, _lodash.times)(2, () => (0, _motionRuntimeTestContext.anObject)()),
      objectToKeep = _times[0],
      objectToOmit = _times[1];
    const fieldsToOmit = Object.keys(objectToOmit);
    const source = sourceFactory((0, _lodash.set)({}, sourceObjectPath, {
      ...objectToKeep,
      ...objectToOmit
    }));
    const topLevelOmitTransformation = {
      '@source': expression,
      '@omit': fieldsToOmit
    };
    const nestedPathOmitTransformation = {
      d: {
        e: {
          f: topLevelOmitTransformation
        }
      }
    };
    test('omits fields from a source path as a top-level transformation', () => {
      expect(transformationFunction(source, topLevelOmitTransformation)).toStrictEqual(objectToKeep);
    });
    test('omits fields from a source path as a nested transformation', () => {
      expect(transformationFunction(source, nestedPathOmitTransformation)).toStrictEqual({
        d: {
          e: {
            f: objectToKeep
          }
        }
      });
    });
    test('supports complex transformation on the @source part', () => {
      const transformation = {
        '@source': {
          '*': expression
        },
        '@omit': fieldsToOmit
      };
      expect(transformationFunction(source, transformation)).toStrictEqual(objectToKeep);
    });
    describe('invalid inputs', () => {
      const nonObject = (0, _motionRuntimeTestContext.aString)();
      const objectWithNonexistingSourcePath = {
        x: {
          y: {
            z: 1
          }
        }
      };
      const nonObjectSource = (0, _lodash.set)({}, sourceObjectPath, nonObject);
      test.each`
          invalidSource                                     | description           | expected
          ${sourceFactory(objectWithNonexistingSourcePath)} | ${'does not exist'}   | ${undefinedFallback}
          ${sourceFactory(nonObjectSource)}                 | ${'is not an object'} | ${sourceFactory(nonObjectSource)}
        `('handles a top-level object to omit that $description', ({
        invalidSource,
        expected
      }) => {
        expect(transformationFunction(invalidSource, topLevelOmitTransformation)).toStrictEqual(expected);
      });
      test.each`
          rawSource                          | description           | expected
          ${objectWithNonexistingSourcePath} | ${'does not exist'}   | ${undefined}
          ${nonObjectSource}                 | ${'is not an object'} | ${nonObject}
        `('does nothing when the nested-path object to omit from $description', ({
        rawSource,
        expected
      }) => {
        const invalidSource = sourceFactory(rawSource);
        expect(transformationFunction(invalidSource, nestedPathOmitTransformation)).toStrictEqual({
          d: {
            e: {
              f: expected
            }
          }
        });
      });
    });
  });
  describe('spread operator', () => {
    test.each`
      transformationFunction       | expression                    | sourceFactory
      ${_customTransformations.transformToRequestMessage} | ${`$[0].${sourceObjectPath}`} | ${sourceValue => [sourceValue]}
      ${_customTransformations.transformResponseMessage}  | ${`$.${sourceObjectPath}`}    | ${sourceValue => sourceValue}
    `('$transformationFunction.name - supports complex expressions', ({
      transformationFunction,
      sourceFactory,
      expression
    }) => {
      const _times2 = (0, _lodash.times)(4, () => (0, _motionRuntimeTestContext.aString)()),
        propertyToOmit = _times2[0],
        valueToOmit = _times2[1],
        propertyToKeep = _times2[2],
        valueToKeep = _times2[3];
      const sourceValue = (0, _lodash.set)({}, sourceObjectPath, {
        [propertyToOmit]: valueToOmit,
        [propertyToKeep]: valueToKeep
      });
      const source = sourceFactory(sourceValue);
      const transformation = {
        '*': {
          '@source': expression,
          '@omit': [propertyToOmit]
        }
      };
      expect(transformationFunction(source, transformation)).toStrictEqual({
        [propertyToKeep]: valueToKeep
      });
    });

    /* eslint-disable max-len */
    test.each`
      transformationFunction       | transformation                       | source                                     | expectedFactory
      ${_customTransformations.transformToRequestMessage} | ${{
      id: '$[0]',
      '*': '$[1]'
    }}       | ${[(0, _motionRuntimeTestContext.aString)(), (0, _motionRuntimeTestContext.anObject)()]}                 | ${source => ({
      id: source[0],
      ...source[1]
    })}
      ${_customTransformations.transformResponseMessage}  | ${{
      id: '$.id',
      '*': '$.resource'
    }} | ${{
      id: (0, _motionRuntimeTestContext.aString)(),
      resource: (0, _motionRuntimeTestContext.anObject)()
    }} | ${source => ({
      id: source.id,
      ...source.resource
    })}
    `( /* eslint-enable max-len */
    '$transformationFunction.name - flattens argument object keys onto its parent object', ({
      transformationFunction,
      transformation,
      source,
      expectedFactory
    }) => {
      expect(transformationFunction(source, transformation)).toStrictEqual(expectedFactory(source));
    });

    /* eslint-disable max-len */
    test.each`
      transformationFunction       | transformation                                        | source                                                            | expectedFactory
      ${_customTransformations.transformToRequestMessage} | ${{
      id: '$[0]',
      '*': ['$[1]', '$[2]']
    }}              | ${[(0, _motionRuntimeTestContext.aString)(), (0, _motionRuntimeTestContext.anObject)(), (0, _motionRuntimeTestContext.anObject)()]}                            | ${source => ({
      id: source[0],
      ...source[1],
      ...source[2]
    })}
      ${_customTransformations.transformResponseMessage}  | ${{
      id: '$.id',
      '*': ['$.resource', '$.resource2']
    }} | ${{
      id: (0, _motionRuntimeTestContext.aString)(),
      resource: (0, _motionRuntimeTestContext.anObject)(),
      resource2: (0, _motionRuntimeTestContext.anObject)()
    }} | ${source => ({
      id: source.id,
      ...source.resource,
      ...source.resource2
    })}
    `( /* eslint-enable max-len */
    '$transformationFunction.name - flattens top-level argument object-keys onto their parent object', ({
      transformationFunction,
      transformation,
      source,
      expectedFactory
    }) => {
      expect(transformationFunction(source, transformation)).toStrictEqual(expectedFactory(source));
    });

    /* eslint-disable max-len */
    test.each`
      transformationFunction       | transformation                                               | source                                                            | expectedFactory
      ${_customTransformations.transformToRequestMessage} | ${{
      id: '$[0]',
      b: {
        '*': ['$[1]', '$[2]']
      }
    }}              | ${[(0, _motionRuntimeTestContext.aString)(), (0, _motionRuntimeTestContext.anObject)(), (0, _motionRuntimeTestContext.anObject)()]}                            | ${source => ({
      id: source[0],
      b: {
        ...source[1],
        ...source[2]
      }
    })}
      ${_customTransformations.transformResponseMessage}  | ${{
      id: '$.id',
      b: {
        '*': ['$.resource', '$.resource2']
      }
    }} | ${{
      id: (0, _motionRuntimeTestContext.aString)(),
      resource: (0, _motionRuntimeTestContext.anObject)(),
      resource2: (0, _motionRuntimeTestContext.anObject)()
    }} | ${source => ({
      id: source.id,
      b: {
        ...source.resource,
        ...source.resource2
      }
    })}
    `( /* eslint-enable max-len */
    '$transformationFunction.name - flattens nested argument object-keys onto their parent object', ({
      transformationFunction,
      transformation,
      source,
      expectedFactory
    }) => {
      expect(transformationFunction(source, transformation)).toStrictEqual(expectedFactory(source));
    });
    describe('siblings override', () => {
      const keyThatShouldNotAppearInTransformed = (0, _motionRuntimeTestContext.aString)();
      const someValue = (0, _motionRuntimeTestContext.aString)();
      const sourceBase = {
        a: {
          someValue,
          b: {
            [keyThatShouldNotAppearInTransformed]: 2
          }
        }
      };

      /* eslint-disable max-len */
      test.each`
        transformationFunction       | transformation                                                                       | source
        ${_customTransformations.transformToRequestMessage} | ${{
        '*': '$[0].a',
        b: {
          newC: `$[0].a.b.${keyThatShouldNotAppearInTransformed}`
        }
      }} | ${[sourceBase]}
        ${_customTransformations.transformResponseMessage}  | ${{
        '*': '$.a',
        b: {
          newC: `$.a.b.${keyThatShouldNotAppearInTransformed}`
        }
      }}       | ${sourceBase}
      `('$transformationFunction.name - does not override sibling properties at the spread target', ({
        transformationFunction,
        transformation,
        source
      }) => {
        /* eslint-enable max-len */

        expect(transformationFunction(source, transformation)).toStrictEqual({
          someValue,
          b: {
            newC: 2
          }
        });
      });

      /* eslint-disable max-len */
      test.each`
        transformationFunction       | transformation                                                                                     | source
        ${_customTransformations.transformToRequestMessage} | ${{
        topLevel: {
          '*': '$[0].a',
          b: {
            newC: `$[0].a.b.${keyThatShouldNotAppearInTransformed}`
          }
        }
      }} | ${[sourceBase]}
        ${_customTransformations.transformResponseMessage}  | ${{
        topLevel: {
          '*': '$.a',
          b: {
            newC: `$.a.b.${keyThatShouldNotAppearInTransformed}`
          }
        }
      }}       | ${sourceBase}
      `('$transformationFunction.name - does not override nested sibling properties at the spread target', ({
        transformationFunction,
        transformation,
        source
      }) => {
        /* eslint-enable max-len */

        expect(transformationFunction(source, transformation)).toStrictEqual({
          topLevel: {
            someValue,
            b: {
              newC: 2
            }
          }
        });
      });
    });
    describe('invalid inputs', () => {
      /* eslint-disable max-len */
      test.each`
        transformationFunction       | transformation                       | source               | expectedFactory
        ${_customTransformations.transformToRequestMessage} | ${{
        id: '$[0]',
        '*': '$[1]'
      }}       | ${[(0, _motionRuntimeTestContext.aString)()]}       | ${source => ({
        id: source[0]
      })}
        ${_customTransformations.transformResponseMessage}  | ${{
        id: '$.id',
        '*': '$.resource'
      }} | ${{
        id: (0, _motionRuntimeTestContext.aString)()
      }} | ${source => ({
        id: source.id
      })}
      `( /* eslint-enable max-len */
      '$transformationFunction.name - passes the input as is when the value to spread does not exist', ({
        transformationFunction,
        transformation,
        source,
        expectedFactory
      }) => {
        expect(transformationFunction(source, transformation)).toStrictEqual(expectedFactory(source));
      });

      /* eslint-disable max-len */
      test.each`
        transformationFunction       | transformation                       | source                                    | expectedFactory
        ${_customTransformations.transformToRequestMessage} | ${{
        id: '$[0]',
        '*': '$[1]'
      }}       | ${[(0, _motionRuntimeTestContext.aString)(), (0, _motionRuntimeTestContext.aString)()]}                 | ${source => ({
        id: source[0]
      })}
        ${_customTransformations.transformResponseMessage}  | ${{
        id: '$.id',
        '*': '$.resource'
      }} | ${{
        id: (0, _motionRuntimeTestContext.aString)(),
        resource: (0, _motionRuntimeTestContext.aString)()
      }} | ${source => ({
        id: source.id
      })}
      `( /* eslint-enable max-len */
      '$transformationFunction.name - does nothing when the value to spread is not an object', ({
        transformationFunction,
        transformation,
        source,
        expectedFactory
      }) => {
        expect(transformationFunction(source, transformation)).toStrictEqual(expectedFactory(source));
      });
    });
  });
  describe.each`
    transformationFunction       | idJsonPath | sourceFactory
    ${_customTransformations.transformToRequestMessage} | ${'$[0]'}  | ${id => [id]}
    ${_customTransformations.transformResponseMessage}  | ${'$.id'}  | ${id => ({
    id
  })}
  `('$transformationFunction.name - custom functions', ({
    transformationFunction,
    idJsonPath,
    sourceFactory
  }) => {
    const id = (0, _motionRuntimeTestContext.aString)();
    const source = sourceFactory(id);
    const constantArgumentExpression = (0, _motionRuntimeTestContext.aString)();
    const functionCallSimpleTransformation = `#someCustomFunction(${idJsonPath}, ${constantArgumentExpression})`;
    const transformation = {
      id: functionCallSimpleTransformation
    };
    const someCustomFunction = (s1, s2) => `${[s1, s1].join('>>>')}___${s2}`;
    test('are applied when transforming using complex mapping', () => {
      const customFunctions = {
        someCustomFunction
      };
      expect(transformationFunction(source, transformation, customFunctions)).toStrictEqual({
        id: `${id}>>>${id}___${constantArgumentExpression}`
      });
    });
    test('are applied when transforming using simple mapping', () => {
      const customFunctions = {
        someCustomFunction
      };
      expect(transformationFunction(source, functionCallSimpleTransformation, customFunctions)).toStrictEqual(`${id}>>>${id}___${constantArgumentExpression}`);
    });
    test('throws when the function is not recognized', () => {
      const customFunctions = {};
      expect(() => transformationFunction(source, transformation, customFunctions)).toThrow(`unrecognized custom function "someCustomFunction"`);
    });
    test('throws an error when the function call throws an error', () => {
      const nestedPathTransformation = {
        some: {
          nested: {
            path: functionCallSimpleTransformation
          }
        }
      };
      const customFunctions = {
        someCustomFunction: () => {
          throw new Error('Something went wrong in the custom function');
        }
      };
      const t = () => transformationFunction(source, nestedPathTransformation, customFunctions);
      expect(t).toThrow(Error);
      expect(t).toThrow(/Transforming some.nested.path failed, #someCustomFunction threw: "Something went wrong in the custom function" for arguments: +./);
    });
  });
  describe('array items transformation', () => {
    const transformationPath = 'd.e.f';
    const nonArrayPath = 'x.y.z';
    const nonArrayPathValue = (0, _motionRuntimeTestContext.aString)();
    const validSource = (0, _lodash.set)({}, sourceObjectPath, [{
      aaa: 555,
      bbb: 6
    }, {
      aaa: 777,
      bbb: 8
    }]);
    const sourceBase = (0, _lodash.set)(validSource, `${sourceObjectPath}.${nonArrayPath}`, nonArrayPathValue);
    describe.each`
      transformationFunction       | rootPathExpression            | source          | expectedForNonExistingPath
      ${_customTransformations.transformToRequestMessage} | ${`$[0].${sourceObjectPath}`} | ${[sourceBase]} | ${{}}
      ${_customTransformations.transformResponseMessage}  | ${`$.${sourceObjectPath}`}    | ${sourceBase}   | ${undefined}
    `('$transformationFunction.name', ({
      transformationFunction,
      rootPathExpression,
      source,
      expectedForNonExistingPath
    }) => {
      test('maps each item from the source object to a new array as a top-level transformation', () => {
        const transformation = {
          '@path': rootPathExpression,
          '@itemTransformation': '$.aaa'
        };
        expect(transformationFunction(source, transformation)).toStrictEqual([555, 777]);
      });
      test('maps each item from the source object to a new array on a nested transformation', () => {
        const transformation = (0, _lodash.set)({}, transformationPath, {
          '@path': rootPathExpression,
          '@itemTransformation': '$.aaa'
        });
        expect(transformationFunction(source, transformation)).toStrictEqual({
          d: {
            e: {
              f: [555, 777]
            }
          }
        });
      });
      test('supports custom functions applied on items - top-level', () => {
        const transformation = {
          '@path': rootPathExpression,
          '@itemTransformation': '#addOne($.aaa)'
        };
        const transformationResult = transformationFunction(source, transformation, {
          addOne: x => x + 1
        });
        expect(transformationResult).toStrictEqual([556, 778]);
      });
      test('supports custom functions applied on items', () => {
        const transformation = (0, _lodash.set)({}, transformationPath, {
          '@path': rootPathExpression,
          '@itemTransformation': '#addOne($.aaa)'
        });
        const transformationResult = transformationFunction(source, transformation, {
          addOne: x => x + 1
        });
        expect(transformationResult).toStrictEqual({
          d: {
            e: {
              f: [556, 778]
            }
          }
        });
      });
      describe('invalid inputs', () => {
        test.each`
            path              | expected                      | description
            ${'doesNotExist'} | ${expectedForNonExistingPath} | ${'does not exist'}
            ${nonArrayPath}   | ${nonArrayPathValue}          | ${'is not an array'}
          `('does not fail when a top-level path $description', ({
          path,
          expected
        }) => {
          const transformation = {
            '@path': `${rootPathExpression}.${path}`,
            '@itemTransformation': '$.aaa'
          };
          expect(transformationFunction(source, transformation)).toStrictEqual(expected);
        });
        test.each`
            path              | expected             | description
            ${'doesNotExist'} | ${undefined}         | ${'does not exist'}
            ${nonArrayPath}   | ${nonArrayPathValue} | ${'is not an array'}
          `('does not fail when a nested path $description', ({
          path,
          expected
        }) => {
          const transformation = (0, _lodash.set)({}, transformationPath, {
            '@path': `${rootPathExpression}.${path}`,
            '@itemTransformation': '$.aaa'
          });
          expect(transformationFunction(source, transformation)).toStrictEqual({
            d: {
              e: {
                f: expected
              }
            }
          });
        });
      });
    });
  });
  describe('constant transformation', () => {
    describe.each`
      transformationFunction       | expression                    | sourceFactory
      ${_customTransformations.transformToRequestMessage} | ${`$[0].${sourceObjectPath}`} | ${sourceValue => [sourceValue]}
      ${_customTransformations.transformResponseMessage}  | ${`$.${sourceObjectPath}`}    | ${sourceValue => sourceValue}
    `('$transformationFunction.name - omitting fields', ({
      transformationFunction,
      expression,
      sourceFactory
    }) => {
      const sourceValue = (0, _motionRuntimeTestContext.aString)();
      const source = sourceFactory((0, _lodash.set)({}, sourceObjectPath, sourceValue));
      const nestedConstantTransformation = {
        d: {
          e: {
            f: expression,
            g: {
              '@constant': {
                something: '$.value',
                notFunction: '#thisWontBeACustomFunction($)',
                '*': 'notGoingToBeSpread'
              }
            }
          }
        }
      };
      test('omits fields from a source path as a top-level transformation', () => {
        expect(transformationFunction(source, nestedConstantTransformation)).toStrictEqual({
          d: {
            e: {
              f: sourceValue,
              g: {
                something: '$.value',
                notFunction: '#thisWontBeACustomFunction($)',
                '*': 'notGoingToBeSpread'
              }
            }
          }
        });
      });
    });
  });
});
//# sourceMappingURL=contract.spec.js.map