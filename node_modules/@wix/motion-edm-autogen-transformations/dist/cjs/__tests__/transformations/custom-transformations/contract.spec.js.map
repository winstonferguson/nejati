{"version":3,"names":["_motionRuntimeTestContext","require","_lodash","_customTransformations","describe","sourceObjectPath","each","transformToRequestMessage","sourceValue","transformResponseMessage","undefined","transformationFunction","expression","sourceFactory","undefinedFallback","_times","times","anObject","objectToKeep","objectToOmit","fieldsToOmit","Object","keys","source","set","topLevelOmitTransformation","nestedPathOmitTransformation","d","e","f","test","expect","toStrictEqual","transformation","nonObject","aString","objectWithNonexistingSourcePath","x","y","z","nonObjectSource","invalidSource","expected","rawSource","_times2","propertyToOmit","valueToOmit","propertyToKeep","valueToKeep","id","resource","expectedFactory","resource2","b","keyThatShouldNotAppearInTransformed","someValue","sourceBase","a","newC","topLevel","idJsonPath","constantArgumentExpression","functionCallSimpleTransformation","someCustomFunction","s1","s2","join","customFunctions","toThrow","nestedPathTransformation","some","nested","path","Error","t","transformationPath","nonArrayPath","nonArrayPathValue","validSource","aaa","bbb","rootPathExpression","expectedForNonExistingPath","transformationResult","addOne","nestedConstantTransformation","g","something","notFunction"],"sources":["../../../../../src/__tests__/transformations/custom-transformations/contract.spec.ts"],"sourcesContent":["import { anObject, aString } from '@wix/motion-runtime-test-context';\nimport { set, times } from 'lodash';\n\nimport {\n  transformResponseMessage,\n  transformToRequestMessage,\n} from '../../../lib/transformations/custom-transformations';\n\ndescribe('transformation contract tests', () => {\n  const sourceObjectPath = 'a.b.c';\n\n  describe.each`\n    transformationFunction       | expression                    | sourceFactory                     | undefinedFallback\n    ${transformToRequestMessage} | ${`$[0].${sourceObjectPath}`} | ${(sourceValue) => [sourceValue]} | ${{}}\n    ${transformResponseMessage}  | ${`$.${sourceObjectPath}`}    | ${(sourceValue) => sourceValue}   | ${undefined}\n  `(\n    '$transformationFunction.name - omitting fields',\n    ({\n      transformationFunction,\n      expression,\n      sourceFactory,\n      undefinedFallback,\n    }) => {\n      const [objectToKeep, objectToOmit] = times(2, () => anObject());\n      const fieldsToOmit = Object.keys(objectToOmit);\n      const source = sourceFactory(\n        set({}, sourceObjectPath, {\n          ...objectToKeep,\n          ...objectToOmit,\n        }),\n      );\n      const topLevelOmitTransformation = {\n        '@source': expression,\n        '@omit': fieldsToOmit,\n      };\n      const nestedPathOmitTransformation = {\n        d: { e: { f: topLevelOmitTransformation } },\n      };\n\n      test('omits fields from a source path as a top-level transformation', () => {\n        expect(\n          transformationFunction(source, topLevelOmitTransformation),\n        ).toStrictEqual(objectToKeep);\n      });\n\n      test('omits fields from a source path as a nested transformation', () => {\n        expect(\n          transformationFunction(source, nestedPathOmitTransformation),\n        ).toStrictEqual({\n          d: {\n            e: {\n              f: objectToKeep,\n            },\n          },\n        });\n      });\n\n      test('supports complex transformation on the @source part', () => {\n        const transformation = {\n          '@source': { '*': expression },\n          '@omit': fieldsToOmit,\n        };\n\n        expect(transformationFunction(source, transformation)).toStrictEqual(\n          objectToKeep,\n        );\n      });\n\n      describe('invalid inputs', () => {\n        const nonObject = aString();\n        const objectWithNonexistingSourcePath = { x: { y: { z: 1 } } };\n        const nonObjectSource = set({}, sourceObjectPath, nonObject);\n\n        test.each`\n          invalidSource                                     | description           | expected\n          ${sourceFactory(objectWithNonexistingSourcePath)} | ${'does not exist'}   | ${undefinedFallback}\n          ${sourceFactory(nonObjectSource)}                 | ${'is not an object'} | ${sourceFactory(nonObjectSource)}\n        `(\n          'handles a top-level object to omit that $description',\n          ({ invalidSource, expected }) => {\n            expect(\n              transformationFunction(invalidSource, topLevelOmitTransformation),\n            ).toStrictEqual(expected);\n          },\n        );\n\n        test.each`\n          rawSource                          | description           | expected\n          ${objectWithNonexistingSourcePath} | ${'does not exist'}   | ${undefined}\n          ${nonObjectSource}                 | ${'is not an object'} | ${nonObject}\n        `(\n          'does nothing when the nested-path object to omit from $description',\n          ({ rawSource, expected }) => {\n            const invalidSource = sourceFactory(rawSource);\n\n            expect(\n              transformationFunction(\n                invalidSource,\n                nestedPathOmitTransformation,\n              ),\n            ).toStrictEqual({\n              d: { e: { f: expected } },\n            });\n          },\n        );\n      });\n    },\n  );\n\n  describe('spread operator', () => {\n    test.each`\n      transformationFunction       | expression                    | sourceFactory\n      ${transformToRequestMessage} | ${`$[0].${sourceObjectPath}`} | ${(sourceValue) => [sourceValue]}\n      ${transformResponseMessage}  | ${`$.${sourceObjectPath}`}    | ${(sourceValue) => sourceValue}\n    `(\n      '$transformationFunction.name - supports complex expressions',\n      ({ transformationFunction, sourceFactory, expression }) => {\n        const [propertyToOmit, valueToOmit, propertyToKeep, valueToKeep] =\n          times(4, () => aString());\n        const sourceValue = set({}, sourceObjectPath, {\n          [propertyToOmit]: valueToOmit,\n          [propertyToKeep]: valueToKeep,\n        });\n        const source = sourceFactory(sourceValue);\n        const transformation = {\n          '*': {\n            '@source': expression,\n            '@omit': [propertyToOmit],\n          },\n        };\n\n        expect(transformationFunction(source, transformation)).toStrictEqual({\n          [propertyToKeep]: valueToKeep,\n        });\n      },\n    );\n\n    /* eslint-disable max-len */\n    test.each`\n      transformationFunction       | transformation                       | source                                     | expectedFactory\n      ${transformToRequestMessage} | ${{ id: '$[0]', '*': '$[1]' }}       | ${[aString(), anObject()]}                 | ${(source) => ({ id: source[0], ...source[1] })}\n      ${transformResponseMessage}  | ${{ id: '$.id', '*': '$.resource' }} | ${{ id: aString(), resource: anObject() }} | ${(source) => ({ id: source.id, ...source.resource })}\n    `(\n      /* eslint-enable max-len */\n      '$transformationFunction.name - flattens argument object keys onto its parent object',\n      ({ transformationFunction, transformation, source, expectedFactory }) => {\n        expect(transformationFunction(source, transformation)).toStrictEqual(\n          expectedFactory(source),\n        );\n      },\n    );\n\n    /* eslint-disable max-len */\n    test.each`\n      transformationFunction       | transformation                                        | source                                                            | expectedFactory\n      ${transformToRequestMessage} | ${{ id: '$[0]', '*': ['$[1]', '$[2]'] }}              | ${[aString(), anObject(), anObject()]}                            | ${(source) => ({ id: source[0], ...source[1], ...source[2] })}\n      ${transformResponseMessage}  | ${{ id: '$.id', '*': ['$.resource', '$.resource2'] }} | ${{ id: aString(), resource: anObject(), resource2: anObject() }} | ${(source) => ({ id: source.id, ...source.resource, ...source.resource2 })}\n    `(\n      /* eslint-enable max-len */\n      '$transformationFunction.name - flattens top-level argument object-keys onto their parent object',\n      ({ transformationFunction, transformation, source, expectedFactory }) => {\n        expect(transformationFunction(source, transformation)).toStrictEqual(\n          expectedFactory(source),\n        );\n      },\n    );\n\n    /* eslint-disable max-len */\n    test.each`\n      transformationFunction       | transformation                                               | source                                                            | expectedFactory\n      ${transformToRequestMessage} | ${{ id: '$[0]', b: { '*': ['$[1]', '$[2]'] } }}              | ${[aString(), anObject(), anObject()]}                            | ${(source) => ({ id: source[0], b: { ...source[1], ...source[2] } })}\n      ${transformResponseMessage}  | ${{ id: '$.id', b: { '*': ['$.resource', '$.resource2'] } }} | ${{ id: aString(), resource: anObject(), resource2: anObject() }} | ${(source) => ({ id: source.id, b: { ...source.resource, ...source.resource2 } })}\n    `(\n      /* eslint-enable max-len */\n      '$transformationFunction.name - flattens nested argument object-keys onto their parent object',\n      ({ transformationFunction, transformation, source, expectedFactory }) => {\n        expect(transformationFunction(source, transformation)).toStrictEqual(\n          expectedFactory(source),\n        );\n      },\n    );\n\n    describe('siblings override', () => {\n      const keyThatShouldNotAppearInTransformed = aString();\n      const someValue = aString();\n\n      const sourceBase = {\n        a: {\n          someValue,\n          b: {\n            [keyThatShouldNotAppearInTransformed]: 2,\n          },\n        },\n      };\n\n      /* eslint-disable max-len */\n      test.each`\n        transformationFunction       | transformation                                                                       | source\n        ${transformToRequestMessage} | ${{ '*': '$[0].a', b: { newC: `$[0].a.b.${keyThatShouldNotAppearInTransformed}` } }} | ${[sourceBase]}\n        ${transformResponseMessage}  | ${{ '*': '$.a', b: { newC: `$.a.b.${keyThatShouldNotAppearInTransformed}` } }}       | ${sourceBase}\n      `(\n        '$transformationFunction.name - does not override sibling properties at the spread target',\n        ({ transformationFunction, transformation, source }) => {\n          /* eslint-enable max-len */\n\n          expect(transformationFunction(source, transformation)).toStrictEqual({\n            someValue,\n            b: {\n              newC: 2,\n            },\n          });\n        },\n      );\n\n      /* eslint-disable max-len */\n      test.each`\n        transformationFunction       | transformation                                                                                     | source\n        ${transformToRequestMessage} | ${{ topLevel: { '*': '$[0].a', b: { newC: `$[0].a.b.${keyThatShouldNotAppearInTransformed}` } } }} | ${[sourceBase]}\n        ${transformResponseMessage}  | ${{ topLevel: { '*': '$.a', b: { newC: `$.a.b.${keyThatShouldNotAppearInTransformed}` } } }}       | ${sourceBase}\n      `(\n        '$transformationFunction.name - does not override nested sibling properties at the spread target',\n        ({ transformationFunction, transformation, source }) => {\n          /* eslint-enable max-len */\n\n          expect(transformationFunction(source, transformation)).toStrictEqual({\n            topLevel: {\n              someValue,\n              b: {\n                newC: 2,\n              },\n            },\n          });\n        },\n      );\n    });\n\n    describe('invalid inputs', () => {\n      /* eslint-disable max-len */\n      test.each`\n        transformationFunction       | transformation                       | source               | expectedFactory\n        ${transformToRequestMessage} | ${{ id: '$[0]', '*': '$[1]' }}       | ${[aString()]}       | ${(source) => ({ id: source[0] })}\n        ${transformResponseMessage}  | ${{ id: '$.id', '*': '$.resource' }} | ${{ id: aString() }} | ${(source) => ({ id: source.id })}\n      `(\n        /* eslint-enable max-len */\n        '$transformationFunction.name - passes the input as is when the value to spread does not exist',\n        ({\n          transformationFunction,\n          transformation,\n          source,\n          expectedFactory,\n        }) => {\n          expect(transformationFunction(source, transformation)).toStrictEqual(\n            expectedFactory(source),\n          );\n        },\n      );\n\n      /* eslint-disable max-len */\n      test.each`\n        transformationFunction       | transformation                       | source                                    | expectedFactory\n        ${transformToRequestMessage} | ${{ id: '$[0]', '*': '$[1]' }}       | ${[aString(), aString()]}                 | ${(source) => ({ id: source[0] })}\n        ${transformResponseMessage}  | ${{ id: '$.id', '*': '$.resource' }} | ${{ id: aString(), resource: aString() }} | ${(source) => ({ id: source.id })}\n      `(\n        /* eslint-enable max-len */\n        '$transformationFunction.name - does nothing when the value to spread is not an object',\n        ({\n          transformationFunction,\n          transformation,\n          source,\n          expectedFactory,\n        }) => {\n          expect(transformationFunction(source, transformation)).toStrictEqual(\n            expectedFactory(source),\n          );\n        },\n      );\n    });\n  });\n\n  describe.each`\n    transformationFunction       | idJsonPath | sourceFactory\n    ${transformToRequestMessage} | ${'$[0]'}  | ${(id) => [id]}\n    ${transformResponseMessage}  | ${'$.id'}  | ${(id) => ({ id })}\n  `(\n    '$transformationFunction.name - custom functions',\n    ({ transformationFunction, idJsonPath, sourceFactory }) => {\n      const id = aString();\n      const source = sourceFactory(id);\n      const constantArgumentExpression = aString();\n\n      const functionCallSimpleTransformation = `#someCustomFunction(${idJsonPath}, ${constantArgumentExpression})`;\n      const transformation = { id: functionCallSimpleTransformation };\n      const someCustomFunction = (s1, s2) => `${[s1, s1].join('>>>')}___${s2}`;\n\n      test('are applied when transforming using complex mapping', () => {\n        const customFunctions = { someCustomFunction };\n\n        expect(\n          transformationFunction(source, transformation, customFunctions),\n        ).toStrictEqual({\n          id: `${id}>>>${id}___${constantArgumentExpression}`,\n        });\n      });\n\n      test('are applied when transforming using simple mapping', () => {\n        const customFunctions = { someCustomFunction };\n\n        expect(\n          transformationFunction(\n            source,\n            functionCallSimpleTransformation,\n            customFunctions,\n          ),\n        ).toStrictEqual(`${id}>>>${id}___${constantArgumentExpression}`);\n      });\n\n      test('throws when the function is not recognized', () => {\n        const customFunctions = {};\n\n        expect(() =>\n          transformationFunction(source, transformation, customFunctions),\n        ).toThrow(`unrecognized custom function \"someCustomFunction\"`);\n      });\n\n      test('throws an error when the function call throws an error', () => {\n        const nestedPathTransformation = {\n          some: { nested: { path: functionCallSimpleTransformation } },\n        };\n\n        const customFunctions = {\n          someCustomFunction: () => {\n            throw new Error('Something went wrong in the custom function');\n          },\n        };\n\n        const t = () =>\n          transformationFunction(\n            source,\n            nestedPathTransformation,\n            customFunctions,\n          );\n\n        expect(t).toThrow(Error);\n        expect(t).toThrow(\n          /Transforming some.nested.path failed, #someCustomFunction threw: \"Something went wrong in the custom function\" for arguments: +./,\n        );\n      });\n    },\n  );\n\n  describe('array items transformation', () => {\n    const transformationPath = 'd.e.f';\n    const nonArrayPath = 'x.y.z';\n    const nonArrayPathValue = aString();\n    const validSource = set({}, sourceObjectPath, [\n      { aaa: 555, bbb: 6 },\n      { aaa: 777, bbb: 8 },\n    ]);\n    const sourceBase = set(\n      validSource,\n      `${sourceObjectPath}.${nonArrayPath}`,\n      nonArrayPathValue,\n    );\n\n    describe.each`\n      transformationFunction       | rootPathExpression            | source          | expectedForNonExistingPath\n      ${transformToRequestMessage} | ${`$[0].${sourceObjectPath}`} | ${[sourceBase]} | ${{}}\n      ${transformResponseMessage}  | ${`$.${sourceObjectPath}`}    | ${sourceBase}   | ${undefined}\n    `(\n      '$transformationFunction.name',\n      ({\n        transformationFunction,\n        rootPathExpression,\n        source,\n        expectedForNonExistingPath,\n      }) => {\n        test('maps each item from the source object to a new array as a top-level transformation', () => {\n          const transformation = {\n            '@path': rootPathExpression,\n            '@itemTransformation': '$.aaa',\n          };\n\n          expect(transformationFunction(source, transformation)).toStrictEqual([\n            555, 777,\n          ]);\n        });\n\n        test('maps each item from the source object to a new array on a nested transformation', () => {\n          const transformation = set({}, transformationPath, {\n            '@path': rootPathExpression,\n            '@itemTransformation': '$.aaa',\n          });\n\n          expect(transformationFunction(source, transformation)).toStrictEqual({\n            d: {\n              e: {\n                f: [555, 777],\n              },\n            },\n          });\n        });\n\n        test('supports custom functions applied on items - top-level', () => {\n          const transformation = {\n            '@path': rootPathExpression,\n            '@itemTransformation': '#addOne($.aaa)',\n          };\n\n          const transformationResult = transformationFunction(\n            source,\n            transformation,\n            { addOne: (x) => x + 1 },\n          );\n\n          expect(transformationResult).toStrictEqual([556, 778]);\n        });\n\n        test('supports custom functions applied on items', () => {\n          const transformation = set({}, transformationPath, {\n            '@path': rootPathExpression,\n            '@itemTransformation': '#addOne($.aaa)',\n          });\n\n          const transformationResult = transformationFunction(\n            source,\n            transformation,\n            { addOne: (x) => x + 1 },\n          );\n\n          expect(transformationResult).toStrictEqual({\n            d: {\n              e: {\n                f: [556, 778],\n              },\n            },\n          });\n        });\n\n        describe('invalid inputs', () => {\n          test.each`\n            path              | expected                      | description\n            ${'doesNotExist'} | ${expectedForNonExistingPath} | ${'does not exist'}\n            ${nonArrayPath}   | ${nonArrayPathValue}          | ${'is not an array'}\n          `(\n            'does not fail when a top-level path $description',\n            ({ path, expected }) => {\n              const transformation = {\n                '@path': `${rootPathExpression}.${path}`,\n                '@itemTransformation': '$.aaa',\n              };\n\n              expect(\n                transformationFunction(source, transformation),\n              ).toStrictEqual(expected);\n            },\n          );\n\n          test.each`\n            path              | expected             | description\n            ${'doesNotExist'} | ${undefined}         | ${'does not exist'}\n            ${nonArrayPath}   | ${nonArrayPathValue} | ${'is not an array'}\n          `(\n            'does not fail when a nested path $description',\n            ({ path, expected }) => {\n              const transformation = set({}, transformationPath, {\n                '@path': `${rootPathExpression}.${path}`,\n                '@itemTransformation': '$.aaa',\n              });\n\n              expect(\n                transformationFunction(source, transformation),\n              ).toStrictEqual({\n                d: {\n                  e: {\n                    f: expected,\n                  },\n                },\n              });\n            },\n          );\n        });\n      },\n    );\n  });\n\n  describe('constant transformation', () => {\n    describe.each`\n      transformationFunction       | expression                    | sourceFactory\n      ${transformToRequestMessage} | ${`$[0].${sourceObjectPath}`} | ${(sourceValue) => [sourceValue]}\n      ${transformResponseMessage}  | ${`$.${sourceObjectPath}`}    | ${(sourceValue) => sourceValue}\n    `(\n      '$transformationFunction.name - omitting fields',\n      ({ transformationFunction, expression, sourceFactory }) => {\n        const sourceValue = aString();\n        const source = sourceFactory(set({}, sourceObjectPath, sourceValue));\n\n        const nestedConstantTransformation = {\n          d: {\n            e: {\n              f: expression,\n              g: {\n                '@constant': {\n                  something: '$.value',\n                  notFunction: '#thisWontBeACustomFunction($)',\n                  '*': 'notGoingToBeSpread',\n                },\n              },\n            },\n          },\n        };\n\n        test('omits fields from a source path as a top-level transformation', () => {\n          expect(\n            transformationFunction(source, nestedConstantTransformation),\n          ).toStrictEqual({\n            d: {\n              e: {\n                f: sourceValue,\n                g: {\n                  something: '$.value',\n                  notFunction: '#thisWontBeACustomFunction($)',\n                  '*': 'notGoingToBeSpread',\n                },\n              },\n            },\n          });\n        });\n      },\n    );\n  });\n});\n"],"mappings":"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"}