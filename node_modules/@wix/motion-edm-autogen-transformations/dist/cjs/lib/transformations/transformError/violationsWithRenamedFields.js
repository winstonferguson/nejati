"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.violationsWithRenamedFields = void 0;
var _motionEdmAutogenTransformationsCore = require("@wix/motion-edm-autogen-transformations-core");
var _lodash = _interopRequireDefault(require("lodash"));
var _withRenamedArgument = require("./withRenamedArgument");
const JS_SINGLE_ARG_UNCHANGED = _motionEdmAutogenTransformationsCore.transformations.JS_SINGLE_ARG_UNCHANGED;
const chain = _lodash.default.chain,
  some = _lodash.default.some;
const collectArgumentExpressions = transformation => {
  const accumulator = {
    spreadPathsToArguments: {},
    explicitPathsToArguments: {}
  };
  (0, _motionEdmAutogenTransformationsCore.reduceTransformation)(transformation, {
    visitors: {
      NestedSpreadExpression: (acc, spreadOperatorParentPath, argumentExpressionToSpread) => {
        acc.spreadPathsToArguments[spreadOperatorParentPath] = argumentExpressionToSpread;
      },
      NestedSimpleTransformationExpression: (acc, path, simpleTransformationExpression) => {
        acc.explicitPathsToArguments[path] = simpleTransformationExpression;
      },
      CustomFunctionExpression: (acc, path, functionName, [transformationPath, wrappingName]) => {
        switch (functionName) {
          case 'wrap':
            acc.explicitPathsToArguments[`${path}.${wrappingName}`] = transformationPath;
            break;
          default:
          // ignore
        }
      }
    },

    accumulator
  });
  return accumulator;
};
const violationsWithRenamedFields = ({
  transformation,
  fieldViolations,
  argumentNames
}) => {
  const _collectArgumentExpre = collectArgumentExpressions(transformation),
    spreadPathsToArguments = _collectArgumentExpre.spreadPathsToArguments,
    explicitPathsToArguments = _collectArgumentExpre.explicitPathsToArguments;
  const allPathsToArguments = {
    ...spreadPathsToArguments,
    ...explicitPathsToArguments
  };
  const allPathsToArgumentsKeys = Object.keys(allPathsToArguments);
  return (0, _lodash.default)(fieldViolations).map(fieldViolation => {
    // In some cases, the violations error will include both some.nested and some.nested.path,
    // so we'll pick the more specific one if it's covered by the paths in the transformation.
    const containedInAMoreSpecificViolationField = some(fieldViolations, anotherViolation => anotherViolation.field.length > fieldViolation.field.length && anotherViolation.field.startsWith(fieldViolation.field) && allPathsToArgumentsKeys.includes(anotherViolation.field));
    if (containedInAMoreSpecificViolationField) {
      return null;
    }

    // This means we've got some.nested.field in the violation,
    // matched against { some: { nested: { field: $[0].a.b.c } } } in the transformation.
    // some.nested.field is replaced entirely with $[0].a.b.c, with $[0] replaced with the name of argument 0
    const exactMatchArgumentExpression = explicitPathsToArguments[fieldViolation.field];
    if (exactMatchArgumentExpression) {
      return {
        ...fieldViolation,
        field: (0, _withRenamedArgument.withRenamedArgument)(exactMatchArgumentExpression, argumentNames)
      };
    }
    const longestPartialPathMatch = chain(allPathsToArgumentsKeys).sortBy('length').reverse().find(path => fieldViolation.field.startsWith(path)).value();

    // This means we've got some.nested.field in the violation,
    // matched against { some: { nested: { *: $[0].a.b.c } } } in the transformation.
    // Only the prefix some.nested is replaced with $[0].a.b.c, with $[0] replaced with the name of argument 0
    // This can also happen in the case where the #wrap function is used.
    const partialMatchArgumentExpression = allPathsToArguments[longestPartialPathMatch];
    if (partialMatchArgumentExpression) {
      return {
        ...fieldViolation,
        field: fieldViolation.field.replace(longestPartialPathMatch, (0, _withRenamedArgument.withRenamedArgument)(partialMatchArgumentExpression, argumentNames))
      };
    }
    if (transformation === JS_SINGLE_ARG_UNCHANGED) {
      return {
        ...fieldViolation,
        field: `${argumentNames[0]}.${fieldViolation.field}`
      };
    }
    return fieldViolation;
  }).compact().value();
};
exports.violationsWithRenamedFields = violationsWithRenamedFields;
//# sourceMappingURL=violationsWithRenamedFields.js.map