{"version":3,"names":["_motionEdmAutogenTransformationsCore","require","_lodash","_interopRequireDefault","_withRenamedArgument","JS_SINGLE_ARG_UNCHANGED","transformations","chain","_","some","collectArgumentExpressions","transformation","accumulator","spreadPathsToArguments","explicitPathsToArguments","reduceTransformation","visitors","NestedSpreadExpression","acc","spreadOperatorParentPath","argumentExpressionToSpread","NestedSimpleTransformationExpression","path","simpleTransformationExpression","CustomFunctionExpression","functionName","transformationPath","wrappingName","violationsWithRenamedFields","fieldViolations","argumentNames","_collectArgumentExpre","allPathsToArguments","allPathsToArgumentsKeys","Object","keys","map","fieldViolation","containedInAMoreSpecificViolationField","anotherViolation","field","length","startsWith","includes","exactMatchArgumentExpression","withRenamedArgument","longestPartialPathMatch","sortBy","reverse","find","value","partialMatchArgumentExpression","replace","compact","exports"],"sources":["../../../../../src/lib/transformations/transformError/violationsWithRenamedFields.ts"],"sourcesContent":["import {\n  reduceTransformation,\n  transformations,\n} from '@wix/motion-edm-autogen-transformations-core';\nimport _ from 'lodash';\n\nimport { withRenamedArgument } from './withRenamedArgument';\n\nconst { JS_SINGLE_ARG_UNCHANGED } = transformations;\n\nconst { chain, some } = _;\n\nconst collectArgumentExpressions = (transformation) => {\n  const accumulator = {\n    spreadPathsToArguments: {},\n    explicitPathsToArguments: {},\n  };\n\n  reduceTransformation(transformation, {\n    visitors: {\n      NestedSpreadExpression: (\n        acc,\n        spreadOperatorParentPath,\n        argumentExpressionToSpread,\n      ) => {\n        acc.spreadPathsToArguments[spreadOperatorParentPath] =\n          argumentExpressionToSpread;\n      },\n      NestedSimpleTransformationExpression: (\n        acc,\n        path,\n        simpleTransformationExpression,\n      ) => {\n        acc.explicitPathsToArguments[path] = simpleTransformationExpression;\n      },\n      CustomFunctionExpression: (\n        acc,\n        path,\n        functionName,\n        [transformationPath, wrappingName],\n      ) => {\n        switch (functionName) {\n          case 'wrap':\n            acc.explicitPathsToArguments[`${path}.${wrappingName}`] =\n              transformationPath;\n            break;\n          default:\n          // ignore\n        }\n      },\n    },\n    accumulator,\n  });\n\n  return accumulator;\n};\n\nconst violationsWithRenamedFields = ({\n  transformation,\n  fieldViolations,\n  argumentNames,\n}) => {\n  const { spreadPathsToArguments, explicitPathsToArguments } =\n    collectArgumentExpressions(transformation);\n  const allPathsToArguments = {\n    ...spreadPathsToArguments,\n    ...explicitPathsToArguments,\n  };\n  const allPathsToArgumentsKeys = Object.keys(allPathsToArguments);\n\n  return _(fieldViolations)\n    .map((fieldViolation) => {\n      // In some cases, the violations error will include both some.nested and some.nested.path,\n      // so we'll pick the more specific one if it's covered by the paths in the transformation.\n      const containedInAMoreSpecificViolationField = some(\n        fieldViolations,\n        (anotherViolation) =>\n          anotherViolation.field.length > fieldViolation.field.length &&\n          anotherViolation.field.startsWith(fieldViolation.field) &&\n          allPathsToArgumentsKeys.includes(anotherViolation.field),\n      );\n\n      if (containedInAMoreSpecificViolationField) {\n        return null;\n      }\n\n      // This means we've got some.nested.field in the violation,\n      // matched against { some: { nested: { field: $[0].a.b.c } } } in the transformation.\n      // some.nested.field is replaced entirely with $[0].a.b.c, with $[0] replaced with the name of argument 0\n      const exactMatchArgumentExpression =\n        explicitPathsToArguments[fieldViolation.field];\n\n      if (exactMatchArgumentExpression) {\n        return {\n          ...fieldViolation,\n          field: withRenamedArgument(\n            exactMatchArgumentExpression,\n            argumentNames,\n          ),\n        };\n      }\n\n      const longestPartialPathMatch = chain(allPathsToArgumentsKeys)\n        .sortBy('length')\n        .reverse()\n        .find((path) => fieldViolation.field.startsWith(path))\n        .value();\n\n      // This means we've got some.nested.field in the violation,\n      // matched against { some: { nested: { *: $[0].a.b.c } } } in the transformation.\n      // Only the prefix some.nested is replaced with $[0].a.b.c, with $[0] replaced with the name of argument 0\n      // This can also happen in the case where the #wrap function is used.\n      const partialMatchArgumentExpression =\n        allPathsToArguments[longestPartialPathMatch];\n\n      if (partialMatchArgumentExpression) {\n        return {\n          ...fieldViolation,\n          field: fieldViolation.field.replace(\n            longestPartialPathMatch,\n            withRenamedArgument(partialMatchArgumentExpression, argumentNames),\n          ),\n        };\n      }\n\n      if (transformation === JS_SINGLE_ARG_UNCHANGED) {\n        return {\n          ...fieldViolation,\n          field: `${argumentNames[0]}.${fieldViolation.field}`,\n        };\n      }\n\n      return fieldViolation;\n    })\n    .compact()\n    .value();\n};\n\nexport { violationsWithRenamedFields };\n"],"mappings":"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"}