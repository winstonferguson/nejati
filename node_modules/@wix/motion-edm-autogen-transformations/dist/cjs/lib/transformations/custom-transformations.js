"use strict";

exports.__esModule = true;
exports.transformToRequestMessage = exports.transformResponseMessage = void 0;
var _motionEdmAutogenTransformationsCore = require("@wix/motion-edm-autogen-transformations-core");
var _jsonpathPlus = require("jsonpath-plus");
var _lodash = require("lodash");
const getValueAtPath = (json, path) => (0, _jsonpathPlus.JSONPath)({
  path,
  json,
  wrap: false
});
const getValueToSpread = ({
  sourceObject,
  expressionOfValueToSpread,
  spreadOperatorSiblingKeys
}) => {
  // eslint-disable-next-line no-use-before-define
  const valueToSpread = transform(sourceObject, expressionOfValueToSpread);
  return (0, _lodash.isPlainObject)(valueToSpread) ? (0, _lodash.pickBy)(valueToSpread, (_, k) => !spreadOperatorSiblingKeys.includes(k)) : {};
};
const resolveArgumentValues = (argumentExpressions, sourceObject) => argumentExpressions.map(expression => (0, _motionEdmAutogenTransformationsCore.isJsonPathExpression)(expression) ? getValueAtPath(sourceObject, expression) : expression);
const transform = (sourceObject, transformation, customFunctions = undefined) => (0, _motionEdmAutogenTransformationsCore.reduceTransformation)(transformation, {
  visitors: {
    TopLevelSimpleTransformationExpression: expression => getValueAtPath(sourceObject, expression),
    TopLevelCustomFunctionExpression: (functionName, argumentExpressions) => (0, _motionEdmAutogenTransformationsCore.runCustomFunctionCallExpression)({
      customFunctions,
      functionName,
      argumentValues: resolveArgumentValues(argumentExpressions, sourceObject),
      transformationParentPath: ''
    }),
    NestedSpreadExpression: (acc, path, expressionOfValueToSpread, spreadOperatorSiblingKeys) => {
      const valueToSpread = getValueToSpread({
        sourceObject,
        expressionOfValueToSpread,
        spreadOperatorSiblingKeys
      });
      const existing = (0, _lodash.get)(acc, path, {});
      (0, _lodash.set)(acc, path, {
        ...existing,
        ...valueToSpread
      });
    },
    TopLevelSpreadExpression: (acc, expressionOfValueToSpread, spreadOperatorSiblingKeys) => {
      const valueToSpread = getValueToSpread({
        sourceObject,
        expressionOfValueToSpread,
        spreadOperatorSiblingKeys
      });
      Object.keys(valueToSpread).forEach(key => {
        acc[key] = valueToSpread[key];
      });
    },
    CustomFunctionExpression: (acc, path, functionName, argumentExpressions) => {
      const customFunctionResult = (0, _motionEdmAutogenTransformationsCore.runCustomFunctionCallExpression)({
        customFunctions,
        functionName,
        argumentValues: resolveArgumentValues(argumentExpressions, sourceObject),
        transformationParentPath: path
      });
      (0, _lodash.set)(acc, path, customFunctionResult);
    },
    NestedSimpleTransformationExpression: (acc, path, simpleTransformationExpression) => {
      (0, _lodash.set)(acc, path, getValueAtPath(sourceObject, simpleTransformationExpression));
    },
    TopLevelMapArrayItems: (sourceArrayExpression, itemTransformation) => {
      const source = transform(sourceObject, sourceArrayExpression);
      return Array.isArray(source) ? source.map(item => transform(item, itemTransformation, customFunctions)) : source;
    },
    MapArrayItems: (acc, path, sourceArrayExpression, itemTransformation) => {
      const source = transform(sourceObject, sourceArrayExpression);
      const transformedValue = Array.isArray(source) ? source.map(item => transform(item, itemTransformation, customFunctions)) : source;
      (0, _lodash.set)(acc, path, transformedValue);
    },
    TopLevelOmit: (sourcePathExpression, fieldsToOmit) => {
      const source = transform(sourceObject, sourcePathExpression);
      if (source === undefined) {
        return undefined;
      }
      return (0, _lodash.isPlainObject)(source) ? (0, _lodash.omit)(source, fieldsToOmit) : sourceObject;
    },
    NestedOmit: (accumulator, path, sourcePathExpression, fieldsToOmit) => {
      const source = transform(sourceObject, sourcePathExpression);
      if (source === undefined) {
        (0, _lodash.set)(accumulator, path, undefined);
        return;
      }
      const value = (0, _lodash.isPlainObject)(source) ? (0, _lodash.omit)(source, fieldsToOmit) : source;
      (0, _lodash.set)(accumulator, path, value);
    },
    NestedConstantValue: ({
      accumulator,
      path,
      value
    }) => {
      (0, _lodash.set)(accumulator, path, value);
    }
  },
  accumulator: {}
});
const transformToRequestMessage = (sourceObject, transformation, customFunctions = undefined) => transform(sourceObject, transformation, customFunctions) || {};
exports.transformToRequestMessage = transformToRequestMessage;
const transformResponseMessage = (sourceObject, transformation, customFunctions = undefined) => transform(sourceObject, transformation, customFunctions);
exports.transformResponseMessage = transformResponseMessage;
//# sourceMappingURL=custom-transformations.js.map