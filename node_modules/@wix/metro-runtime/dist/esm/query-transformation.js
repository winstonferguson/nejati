var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { isArray, isPlainObject } from 'lodash';
import { reduceTransformation, stripJsonPathRootPrefix, } from '@wix/motion-edm-autogen-transformations-core';
var QUERY_OPERATOR_PREFIX = '$';
var QuerySections;
(function (QuerySections) {
    QuerySections["FILTER"] = "filter";
    QuerySections["SORT"] = "sort";
    QuerySections["FIELDS"] = "fields";
})(QuerySections || (QuerySections = {}));
var CommonTransformations = {
    _id: "".concat(QUERY_OPERATOR_PREFIX, ".id"),
    _createdDate: "".concat(QUERY_OPERATOR_PREFIX, ".createdDate"),
    _updatedDate: "".concat(QUERY_OPERATOR_PREFIX, ".updatedDate"),
};
export function resolveQueryFieldsTransformationPaths(transformation) {
    return (reduceTransformation(transformation, {
        visitors: {
            NestedSimpleTransformationExpression: function (acc, path, value) {
                acc[path] = stripJsonPathRootPrefix(value);
            },
            MapArrayItems: function (acc, path, sourceArrayExpression) {
                acc[path] = stripJsonPathRootPrefix(sourceArrayExpression);
            },
        },
        accumulator: {},
    }) || {});
}
export function toPlatformizedQuery(query, transformations) {
    var allTransformations = __assign(__assign({}, CommonTransformations), transformations);
    var transformationPaths = resolveQueryFieldsTransformationPaths(allTransformations);
    return Object.entries(query).reduce(function (transformedQuery, _a) {
        var key = _a[0], value = _a[1];
        if (key === QuerySections.FILTER) {
            transformedQuery[key] = transformQueryFilter(value, transformationPaths);
        }
        else if (key === QuerySections.SORT) {
            transformedQuery[key] = transformQuerySort(value, transformationPaths);
        }
        else if (key === QuerySections.FIELDS) {
            transformedQuery[key] = transformQueryFields(value, transformationPaths);
        }
        else {
            transformedQuery[key] = value;
        }
        return transformedQuery;
    }, {});
}
function transformQueryFilter(filter, transformationPaths) {
    return Object.entries(filter).reduce(function (transformedFilter, _a) {
        var filedOrOperator = _a[0], value = _a[1];
        var key = filedOrOperator.startsWith(QUERY_OPERATOR_PREFIX)
            ? filedOrOperator
            : transformationPaths[filedOrOperator] || filedOrOperator;
        if (isPlainObject(value)) {
            transformedFilter[key] = transformQueryFilter(value, transformationPaths);
        }
        else if (isArray(value)) {
            transformedFilter[key] = value.map(function (x) {
                return isPlainObject(x) ? transformQueryFilter(x, transformationPaths) : x;
            });
        }
        else {
            transformedFilter[key] = value;
        }
        return transformedFilter;
    }, {});
}
function transformQuerySort(sort, transformationPaths) {
    return sort.map(function (_a) {
        var fieldName = _a.fieldName, order = _a.order;
        return (__assign({ fieldName: transformationPaths[fieldName] || fieldName }, (order ? { order: order } : {})));
    });
}
function transformQueryFields(fields, transformationPaths) {
    return fields.map(function (field) { return transformationPaths[field] || field; });
}
//# sourceMappingURL=query-transformation.js.map