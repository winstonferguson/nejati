// Flatten a nested object to params object { field: { text: 'foo' } } => { field.text ='foo' }
function flattenParams(data, path) {
    if (path === void 0) { path = ''; }
    var params = {};
    Object.entries(data).forEach(function (_a) {
        var key = _a[0], value = _a[1];
        var isObject = value !== null && typeof value === 'object' && !Array.isArray(value);
        var fieldPath = resolvePath(path, key);
        if (isObject) {
            var serializedObject = flattenParams(value, fieldPath);
            Object.assign(params, serializedObject);
        }
        else {
            params[fieldPath] = value;
        }
    });
    return params;
}
function resolvePath(path, key) {
    return "".concat(path).concat(path ? '.' : '').concat(key);
}
export function toURLSearchParams(params) {
    var flatten = flattenParams(params);
    return Object.entries(flatten).reduce(function (urlSearchParams, _a) {
        var key = _a[0], value = _a[1];
        // inorder to make `foo: [1,2]` turn into `foo=1&foo=2` and not `foo[]=1&foo[]=2`
        var keyParams = Array.isArray(value) ? value : [value];
        keyParams.forEach(function (param) {
            if (param === undefined || param === null) {
                return;
            }
            urlSearchParams.append(key, param);
        });
        return urlSearchParams;
    }, new URLSearchParams());
}
//# sourceMappingURL=flatten-params.js.map