{"version":3,"names":["_","require","schemaSerializer","rootSchema","depSchemas","converterSets","serialize","json","converterType","transformSchema","schema","payload","result","undefined","includes","Object","entries","forEach","key","val","_getConverter$checkRe","_getConverter","renderedSchemaName","_parseLeanSchemaRef","parseLeanSchemaRef","schemaName","schemaType","isMap","isRepeatable","getConverter","checkRepetable","Array","isArray","parsedValue","map","v","applyField","applyFieldOnMap","schemaOrSerializer","maybeSchema","maybeConverter","transform","Error","name","_converterSets$name","sanitizedSchemaOrSerializer","reduce","acc","propertyName","value"],"sources":["../../../src/serializer/serializer.ts"],"sourcesContent":["import type {\n  RenderedLeanSchemaFields,\n  RenderedLeanSchema,\n} from '@wix/metro-public-utils';\nimport { parseLeanSchemaRef } from '..';\nimport { ConverterType, Payload, TypeToConverterSet } from './domain';\n\nexport function schemaSerializer(\n  rootSchema: RenderedLeanSchemaFields,\n  depSchemas: RenderedLeanSchema = {},\n  converterSets: TypeToConverterSet,\n) {\n  return function serialize(\n    json: Payload = {},\n    converterType: ConverterType,\n  ): Payload {\n    return typeof json === 'string' ? json : transformSchema(rootSchema, json);\n\n    function transformSchema(\n      schema: RenderedLeanSchemaFields,\n      payload: any,\n    ): Payload {\n      const result = {} as Payload;\n      if ([null, undefined].includes(payload)) {\n        return payload;\n      }\n\n      Object.entries(payload).forEach(([key, val]) => {\n        const renderedSchemaName = schema[key];\n        const { schemaName, schemaType } =\n          parseLeanSchemaRef(renderedSchemaName);\n\n        const isMap = schemaType === 'Map';\n        const isRepeatable =\n          getConverter(schemaName)?.checkRepetable?.(val) ?? Array.isArray(val);\n\n        let parsedValue;\n\n        if (isRepeatable) {\n          parsedValue = (val as any[]).map((v) => applyField(v, schemaName));\n        } else if (isMap) {\n          parsedValue = applyFieldOnMap(val, schemaName);\n        } else {\n          parsedValue = applyField(val, schemaName);\n        }\n\n        result[key] = parsedValue;\n      });\n\n      return result;\n    }\n\n    function applyField(val: unknown, schemaOrSerializer?: string) {\n      if (!schemaOrSerializer) {\n        return val;\n      }\n\n      const maybeSchema = depSchemas[schemaOrSerializer];\n      const maybeConverter = getConverter(schemaOrSerializer);\n\n      if (maybeConverter) {\n        return getConverter(schemaOrSerializer).transform(val);\n      } else if (maybeSchema) {\n        return transformSchema(maybeSchema, val);\n      }\n\n      throw new Error(\n        `${schemaOrSerializer} is neither schema nor serializable type`,\n      );\n    }\n\n    function getConverter(name: string) {\n      return converterSets[name]?.[converterType];\n    }\n\n    function applyFieldOnMap(val: any, sanitizedSchemaOrSerializer: string) {\n      return Object.entries(val).reduce<Record<string, any>>(\n        (acc, [propertyName, value]) => {\n          acc[propertyName] = applyField(value, sanitizedSchemaOrSerializer);\n          return acc;\n        },\n        {},\n      );\n    }\n  };\n}\n"],"mappings":"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"}