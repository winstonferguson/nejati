"use strict";

exports.__esModule = true;
exports.schemaSerializer = schemaSerializer;
var _ = require("..");
function schemaSerializer(rootSchema, depSchemas = {}, converterSets) {
  return function serialize(json = {}, converterType) {
    return typeof json === 'string' ? json : transformSchema(rootSchema, json);
    function transformSchema(schema, payload) {
      const result = {};
      if ([null, undefined].includes(payload)) {
        return payload;
      }
      Object.entries(payload).forEach(([key, val]) => {
        var _getConverter$checkRe, _getConverter;
        const renderedSchemaName = schema[key];
        const _parseLeanSchemaRef = (0, _.parseLeanSchemaRef)(renderedSchemaName),
          schemaName = _parseLeanSchemaRef.schemaName,
          schemaType = _parseLeanSchemaRef.schemaType;
        const isMap = schemaType === 'Map';
        const isRepeatable = (_getConverter$checkRe = (_getConverter = getConverter(schemaName)) == null ? void 0 : _getConverter.checkRepetable == null ? void 0 : _getConverter.checkRepetable(val)) != null ? _getConverter$checkRe : Array.isArray(val);
        let parsedValue;
        if (isRepeatable) {
          parsedValue = val.map(v => applyField(v, schemaName));
        } else if (isMap) {
          parsedValue = applyFieldOnMap(val, schemaName);
        } else {
          parsedValue = applyField(val, schemaName);
        }
        result[key] = parsedValue;
      });
      return result;
    }
    function applyField(val, schemaOrSerializer) {
      if (!schemaOrSerializer) {
        return val;
      }
      const maybeSchema = depSchemas[schemaOrSerializer];
      const maybeConverter = getConverter(schemaOrSerializer);
      if (maybeConverter) {
        return getConverter(schemaOrSerializer).transform(val);
      } else if (maybeSchema) {
        return transformSchema(maybeSchema, val);
      }
      throw new Error(`${schemaOrSerializer} is neither schema nor serializable type`);
    }
    function getConverter(name) {
      var _converterSets$name;
      return (_converterSets$name = converterSets[name]) == null ? void 0 : _converterSets$name[converterType];
    }
    function applyFieldOnMap(val, sanitizedSchemaOrSerializer) {
      return Object.entries(val).reduce((acc, [propertyName, value]) => {
        acc[propertyName] = applyField(value, sanitizedSchemaOrSerializer);
        return acc;
      }, {});
    }
  };
}
//# sourceMappingURL=serializer.js.map