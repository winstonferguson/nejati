declare const PlatformizedQueryBuilder_base: {
    new (obj?: {
        filterTree?: any;
        invalidArguments?: any;
        encoder?: any;
    } | undefined): {
        [x: string]: any;
        filterTree: any;
        invalidArguments: any;
        encoder: any;
        eq(...args: any[]): any;
        ne(...args: any[]): any;
        ge(...args: any[]): any;
        gt(...args: any[]): any;
        le(...args: any[]): any;
        lt(...args: any[]): any;
        isNotEmpty(field: any): any;
        isEmpty(field: any): any;
        startsWith(...args: any[]): any;
        endsWith(...args: any[]): any;
        contains(...args: any[]): any;
        hasSome(...args: any[]): any;
        hasAll(...args: any[]): any;
        or(orQuery: any): any;
        and(andQuery: any): any;
        not(notQuery: any): any;
        between(field: any, rangeStart: any, rangeEnd: any): any;
        getFilterModel(): any;
        setFilterModel(filterModel: any): any;
        _binaryAnd(filterOperatorSymbol: any, operatorName: any, args: any): any;
        _AndLogicalEquivalence(filterOperatorSymbol: any, operatorName: any, args: any): any;
        _AndStringOperand(filterOperatorName: any, operatorName: any, args: any): any;
        _AndSetOperand(filterOperatorName: any, operatorName: any, args: any): any;
        _makeNewFilter(field: any, filterOperatorName: any, operand: any): any;
        _buildFilter(field: any, filterOperatorName: any, operand: any): {};
        _encode(operand: any): any;
        _copy(filterTree: any, invalidArguments: any): any;
        _filterValidator(filterOperatorName: any): import("@wix/filter-builder").Validator;
    };
    [x: string]: any;
};
declare class PlatformizedQueryBuilder extends PlatformizedQueryBuilder_base {
    constructor(obj: any);
    eq(field: any, value: any): any;
    ne(field: any, value: any): any;
    ge(field: any, value: any): any;
    gt(field: any, value: any): any;
    le(field: any, value: any): any;
    lt(field: any, value: any): any;
    isNotEmpty(field: any): any;
    isEmpty(field: any): any;
    startsWith(field: any, value: any): any;
    endsWith(field: any, value: any): any;
    contains(field: any, value: any): any;
    hasSome(field: any, ...values: any[]): any;
    hasAll(field: any, ...values: any[]): any;
    between(field: any, rangeStart: any, rangeEnd: any): any;
    in(field: any, values: any): any;
    exists(field: any, value: any): any;
    ascending(...fieldNames: any[]): this;
    descending(...fieldNames: any[]): this;
    skip(offset: any): this;
    limit(limit: any): this;
    build(): {
        filter: any;
        sort: any;
        paging: any;
    };
    _transformQueryFieldName(field: any): any;
}
export { PlatformizedQueryBuilder };
//# sourceMappingURL=PlatformizedQueryBuilder.d.ts.map