"use strict";

exports.__esModule = true;
exports.PlatformizedQueryBuilder = void 0;
var _filterBuilder = require("@wix/filter-builder");
var _lodash = require("lodash");
var _renameFieldByPaths = require("./renameFieldByPaths");
// import wrapper from './proto-generated';
// The use of SortOrder adds @wix/motion-edm-autogen-query-wrapper into the chunk out of auto-fem for certain edms
// This is a workaround to avoid that
// const { SortOrder } = wrapper.wix.common;
var SortOrder = /*#__PURE__*/function (SortOrder) {
  SortOrder[SortOrder["ASC"] = 0] = "ASC";
  SortOrder[SortOrder["DESC"] = 1] = "DESC";
  return SortOrder;
}(SortOrder || {});
const WIX_DATA_EMPTY_FILTER = {
  $and: []
};

// This can be removed when the platformized-filter-builder
// will stop producing { $and: [] } for an empty filter
const toScalaCompatibleFilter = filter => (0, _lodash.isEqual)(filter, WIX_DATA_EMPTY_FILTER) ? {} : filter;
class PlatformizedQueryBuilder extends (0, _filterBuilder.filterMixin)() {
  constructor(obj) {
    super(obj);
    // We must save transformationPaths on this (without `_` prefix), due to how filterMixin works.
    // See a more details explanation on PlatformizedQueryMethodWrapper
    this.transformationPaths = obj.transformationPaths;
    this.sort = obj.sort || [];
    this.paging = obj.paging || {};
  }
  eq(field, value) {
    return super.eq(this._transformQueryFieldName(field), value);
  }
  ne(field, value) {
    return super.ne(this._transformQueryFieldName(field), value);
  }
  ge(field, value) {
    return super.ge(this._transformQueryFieldName(field), value);
  }
  gt(field, value) {
    return super.gt(this._transformQueryFieldName(field), value);
  }
  le(field, value) {
    return super.le(this._transformQueryFieldName(field), value);
  }
  lt(field, value) {
    return super.lt(this._transformQueryFieldName(field), value);
  }
  isNotEmpty(field) {
    return super.isNotEmpty(this._transformQueryFieldName(field));
  }
  isEmpty(field) {
    return super.isEmpty(this._transformQueryFieldName(field));
  }
  startsWith(field, value) {
    return super.startsWith(this._transformQueryFieldName(field), value);
  }
  endsWith(field, value) {
    return super.endsWith(this._transformQueryFieldName(field), value);
  }
  contains(field, value) {
    return super.contains(this._transformQueryFieldName(field), value);
  }
  hasSome(field, ...values) {
    return super.hasSome(this._transformQueryFieldName(field), ...values);
  }
  hasAll(field, ...values) {
    return super.hasAll(this._transformQueryFieldName(field), ...values);
  }
  between(field, rangeStart, rangeEnd) {
    return super.between(this._transformQueryFieldName(field), rangeStart, rangeEnd);
  }

  /*
    TODO: use the custom in() and exists() implementations from super (PlatformizedFilterBuilder) once it is exposed as a class
    from this module: https://github.com/wix-private/wix-data/blob/master/platformized-filter-builder/src/filterBuilder.es6#L13,
   */

  in(field, values) {
    return this._AndSetOperand('$in', '.in', [this._transformQueryFieldName(field), values]);
  }
  exists(field, value) {
    return this._binaryAnd('$exists', '.exists', [this._transformQueryFieldName(field), value]);
  }
  ascending(...fieldNames) {
    this.sort.push(...fieldNames.map(fieldName => ({
      fieldName: this._transformQueryFieldName(fieldName),
      order: SortOrder[SortOrder.ASC]
    })));
    return this;
  }
  descending(...fieldNames) {
    this.sort.push(...fieldNames.map(fieldName => ({
      fieldName: this._transformQueryFieldName(fieldName),
      order: SortOrder[SortOrder.DESC]
    })));
    return this;
  }
  skip(offset) {
    this.paging.offset = offset;
    return this;
  }
  limit(limit) {
    this.paging.limit = limit;
    return this;
  }
  build() {
    return {
      filter: toScalaCompatibleFilter(this.getFilterModel()),
      sort: this.sort,
      paging: this.paging
    };
  }
  _transformQueryFieldName(field) {
    return (0, _renameFieldByPaths.renameFieldByPaths)(this.transformationPaths, field);
  }
}
exports.PlatformizedQueryBuilder = PlatformizedQueryBuilder;
//# sourceMappingURL=PlatformizedQueryBuilder.js.map